 #define MAXROW 20   /* maximum size of grid */#define MAXCOL 60   /* dependent on the size of the screen output   */#define MAXLIST 300 /* maximum size allowed for each of the four lists  */typedef enum state { DEAD, ALIVE } State;   /* cell status  */typedef State Grid[MAXROW+2][MAXCOL+2];typedef int Gridcount[MAXROW+2][MAXCOL+2];  /* number of neighbors */typedef struct cell {        int row, col;      /* grid coordinate  */} Cell;typedef Cell ListEntry;#include "simplist.h"Boolean UserSaysYes(void);void WriteMap(Grid);void FindSize(int *, int *);void ReadMap(List *, Grid);void Vivify(ListEntry);void Kill(ListEntry);void AddNeighbors(ListEntry);void SubtractNeighbors(ListEntry);void Initialize (Grid, Gridcount, List *, List *, List *, List *); typedef struct list {    int count;    ListEntry entry[MAXLIST];} List;void CreateList(List *);void ClearList(List *);Boolean ListEmpty(const List *);Boolean ListFull(const List *);int ListSize(const List *);void AddList(ListEntry, List *);void TraverseList(List *, void (*)(ListEntry));void CopyList(List *, const List *); /* Life2: Second version of Life program Pre:  The user supplies an initial configuration of living cells.Post: The program prints a sequence of maps showing the changes in the      configuration of living cells according to the rules for the game      of Life. */#include "common.h"#include "life2.h"Grid map;           /* global: square array holding cells                   */Gridcount numbernbrs;/* global: square array holding neighbor counts        */List newlive,  /* global: the cells that have just been vivified       */     newdie,       /* global: the cells that have just died                */     maylive,  /* global: candidates to vivify in the next generation  */     maydie;       /* global: candidates to kill in the next generation    */int maxrow, maxcol; /* global: user defined grid size                       */int main(void){     Initialize(map, numbernbrs, &newlive, &newdie, &maylive, &maydie);     WriteMap(map);     printf("Proceed with the demonstration");     while (UserSaysYes()) {          TraverseList(&maylive,Vivify);/* uses numbernbrs, changes map and newlive */          TraverseList(&maydie, Kill);  /* uses numbernbrs, changes map and newdie */          WriteMap(map);          ClearList(&maylive);          ClearList(&maydie);          TraverseList(&newlive, AddNeighbors); /* changes numbernbrs, maylive, maydie */          TraverseList(&newdie, SubtractNeighbors);          ClearList(&newlive);          ClearList(&newdie);          printf("Do you want to continue viewing new generations");     }     return 0;} void Initialize (Grid map, Gridcount numbernbrs,                 List *newlive, List *newdie, List *maylive, List *maydie); typedef struct list {        int count;        ListEntry entry[MAXLIST];} List; /* AddList: Pre:  The list list has been created and is not full; x is an element of type     ListEntry.Post: The element x has been inserted as the last element of list. */void AddList(ListEntry x, List *list){     if (ListFull(list))          Warning("Attempt to insert at the end of a full list.");     else          list->entry[list->count++] = x;} /* TraverseList: Pre:  The list list has been created.Post: The action specified by function Visit has been performed on everyentry of list, beginning at the first entry and doing each in turn. */void TraverseList(List *list, void (*Visit)(ListEntry)){     int i;     for (i = 0; i < list->count; i++)          (*Visit)(list->entry[i]);} /* Warning: display a warning message Pre:  message is the warning message to display.Post: The warning message has been printed to stderr. */void Warning(char *message){     fprintf(stderr, "Warning: %s\n", message);} /* Error: display an error message Pre:  message is the error message to display.Post: The error message has been printed to stderr and theprogram terminates. */void Error(char *message){     fprintf(stderr, "Error: %s\n", message);     exit(1);} /* Simple List Driver Pre:  None.Post: Acts as a menu-driven demonstration program for simple lists.*/#include "common.h"#include <ctype.h>      /* Used for converting uppercase to lowercase.  */#include "simplist.h"void Print(ListEntry);void Introduction(void);void Help(void);char GetCommand(void);void DoCommand(char, List *); int main(void){    List list;    Introduction();    CreateList(&list);    /* endless loop; DoCommand() will call exit() to end the program.   */    while (TRUE)          DoCommand(GetCommand(), &list);    return 1;   /* This statement should never be executed. */} /* Help: Pre:  None.Post: A help screen for the program has been printed. */void Help(void){    printf( "\nThis program allows one command to be entered on each line.\n"            "For example, if the command I is entered at the command line\n"            "then the program will ask for a string of characters and\n"            "insert them one at a time into the simple list.\n");     printf( "Valid commands are:\n"        "\tI - Insert values into the simple list\n"        "\tP - Print the simple list\n"        "\tT - Traverse the simple list (same as print)\n"        "\tS - The current size of the simple list\n"        "\tD - Delete the simple list\n"        "\tC - Clear the simple list (same as delete)\n"        "\tH - This help screen\n"        "\tQ - Quit\n"        "Press <Enter> to continue.");    while (getchar() != '\n')        ;} /* GetCommand: Pre:  None.Post: Gets a valid command from the terminal and returns it through command. */char GetCommand(void){    char command;    printf( "\n\t[I]nsert entry\t[P]rint list\t[S]ize of list\n"            "\t[D]elete list\t[C]lear list\t[H]elp\n"            "\t[T]raverse the list\t\t[Q]uit.\n"            "Select command and press <Enter>:");    while (TRUE) {        while ((command = getchar()) == '\n')          ;        command = tolower(command);     /* changes case if necessary    */     if (command == 'i' || command == 'p' || command == 't' ||             command == 's' || command == 'd' || command == 'c' ||             command == 'h' || command == 'q') {          while (getchar() != '\n')               ;              return command;        }        printf("Please enter a valid command or H for help:");    }} /* DoCommand: Pre:  command contains a valid command.Post: Performs command on list. */void DoCommand(char command, List *list){    ListEntry x;    /* used to insert a new entry */    switch (command) {    case 'i':               /* insert new entries */        if (ListFull(list))            Warning("Sorry, list is full.");        else {            printf("Enter new key(s) to insert:");            while ((x = getchar()) != '\n' && !ListFull(list))                AddList(x, list);            if (x != '\n') {                Warning("The list is full, cannot insert any more entries.");                while ((x = getchar()) != '\n')                    ;            }        }        break;    case 'd':               /* deleting the entries */    case 'c':        ClearList(list);        printf("List is cleared.\n");        break;    case 'p':               /* printing the entries */    case 't':        if (ListEmpty(list))            printf("List is empty.\n");        else {            printf("\nTraversing the list; it contains:\n");            TraverseList(list, Print);  /* function as a parameter  */        }        break;    case 's':        printf("The size of the list is %d\n", ListSize(list));        break;    case 'h':        Help();        break;    case 'q':        printf("Simple list demonstration finished.\n");        exit(0);    }} /* Print: display a ListEntry. Pre:  x contains a valid list entry (a character).Post: Prints out the value of x. */void Print(ListEntry x){    printf("  %c", x);} /* Vivify: vivify cell if applicable. Pre:  The cell is a candidate to become alive.Post: Checks that cell meets all requirements to become alive.  If not,      no change is made.  If so, then cell is added to the list newlive,      and array map is updated.Uses: Function AddList, array numbernbrs, changes array map and      list newlive as global variables (side effects). */void Vivify(ListEntry cell){    if (map[cell.row][cell.col] == DEAD &&        numbernbrs[cell.row][cell.col] == 3)        if (cell.row >= 1 && cell.row <= maxrow &&      /* not on hedge */            cell.col >= 1 && cell.col <= maxcol) {            map[cell.row][cell.col] = ALIVE;            AddList(cell, &newlive);        }} /* AddNeighbors: adjust neighbor counts of vivified cell. Pre:  cell has just become alive.Post: Array numbernbrs has increased counts for all cells neighboring      cell.  If the increased neighbor count makes the cell a      candidate to be vivified [resp. killed] then the cell has been added      to list maylive [resp. maydie].Uses: Function AddList; changes array numbernbrs and      lists maylive and maydie as global variables (side effects). */void AddNeighbors(ListEntry cell){    int nbrrow,     /* loop index for row of neighbor loops */        nbrcol;     /* column loop index    */    Cell neighbor;  /* structure form of a neighbor */    for (nbrrow = cell.row-1; nbrrow <= cell.row+1; nbrrow++)        for (nbrcol = cell.col-1; nbrcol <= cell.col+1; nbrcol++)            if (nbrrow != cell.row || nbrcol != cell.col) { /* Skip cell itself. */                numbernbrs[nbrrow][nbrcol]++;                switch (numbernbrs[nbrrow][nbrcol]) {                    case 0:                         Error("Impossible case in AddNeighbors.");                         break;                    case 3:                         if (map[nbrrow][nbrcol] == DEAD) {                              neighbor.row = nbrrow; /* Set up a coordinate record. */                              neighbor.col = nbrcol;                              AddList(neighbor, &maylive);                         }                         break;                    case 4:                         if (map[nbrrow][nbrcol] == ALIVE) {                              neighbor.row = nbrrow; /* Set up a coordinate record. */                              neighbor.col = nbrcol;                              AddList(neighbor, &maydie);                         }                         break;                }   /* switch statement */            }} /* Initialize: initialize Life game. Pre:  None.Post: Array map contains the initial configuration of living and dead cells.      Array numbernbrs contains counts of living neighbors corresponding to      the configuration in array map.  List maylive contains only dead cells      and includes all candidates that may be vivified in the first generation.      List maydie contains only living cells and contains all candidates that      may die in the first generation.  Lists newlive and newdie are empty.Uses: Simple list package, functions FindSize, ReadMap, AddNeighbors. */3 void Initialize (Grid map, Gridcount numbernbrs,              List *newlive, List *newdie, List *maylive, List *maydie){        /* The following variables are used to set all entries in numbernbrs to 0. */    int row, col;    CreateList(newlive);    CreateList(newdie);    CreateList(maylive);    CreateList(maydie);    /* Put out an initial message and establish the bounds for the grid. */    FindSize(&maxrow, &maxcol);    /* Obtain the initial configuration. */    ReadMap(newlive, map);    /* Set all the entries in numbernbrs to 0. */    for (row = 0; row <= maxrow + 1; row++)        for (col = 0; col <= maxcol + 1; col++)            numbernbrs[row][col] = 0;    /* Put the candidates to live into maylive. */    TraverseList(newlive, AddNeighbors);    /* Check all the living cells to see which may die. */    CopyList(maydie, newlive);    ClearList(newlive);}