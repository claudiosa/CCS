 CreateQueue(q);Append('a',q);Serve(&x, q);Append('b', q);Serve(&y, q);Append('c', q);Append('d', q);Serve(&z, q); CreateQueue(q);Append('a',q);Append('b', q);Serve(&x, q);Append('c', q);Append(x, q);Serve(&y, q);Serve(&z, q); CreateQueue(q);Append('a', q);x = 'b';Append('x', q);Serve(&y, q);Append(x, q);Serve(&z, q);Append(y, q); if (i >= MAX-1)    i = 0;else    i++; i = (i + 1) % MAX; typedef struct queue {    int count;    int front;    int rear;    QueueEntry entry[MAXQUEUE];} Queue;void    Append(QueueEntry, Queue *);void    CreateQueue(Queue *);void    Serve(QueueEntry *, Queue *);int     QueueSize(Queue *);Boolean QueueEmpty(Queue *);Boolean QueueFull(Queue *); #define MAXQUEUE    3    /* small value for testing */typedef char QueueEntry; /* CreateQueue:  create the queue. Pre:   None.Post: The queue q has been initialized to be empty. */void CreateQueue(Queue *q){    q->count = 0;    q->front = 0;    q->rear  = -1;} /* Append:  append an entry to the queue. Pre:   The queue q has been created and is not full.Post: The entry x has been stored in the queue as its last entry.Uses: QueueFull, Error.*/void Append(QueueEntry x, Queue *q){    if (QueueFull(q))        Error("Cannot append an entry to a full queue.");    else {        q->count++;        q->rear = (q->rear + 1) % MAXQUEUE;        q->entry[q->rear] = x;    }} /* Serve:  remove the first entry in the queue. Pre:   The queue q has been created and is not empty.Post: The first entry in the queue has been removed and returned as the    value of x.Uses: QueueEmpty, Error. */void Serve(QueueEntry *x, Queue *q){    if (QueueEmpty(q))        Error("Cannot serve from an empty queue.");    else {        q->count--;        *x = q->entry[q->front];        q->front = (q->front + 1) % MAXQUEUE;    }} /* QueueSize: return the number of entries in the queue. Pre:   The queue q has been created.Post: The function returns the number of entries in the queue q. */int QueueSize(Queue *q){    return q->count;} /* QueueEmpty: returns non-zero if the queue is empty. Pre:   The queue q has been created.Post: The function returns non-zero if the queue q is empty,    zero otherwise. */Boolean QueueEmpty(Queue *q){    return q->count <= 0;} /* QueueFull: returns non-zero if the queue is full. Pre:   The queue q has been created.Post: The function returns non-zero if the queue is full,    zero otherwise. */Boolean QueueFull(Queue *q){    return q->count >= MAXQUEUE;} #include    "common.h"#include    "simdefs.h" /* simulation of an airport                                 *//* This is an outline only; not ready to compile.           */int main(void){    Queue landing, takeoff;    Queue *pl = &landing;    Queue *pt = &takeoff;    Plane plane;     int curtime;    /* current time unit                    */    int endtime;    /* total number of time units to run    */    int i;          /* loop control variable                */    CreateQueue(pl);        /* Initialize landing queue.    */    CreateQueue(pt);        /* Initialize takeoff queue.    */    for (curtime = 1; curtime <= endtime; curtime++) {        for (i = 1; i <= RandomNumber(); i++) { /* landing queue */            NewPlane(&plane);            if (QueueFull(pl))                Refuse(plane);      /* Refuse plane if full.    */            else                Append(plane, pl);  /* Add to landing queue.    */        }         for (i = 1; i <= RandomNumber(); i++) { /* takeoff queue */            NewPlane(&plane);            if (QueueFull(pt))                Refuse(plane);            else                Append(plane, pt);        }         if (!QueueEmpty(pl)) {      /* Bring plane to land. */            Serve(&plane, pl);            Land(plane);         } else if (!QueueEmpty(pt)) {   /* Allow plane take off.    */            Serve(&plane, pt);            Fly(plane);        } else            Idle();    }    Conclude();    return 0;} #define MAXQUEUE    5   /* use a small value for testing    */typedef enum action { ARRIVE, DEPART } Action;typedef struct plane {    int id;             /* identification number of airplane*/    int tm;             /* time of arrival in queue         */} Plane;typedef Plane QueueEntry;typedef struct queue {    int count;          /* number of airplanes in the queue */    int front;          /* front of the queue               */    int rear;           /* rear of the queue                */    QueueEntry entry[MAXQUEUE];} Queue; /* simulation of an airport                                 */int main(void){     Queue landing, takeoff;    Queue *pl = &landing;    Queue *pt = &takeoff;    Plane plane;     int curtime; /* current time; one unit = time for take off or landing */    int endtime;    /* total number of time units to run    */    double expectarrive;/* number of planes arriving in one unit    */    double expectdepart;/* number of planes newly ready to take off */2     int i;          /* loop control variable                */    int idletime;   /* number of units when runway is idle  */    int landwait;   /* total waiting time for planes landed */    int nland;      /* number of planes landed              */    int nplanes;    /* number of planes processed so far    */    int nrefuse;    /* number of planes refused use of airport  */    int ntakeoff;   /* number of planes taken off           */    int pri;        /* pseudo-random integer                */    int takeoffwait;/* total waiting time for take off      */     CreateQueue(pl);    CreateQueue(pt);    nplanes = nland = ntakeoff = nrefuse = 0;    landwait = takeoffwait = idletime = 0;    Start(&endtime, &expectarrive, &expectdepart);    for (curtime = 1; curtime <= endtime; curtime++) {         pri = PoissonRandom(expectarrive);        for (i = 1; i <= pri; i++) {/* Add to landing queue.    */            NewPlane(&plane, &nplanes, curtime, ARRIVE);            if (QueueFull(pl))                Refuse(plane, &nrefuse, ARRIVE);            else                Append(plane, pl);    }         pri = PoissonRandom(expectdepart);        for (i = 1; i <= pri; i++) {/* Add to takeoff queue.    */            NewPlane(&plane, &nplanes, curtime, DEPART);            if (QueueFull(pt))                Refuse(plane, &nrefuse, DEPART);            else                Append(plane, pt);        }         if (!QueueEmpty(pl)) {      /* Bring plane to land. */            Serve(&plane, pl);            Land(plane, curtime, &nland, &landwait);        } else if (!QueueEmpty(pt)) {   /* Allow plane to take off. */            Serve(&plane, pt);            Fly(plane, curtime, &ntakeoff, &takeoffwait);        } else            Idle(curtime, &idletime);    }     Conclude(nplanes, nland, ntakeoff, nrefuse, landwait,            takeoffwait, idletime, endtime, pt, pl);    return 0;} #include    "common.h"#include    "simdefs.h" /* Start: print messages and initialize the parameters. Pre:  None.Post: Asks user for responses and initializes all variables specified as    parameters.Uses: UserSaysYes. */ void Start(int *endtime, double *expectarrive, double *expectdepart){    Boolean ok;    printf("This program simulates an airport with only one runway.\n"            "One plane can land or depart in each unit of time.\n"            "Up to %d planes can be waiting to land or take off "            "at any time.\n", MAXQUEUE);     printf("How many units of time will the simulation run? ");    scanf("%d", endtime);     Randomize();    /* Initialize random number generation. */    do {        printf("Expected number of arrivals per unit time "               "(real number)? ");        scanf("%lf", expectarrive);        printf("Expected number of departures per unit time? ");        scanf("%lf", expectdepart);         if (*expectarrive < 0.0 || *expectdepart < 0.0) {            printf("These numbers must be nonnegative.\n");            ok = FALSE;        } else if (*expectarrive + *expectdepart > 1.0) {            printf("The airport will become saturated. "                   "Read new numbers? ");            ok = !UserSaysYes(); /* If user says yes, repeat loop. */        } else            ok = TRUE;    } while (ok == FALSE);} /* NewPlane: make a new record for a plane, update nplanes. Pre:  None.Post: Makes a new structure for a plane and updates nplanes. */ void NewPlane(Plane *p, int *nplanes, int curtime, Action kind){    (*nplanes)++;    p->id = *nplanes;    p->tm = curtime;    switch(kind) {    case ARRIVE:        printf("      Plane %3d ready to land.\n", *nplanes);        break;     case DEPART:        printf("      Plane %3d ready to take off.\n", *nplanes);        break;    }} /* Refuse: processes a plane when the queue is full. Pre:  None.Post: Processes a plane wanting to use runway, but the queue is full. */void Refuse(Plane p, int *nrefuse, Action kind){    switch(kind) {    case ARRIVE:        printf("      Plane %3d directed to another airport.\n", p.id);        break;     case DEPART:        printf("      Plane %3d told to try later.\n", p.id);        break;    }    (*nrefuse)++;} /* Land: process a plane that is actually landing. Pre:  None.Post: Processes a plane p that is actually landing. */void Land(Plane p, int curtime, int *nland, int *landwait){    int wait;     wait = curtime - p.tm;    printf("%3d : Plane %3d landed; in queue %d units.\n",            curtime, p.id, wait);    (*nland)++;    *landwait += wait;} /* Fly: process a plane that is actually taking off. Pre:  None.Post: Processes a plane p that is actually taking off. */void Fly(Plane p, int curtime, int *ntakeoff, int *takeoffwait){    int wait;     wait = curtime - p.tm;    printf("%3d : Plane %3d took off; in queue %d units.\n",            curtime, p.id, wait);    (*ntakeoff)++;    *takeoffwait += wait;} /* Idle:  updates variables for idle runway. Pre:  None.Post: Updates variables for a time unit when the runway is idle. */void Idle(int curtime, int *idletime){    printf("%3d : Runway is idle.\n", curtime);    (*idletime)++;} /* Conclude: write out statistics and conclude simulation. Pre:  None.Post: Writes out all the statistics and concludes the simulation. */void Conclude(int nplanes, int nland, int ntakeoff,              int nrefuse, int landwait, int takeoffwait,              int idletime, int endtime,              Queue *pt, Queue *pl){     printf("Simulation has concluded after %d units.\n", endtime);    printf("Total number of planes processed:    %3d\n", nplanes);    printf("   Number of planes landed:          %3d\n", nland);    printf("   Number of planes taken off:       %3d\n", ntakeoff);    printf("   Number of planes refused use:     %3d\n", nrefuse);    printf("   Number left ready to land:        %3d\n", QueueSize(pl));    printf("   Number left ready to take off:    %3d\n", QueueSize(pt));     if (endtime > 0)        printf("   Percentage of time runway idle:   %6.2f\n",            ((double) idletime / endtime) * 100.0);    if (nland > 0)        printf("   Average wait time to land:        %6.2f\n",            (double) landwait / nland);    if (ntakeoff > 0)        printf("   Average wait time to take off:    %6.2f\n",            (double) takeoffwait / ntakeoff);} /* Randomize: set starting point for pseudorandom integers. */void Randomize(void){    srand((unsigned int) (time(NULL) % 10000));} /* PoissonRandom: generate a pseudorandom integer accordingto the Poisson distribution. Pre:  None.Post: Generates a random nonnegative integer according to a Poisson    distribution with the expected value given as the parameter.Uses: exp, rand. */int PoissonRandom(double expectedvalue){    int n = 0;          /* counter of iterations                    */    double limit;       /* e^-v, where v is the expected value    */    double x;           /* pseudorandom number                      */    limit = exp(-expectedvalue);    x = rand() / (double) INT_MAX;    while (x > limit) {        n++;        x *= rand() / (double) INT_MAX;    }    return n;} void f(void){    char c;    ...} typedef struct node {    ...} Node;Node  *q; char *a, *b;Node *x, *y; typedef struct node {    ListEntry   entry;    struct node *next;} Node; typedef struct node {    char c;    struct node *next;} Node;Node *p, *q, *r;Node x, y, z; %.include "12.pc" %.include "12\node.ph" %.include "13.pc" %.include "14\reassign.pc" %.include "15.pc" typedef char QueueEntry;typedef struct queuenode {    QueueEntry info;    struct queuenode *next;} QueueNode; typedef struct queue {    QueueNode *front;    QueueNode *rear;} Queue; /* CreateQueue:  create the queue. Pre:   None.Post: The queue q has been initialized to be empty. */void CreateQueue(Queue *q){    q->front = q->rear = NULL;} /* AppendNode:  append an entry to the queue. Pre:   The linked queue q has been created and p points to a node        not already in q.Post: The node to which p points has been placed in the queue as its        last entry.Uses: QueueEmpty, Error.*/void AppendNode(QueueNode *p, Queue *q){    if (!p)        Error("Attempt to append a nonexistent node to the queue.");    else if (QueueEmpty(q)) /* Set both front and rear to p.          */        q->front = q->rear = p;    else {                  /* Place p after previous rear of the queue.  */        q->rear->next = p;        q->rear = p;    }} /* ServeNode:  remove the first entry in the queue. Pre:   The linked queue q has been created and is not empty.Post: The first node in the queue has been removed and parameter        p points to this node.Uses: QueueEmpty, Error. */void ServeNode(QueueNode **p, Queue *q){    if (QueueEmpty(q))        Error("Attempt to delete a node from an empty queue.");    else {        *p = q->front;          /* Pull off the front entry of the queue. */        q->front = q->front->next;/* Advance front of queue to the next node. */        if (QueueEmpty(q))      /* Is the queue now empty? */            q->rear = NULL;    }} /* Preliminary outline: program for manupulating polynomials*/int main(void){    CreateStack(stack);    while (there are more commands) {        GetCommand(cmd);        /* command to execute       */        DoCommand(cmd);    }    return 0;} /* DoCommand: do command cmd for polynomials. Pre:  The stack s has been created, and command is one of the operations        allowed in the calculator.Post: The specified operation command has been performed and the top        entries of the stack s have been changed accordingly.Uses: Help, ReadPolynomial, WritePolymial,        Add, Subtract, Multiply, Divide. */void DoCommand(char command, Stack *s){    switch(command) {     case 'h':           /* Print help instructions for the user.    */        Help();        break;     case '?':           /* Input a polynomial. */        ReadPolynomial(s);        break;     case '=':           /* Print the polynomial on the top of the stack. */        WritePolynomial(s);        break;     case '+':           /* Add top two polynomials and push answer. */        Add(s);        break;     case '-':           /* Subtract two polynomials and push answer.    */        Subtract(s);        break;     case '*':           /* Multiply two polynomials and push answer.    */        Multiply(s);        break;     case '/':           /* Divide two polynomials and push answer.  */        Divide(s);        break;    }} #include    "common.h"#include    "poly.h" #define     MAXCOMMAND      10/* Implement calculator for polynomials. Pre:  None.Post: Allows the user to do simple arithmetic with polynomials. */int main(void){    int i, n;    Stack stack;    char command[MAXCOMMAND];    Introduction();    Instructions();    CreateStack(&stack);     do {        n = ReadCommand(command, &stack);        for (i = 0; i < n; i++)            DoCommand(command[i], &stack);    } while (n > 0);    return 0;} /* ReadCommand: read a command line and save it in command.  Pre:  None.Post: The parameter commandlist has been set to a list of legitimate        commands ready to be performed by the calculator.Uses:  Prompt. */int ReadCommand(char commandlist[], Stack *s){    int c, n;    do {                        /* Read a valid command line. */        n = 0;                  /* number of characters read*/        Prompt(s);         while ((c = getchar()) != '\n') {            c = tolower(c);            if (strchr(" ,\t", c) != NULL)                 /* empty */ ;      /* Skip white-space characters. */            else if (c == 'q')                return 0;               /* quit                     */            else if (strchr("?+-*/=h", c) != NULL)                commandlist[n++] = c;   /* valid command            */            else {                printf("A command given is not valid; "                       "please enter the line again.");                fflush(stdin);                break;            }        }    } while (c != '\n');    commandlist[n] = '\0';              /* Add end of string marker. */    return n;} /* Prompt: prompt the user for command line. Pre:  None.Post: Produces a prompt for the user and discards existing newline characters,    if any.Uses: StackSize. */void Prompt(Stack *s){    int c;    printf("\nThe stack size is %d\n", StackSize(s));    printf("Enter in a command list of operations\n");    while ((c = getchar()) == '\n')        /* empty */ ;       /* Discard newlines, if any.    */    ungetc(c, stdin);   /* Back up to the last useful character. */} Add(Stack *s){  double x, y;  Pop(&x, s);  Pop(&y, s);  Push(x+y, s);} typedef struct term {    double  coef;    int     exp;} Term;typedef struct term QueueEntry;typedef struct queue Polynomial;typedef Polynomial StackEntry; /* WritePolynomial: write the polynomial at the top of the stack. Pre:  The stack s has been created and is not empty.Post: The coefficients and exponents of the polynomial on the top of        the stack s have been written out to the user.Uses: StackEmpty, Error, StackTop, TraverseQueue,        QueueEmpty, WriteTerm. */void WritePolynomial(Stack *s){    Polynomial *p;    if (StackEmpty(s))        Error("Cannot write a polynomial since the stack is empty.");    else {        StackTop(&p, s);        if (QueueEmpty(&p))            printf("zero polynomial\n");        else            TraverseQueue(p, WriteTerm);    }} /* WriteTerm: write a term of a polynomial. Pre:  A valid term currentterm exists.Post: The term currentterm is printed. */void WriteTerm(Term currentterm){    if (currentterm.coef > 0.)        printf(" +");    printf("%5.2f x^%d", currentterm.coef, currentterm.exp);} /* AppendTerm: append a new term to the polynomial. Pre:  The polynomial p exists; coefficient and exponent are valid, with        exponent less than the smallest exponent in p.Post: A new term with the given coefficient and exponent has been added        to the end of polynomial p.Uses: AppendNode, MakeQueueNode. */void AppendTerm(double coefficient, int exponent, Polynomial *p){    Term newterm;    newterm.coef = coefficient;    newterm.exp  = exponent;    AppendNode(MakeQueueNode(newterm), p);} /* ReadPolynomial: read a polynomial onto the stack. Pre:  The stack s has been created and is not full.Post: The user has supplied valid terms that have been assembled into        the polynomial newpoly in order of decreasing exponents.        The new polynomial is pushed onto the stack s.Uses: StackFull, Error, CreateQueue, AppendTerm, Push. */void ReadPolynomial(Stack *s){    double  coefficient;    int     exponent, lastexponent;    Polynomial newpoly;    if (StackFull(s))        Error("The stack is full: No more polynomials can be read at present.");    else {        CreateQueue(&newpoly);        printf("Enter coefficients and exponents for the polynomial, "                "one per line.\nExponents must be in decreasing order.\n"                "Enter a coefficient of 0 or an exponent of 0 to terminate.\n");        lastexponent = INT_MAX;        while (1) {            printf("coefficient? ");            scanf("%lf", &coefficient);            if (coefficient == 0.)                break;            printf("exponent? ");            scanf("%d", &exponent);            if (exponent >= lastexponent || exponent < 0)                Error("Bad exponent.");            else {                AppendTerm(coefficient, exponent, &newpoly);                if (exponent == 0)                    break;                lastexponent = exponent;            }        }        Push(newpoly, s);    }} /* Add: add two polynomials and push the answer onto stack. Pre:  The stack s has been created and contains at least two polynomials.Post: The top two entries of the stack s have been popped off and added        together.  The sum is then pushed onto the stack s.Uses: StackSize, Error, CreateQueue, Pop, QueueEmpty,        QueueFront, ServeTerm, AppendTerm, MoveTerm, Push. */void Add(Stack *s){    Polynomial summand1, summand2, sum;    Term firstterm, secondterm;    double coefficient;    if (StackSize(s) <= 1)        Error("The stack does not contain enough "              "polynomials for Add operation.");    CreateQueue(&sum);    Pop(&summand1, s);    Pop(&summand2, s);    while (!QueueEmpty(&summand1) && !QueueEmpty(&summand2)) {        QueueFront(&firstterm, &summand1);        QueueFront(&secondterm, &summand2);        if (firstterm.exp == secondterm.exp) {/* Add terms with equal exponents.*/            ServeTerm(&firstterm, &summand1);            ServeTerm(&secondterm, &summand2);            coefficient = firstterm.coef + secondterm.coef;            if (coefficient != 0.)  /* Exclude terms with 0. coefficient. */                AppendTerm(coefficient, firstterm.exp, &sum);        } else if (firstterm.exp > secondterm.exp)            MoveTerm(&summand1, &sum);        else            MoveTerm(&summand2, &sum);    }    /* At this point one or both of the summands has been exhausted.       At most one of the following loops will be executed. */    while (!QueueEmpty(&summand1))        MoveTerm(&summand1, &sum);    while (!QueueEmpty(&summand2))        MoveTerm(&summand2, &sum);    Push(sum, s);} /* MoveTerm: move a term from one polynomial to another. Pre:  The polynomials incoming and outgoing exist.Post: Removes a term from the incoming polynomial and appends in onto        the outgoing polynomial.Uses: ServeNode, AppendNode. */void MoveTerm(Polynomial *incoming, Polynomial *outgoing){    QueueNode *p;    ServeNode(&p, incoming);    AppendNode(p, outgoing);} if ((xxh == xxt + 1 && xxt >= 0) || (xxt == mxx && xxh == 0))    tryagain();else {    xxt++;    if (xxt > mxx)        xxt = 0;    xx[xxt] = wi;}