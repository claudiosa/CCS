 typedef Boolean AdjacencyTable[MAXVERTEX][MAXVERTEX];typedef struct graph {    int n;          /* number of vertices in the graph  */    AdjacencyTable A;} Graph; typedef struct vertex Vertex;typedef struct edge Edge;struct vertex {    Edge *firstedge;        /* start of the adjacency list      */    Vertex *nextvertex; /* next vertex on the linked list   */};struct edge {    Vertex *endpoint;       /* vertex to which the edge points  */    Edge *nextedge;     /* next edge on the adjacency list  */};typedef Vertex *Graph;  /* header for the list of vertices  */ typedef int AdjacencyList[MAXVERTEX];typedef struct graph {    int n;          /* number of vertices in the graph  */    int valence[MAXVERTEX];    AdjacencyList A[MAXVERTEX];} Graph; typedef struct edge {    Vertex endpoint;    struct edge *nextedge;} Edge;typedef struct graph {    int n;      /* number of vertices in the graph  */    Edge *firstedge[MAXVERTEX];} Graph; Visit(v);for all vertices w adjacent to v do  Traverse(w, Visit); /* DepthFirst: depth-first traversal of a graph. Pre:  The graph G has been created.Post: The function Visit has been performed at each vertex of G indepth-first order.Uses: Function Traverse produces the recursive depth-first order. */void DepthFirst(Graph G, void (*Visit)(Vertex)){    Boolean visited[MAXVERTEX];    Vertex v;    for (all v in G)        visited[v] = FALSE;    for (all v in G)        if (!visited[v])            Traverse(v, Visit);} /* Traverse: recursive traversal of a graph Pre:  v is a vertex of the graph G.Post: The depth-first traversal, using function Visit, has been completedfor v and for all vertices adjacent to v.Uses: Traverse recursively. */void Traverse(Vertex v, void (*Visit)(Vertex)){    Vertex w;    visited[v] = TRUE;    Visit(v);    for (all w adjacent to v)        if (!visited[w])            Traverse(w, Visit);} /* BreadthFirst: breadth-first traversal of a graph. Pre:  The graph G has been created.Post: The function Visit has been performed at each vertex of G, wherethe vertices are chosen in breadth-first order.Uses: Queue functions. */void BreadthFirst(Graph G, void (*Visit)(Vertex)){    Queue Q;        /* QueueEntry defined to be Vertex. */    Boolean visited[MAXVERTEX];    Vertex v, w;    for (all v in G)        visited[v] = FALSE;    CreateQueue(Q);    for (all v in G)        if (!visited[v]) {            Append(v, Q);            do {                Serve(v,Q);                if (!visited[v]) {                    visited[v] = TRUE;                    Visit(v);                }                for (all w adjacent to v)                    if (!visited[w])                        Append(w, Q);            } while (!QueueEmpty(Q));        }} /* DepthTopSort: generate depth-first topological ordering Pre:  G is a directed graph with no cycles implemented with a contiguous list     of vertices and linked adjacency lists.Post: The function makes a depth-first traversal of G and generates the      resulting topological order in the array T.Uses: RecDepthSort performs the recursive depth-first traversal. */void DepthTopSort(Graph *G, Toporder T){    Vertex v;       /* next vertex whose successors are to be ordered       */    int place;      /* next position in the topological order to be filled  */    for (v = 0; v < G->n; v++)        visited[v] = FALSE;    place = G->n - 1;    for (v = 0; v < G->n; v++)        if (!visited[v])            RecDepthSort(G, v, &place, T);} /* RecDepthSort: perform recursion for DepthTopSort. Pre:  v is a vertex of the graph G and place is the next location in the     topological order T to be determined (starting from the end of the final     ordered list).Post: The procedure puts all the successors of/ v and finally/ v itself     into the topological order T in depth-first order.Uses: Global array visited and RecDepthSort recursively. */void RecDepthSort(Graph *G, int v, int *place, Toporder T){    Vertex curvertex;   /* vertex adjacent to v       */    Edge *curedge;      /* traverses list of vertices adjacent to v   */    visited[v] = TRUE;    curedge = G->firstedge[v];  /* Find the first vertex succeeding v.    */    while (curedge) {        curvertex = curedge->endpoint;  /* curvertex is adjacent to v.  */        if (!visited[curvertex])            RecDepthSort(G, curvertex, place, T);   /* Order the successors of curvertex. */        curedge = curedge->nextedge;    /* Go on to the next immediate successor of/ v.  */    }    T[*place] = v;      /* Put v itself into the topological order.   */    (*place)--;} /* BreadthTopSort: generate breadth-first topological ordering Pre:  G is a directed graph with no cycles implemented with a contiguous     list of vertices and linked adjacency lists.Post: The function makes a breadth-first traversal of G and generates the      resulting topological order in T.Uses: Functions for processing queues. */void BreadthTopSort(Graph *G, Toporder T){    int predecessorcount[MAXVERTEX]; /* number of immediate predecessors of each vertex */    Queue Q;        /* vertices ready to be placed into the order   */    Vertex v;       /* vertex currently being visited       */    Vertex succ;    /* one of the immediate successors of v   */    Edge *curedge;  /* traverses the adjacency list of v  */    int place;      /* next position in topological order   */    /* Initialize all the predecessor counts to 0.  */    for (v = 0; v < G->n; v++)        predecessorcount[v] = 0;    /* Increase the predecessor count for each vertex that is a successor.  */    for (v = 0; v < G->n; v++)        for (curedge = G->firstedge[v]; curedge; curedge = curedge->nextedge)            predecessorcount[curedge->endpoint]++;    CreateQueue(&Q);    /* Place all vertices with no predecessors into the queue.  */    for (v = 0; v < G->n; v++)        if (predecessorcount[v] == 0)            Append(v, &Q);    /* Start the breadth-first traversal.   */    place = -1;    while (!QueueEmpty(Q)) {        /* Visit v by placing it into the topological order.  */        Serve(&v, &Q);        place++;        T[place] = v;        /* Traverse the list of immediate successors of v.    */        for (curedge = G->firstedge[v]; curedge; curedge = curedge->nextedge) {        /* Reduce the predecessor count for each immediate successor.   */            succ = curedge->endpoint;            predecessorcount[succ]--;            if (predecessorcount[succ] == 0)            /* succ has no further predecessors, so it is ready to process.   */                Append(succ, &Q);        }    }} #include <limits.h>#define INFINITY    INT_MAX     /* value for infty        */typedef int AdjacencyTable[MAXVERTEX][MAXVERTEX]; typedef int DistanceTable[MAXVERTEX];int n;                  /* number of vertices in the graph  */ AdjacencyTable cost;    /* describes the graph              */ DistanceTable D;        /* shortest distances from vertex 0 */ /* Distance: calculates the cost of the shortest path. Pre:  A directed graph is given which has n verticesby the weights given in the table cost.Post: The function finds the shortest path from vertex0 to each vertex of the graph and returns the path that itfinds in the array D. */ void Distance(int n, AdjacencyTable cost, DistanceTable D){    Boolean final[MAXVERTEX];   /* Has the distance from 0 to v been found? */                               /* final[v] is true iff v is in the set S.  */    int i;          /* repetition count for the main loop               */                           /* One distance is finalized on each pass through the loop.         */    int w;          /* a vertex not yet added to the set S              */    int v;          /* vertex with minimum tentative distance in D[]*/    int min;        /* distance of v, equals D[v]                 */    final[0] = TRUE;        /* Initialize with vertex 0 alone in the set S. */    D[0] = 0;    for (v = 1; v < n; v++) {        final[v] = FALSE;        D[v] = cost[0][v];    }    /* Start the main loop; add one vertex v to S on each pass.   */    for (i = 1; i < n; i++) {        min = INFINITY;     /* Find the closest vertex v to vertex 0. */        for (w = 1; w < n; w++)            if (!final[w])                if (D[w] < min) {                    v = w;                    min = D[w];                }        final[v] = TRUE;            /* Add v to the set S.    */        for (w = 1; w < n; w++)     /* Update the remaining distances in D.   */            if (!final[w])                if (min + cost[v][w] < D[w])                    D[w] = min + cost[v][w];    }}