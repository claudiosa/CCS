
%% TSP usando MATRIZ de DECISAO
%%

import cp,util.

matriz_adj(Matrix) =>
   Matrix = 
       [[ 0, 4, 8,10, 7,14,15],
        [ 4, 0, 7, 7,10,12, 5],
        [ 8, 7, 0, 4, 6, 8,10],
        [10, 7, 4, 0, 2, 5, 8],
        [ 7,10, 6, 2, 0, 6, 7],
        [14,12, 8, 5, 6, 0, 5],
        [15, 5,10, 8, 7, 5, 0]].

main => 
  matriz_adj(Matriz), %% leitura dos dados
  %tsp_D( Inp, Out, Out, Out),
  tsp_D( Matriz, Cidades, M_Decisao, Custo),
  
  printf("\nM_Decisao: %w\n", M_Decisao),
  print_matrix( M_Decisao ),
  printf("Sequência das Cidades: %w\n", Cidades),
  printf("Custo: %w\n", Custo),
  show_tour(Cidades, Matriz) .
%
% TSP using a matrix circuit/1 constraints.
% 
%
tsp_D(Matriz, Cidades, M_Decisao, Custo) =>
   % println(matrix=Matrix),
   Len = Matriz.length, %% simétrico
   %printf("N cidades: %d", Len),

   Cidades = new_list(Len), %%% 1a. dimensao
   Cidades :: 1..Len,
   % grafo de DECISAO que representa o resultado dos nos escolhidos
   M_Decisao = new_array (Len, Len),
   M_Decisao :: 0..1 ,
   
   % calculate upper and lower bounds of the Costs list -- HAKAN
   % repensar MELHORAR .....
   Dists = sum([Matriz[I,J] : I in 1..Len, J in 1..Len, Matriz[I,J] > 0]),
   MinDist = 0,
   MaxDist = Dists,
   printf("\n ...DISTS %d", Dists),
   Custo :: 0..MaxDist,
   % Custo :: 1..1000,
   
% aceitar somente arcos como resultados válidos aqueles existentes no GRAFO ORIGINAL
%% If any arc=0, means any connection
% Similar IDEA from assignment problems
  foreach(I in 1..Len , J  in 1..Len)
    (Matriz[I,J] #= 0) #=> (M_Decisao[I,J] #= 0)
  end,    
  
% Todo noh tem um proximo no, ou UMA aresta .. ex: 3 -> 4
% All node follow to the next
 foreach(I in 1..Len)
      sum([M_Decisao[I,J] : J in 1..Len, I != J]) #= 1
 end,     
  
% TODO noh destino de algum outro no .. ex: 5 -> 3  ... mas nao podera 4 -> 3
% All node is a destination
 foreach(J in 1..Len)
      sum([M_Decisao[I,J] : I in 1..Len, I != J]) #= 1
 end,     
  
  %% Relacionar as escolhas da M_Decisao com a
  %% Sequencia das Cidades. 
  foreach(I in 1..Len , J  in 1..Len)
    (M_Decisao[I,J] #= 1) #<=> (Cidades[I] #= J)
  end,    
 
  circuit(Cidades),
  
 %% f custo
  Custo #= sum([M_Decisao[I,J]*Matriz[I,J]:I in 1..Len , J  in 1..Len]),

  
  Vars = [Cidades, M_Decisao], %% OU  Cidades ++ M_Decisao
  solve([$min(Custo)], Vars ).
   
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
print_matrix( M ) =>
  L = M.length,
  C = M[1].length,
  printf("DESTINOS:\n      "),
  foreach(J in 1  .. C)
    printf("%d ", J)
  end,
  nl,
  foreach(I in 1  .. L)
      printf(" %d -> ", I),
      foreach(J in 1  ..  C)
      printf("%d " , M[I,J] )
    %% printf("(%d,%d): %w " , I, J, M[I,J] ) -- OK
      end,
    nl
  end.   
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% print the tour
%
show_tour(Cidades, Matriz_Custo) =>
   City = 1, % start from city 1
   N = 0,
   S_parcial = 0,
   printf("\n A viagem: \n"),
   while(N < Cidades.len) 
     City2 = Cidades[City],
     Cost2 := Matriz_Custo[City,City2],
     S_parcial := S_parcial + Cost2,
     printf("Da cidade %d --> %d custa: %d\t Acumulado: %d\n", 
             City,City2,Cost2, S_parcial),
     N := N + 1,
     City := City2
   end,
   nl.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

   /*
 
 ESTUDE a equivalencia   
   foreach(I in 1..Len , J  in 1..Len)
       (Matriz[I,J] #= 0) #=> (M_Decisao[I,J] #= 0)
      %%%(Matriz[I,J] #!= 0) #=> (M_Decisao[I,J] #= 1)
       OU >>>> if(Matriz[I,J] == 0) then
       M_Decisao[I,J] #= 0
       else
       M_Decisao[I,J] #= 1
       end
      
    end,     


*/
    
