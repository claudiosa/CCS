/*
I am trying to solve Advent of Code 2017 day 12. 

*/
% https://adventofcode.com/2017/day/12 part2 or B
import util.
%import ordset.
%import sys.

main([File]) =>
    Graph = new_map(),
    read_input(File, Graph),
    Visited = new_set(), 
    Nodes = keys(Graph),
    print(Visited),
    printf("\n NODES: %w \n Graph %w", Nodes, Graph),
 
    Init = 0,                 
    Groups = 0,

    foreach(Node in Nodes)
        if not get(Visited, Node, _) then
            % Encontra todos os nós conectados a Node
            Connected = dfs_functional(Graph, Node),
            % Marca todos como visitados
            foreach(C in Connected)
                put(Visited, C, true)
            end,
            % Incrementa o número de grupos
            Groups := Groups + 1,
            printf("\nGrupo %w: %w", Groups, Connected)
        end
    end.
    %printf("\n Visiteds: %w \n Size: %w", keys(Visited), size(Visited)).

 
%% REUSED from NENG-FA
read_input(File,EMap) =>
    Lines = read_file_lines(File), 
    foreach (Line in Lines)
        append(Str1,['<','-','>'|Str2],Line),
        V1 = to_int(Str1),
        Neibs = [to_int(Token) : Token in split(Str2,",")],
        EMap.put(V1,Neibs)
    end.

% KERNEL DFS as a FUNCTION ...
% here I tried to code using a map or a set, but does not works well
dfs_functional(Graph, InitNode, EndNode) = Sol =>
        S := InitNode,
        Visited := [InitNode],
        %printf("\nS: %w Path or Visiteds %w EndNode: %w" ,S, Visited, EndNode), 
        while (S != EndNode) do
            next_node(Graph, S, Next, Visited),
            Visited := Visited ++ [Next],
     %      printf("\nS: %w New Path %w Next: %w", S, Visited, Next), 
            S := Next
        end,
     
        Sol = Visited.


next_node(Graph, Node, Next, Visited) =>
    Neighbours = Graph.get(Node,[]),
    member(Next, Neighbours), %%% with backtracking here ....
    %printf("\n Node: %w Next %w : Visited %w" ,Node, Next, Visited),
    not membchk(Next,Visited).



%%% convert a MAP to a list with arrays
%%% each array { NODE, [NEIBOURGHS] }
map_to_list_array(Map) = Graph =>
    Keys = keys(Map),
    Graph = [{K, get(Map, K)} : K in Keys].


% Convert a list to set
list_to_set(List) = Set =>
    Set = new_set(),
    foreach(Elem in List)
        put(Set, Elem, true)
    end.

% Union of twor sets
union_sets(Set1, Set2) = Union =>
    keys(Set1) = List1,
    keys(Set2) = List2,
    L_Temp = sort_remove_dups(List1 ++ List2),
    Union = list_to_set(L_Temp).

