/*
I am trying to solve Advent of Code 2017 day 12. 

*/
% https://adventofcode.com/2017/day/12 part2 or B
import util.
%import ordset.
%import sys.

main([File]) =>
    Graph = new_map(),
    read_input(File, Graph),
    
    Visited := new_set(),
    Empty_Set := new_set(),
    %Picat> V := new_set(), print(V) .
    %(map)[]V = (map)[]

    Nodes := keys(Graph),
    print(Visited),
    printf("\n NODES: %w \n Graph %w", Nodes, Graph),
 
    Init := 0,                 
    Groups := 0,
    
    while (len(Nodes) > 3)

            foreach(EndNode in Nodes)
                %printf("\n End: %w", EndNode),
                %printf("\n\n PATH: %w", dfs_functional(Graph, 0, EndNode ))
                if (keys(dfs_functional(Graph, Init, EndNode )) != []) then
            
                One_Path := dfs_functional(Graph, Init, EndNode ),
                %printf("\n Init: %w EndNode: %w Visiteds: %w", Init, EndNode, One_Path),
                Visited := union_sets_fast(Visited, One_Path),
                %printf("\n Visited: %w \t Size %w", Visited, size(One_Path)),
                end ,   
        
                end,     
                % Incrementa o número de grupos
                Groups := Groups + 1,

                %%%%Atualizar  quem falta, atualizar um Init e Nodes
                %Novo Nodes :=  All_Nodes - Visited
                %% Novo Init será o primeiro nó em Novo Nodes
                %Nodes := keys(symmetric_difference(Graph, Visited)), 
                printf("\n NODES: %w ==> \t Visited %w", Nodes, Visited),
                Nodes := keys(set_difference(Graph, Visited)), 
                Init := first(Nodes),
                clear(Visited),
                printf("\n Init: %w ==> \t Visited %w", Init, Visited)

        end,        
        
        printf("\nGroups Number %w: Visiteds %w", Groups, keys(Visited) ).
    
    %end.
    %printf("\n Visiteds: %w \n Size: %w", keys(Visited), size(Visited)).

 
%% REUSED from NENG-FA
read_input(File,EMap) =>
    Lines = read_file_lines(File), 
    foreach (Line in Lines)
        append(Str1,['<','-','>'|Str2],Line),
        V1 = to_int(Str1),
        Neibs = [to_int(Token) : Token in split(Str2,",")],
        EMap.put(V1,Neibs)
    end.


% KERNEL DFS as a FUNCTION ... USING SETS
 dfs_functional(Graph, InitNode, EndNode) = Sol =>
        S := InitNode,
        Visited = new_set(),
        put(Visited, InitNode, true),

        %printf("\nS: %w Path or Visiteds %w EndNode: %w" ,S, Visited, EndNode), 
        while (S != EndNode) do
            %next_node_P(Graph, S, Next, Visited),  %%% Predicative version 
            Next := next_node_F(Graph, S, Visited), %%% Functional version for next node from S ...
            put(Visited, Next, true),
            % printf("\nS: %w New Path %w Next: %w", S, Visited, Next), 
            S := Next
        end,
        Sol = Visited. % Return a SET

%%% NEXT node predicative version
next_node_P(Graph, Node, Next, Visited) =>
    Neighbours = Graph.get(Node,[]),
    member(Next, Neighbours), %%% with backtracking here ....
    %printf("\n Node: %w Next %w : Visited %w" ,Node, Next, Visited),
    not(has_key(Visited,Next)).

%%% NEXT node functional version
next_node_F(Graph, Node, Visited ) = Next =>
    Neighbours = Graph.get(Node,[]),
    member(Next, Neighbours), %%% with backtracking here ....
    %printf("\n Node: %w Next %w : Visited %w" ,Node, Next, Visited),
    not(has_key(Visited,Next)).

%%% convert a MAP to a list with arrays
%%% each array { NODE, [NEIBOURGHS] }
map_to_list_array(Map) = Graph =>
    Keys = keys(Map),
    Graph = [{K, get(Map, K)} : K in Keys].

%%%% SETs UTILs  .... Need to be tests
% Helper predicate to ensure Set is not modified
copy_set(Set) = Copy =>
    Copy = new_set(),
    foreach(Key in keys(Set))
        put(Copy, Key, true)
    end.

union_sets_fast(Set1, Set2) = Union =>
    % 1. Create a copy of Set1 to be the Union set.
    Union = copy_set(Set1),
    % 2. Iterate through all keys (elements) of Set2.
    foreach(Elem in keys(Set2))
        % 3. Add each element of Set2 to the Union. 
        % If the element already exists (from Set1), put/3 simply overwrites it,
        % without duplication in the map. put without duplication
        put(Union, Elem, true)
    end.

% Convert a list to set ... necessary in union_sets
list_to_set(List) = Set =>
    Set = new_set(),
    foreach(Elem in List)
        put(Set, Elem, true)
    end.

% My union of two sets .... slow - maybe
union_sets(Set1, Set2) = Union =>
    keys(Set1) = List1,
    keys(Set2) = List2,
    L_Temp = sort_remove_dups(List1 ++ List2),
    Union = list_to_set(L_Temp).

symmetric_difference(Set1, Set2) = SymDiff =>
    % 1. Calcula Set1 - Set2 (Elementos que estão apenas em Set1).
    Diff_1_2 = set_difference(Set1, Set2),
    
    % 2. Calcula Set2 - Set1 (Elementos que estão apenas em Set2).
    Diff_2_1 = set_difference(Set2, Set1),
    
    % 3. Faz a União dos dois resultados (reutilizando o predicado otimizado anterior).
    SymDiff = union_sets_fast(Diff_1_2, Diff_2_1).


% Calcula a diferença simples: Set1 - Set2.
%%% Set1 - Set2.
set_difference(Set1, Set2) = Difference =>
    % 1. Obtém a lista de chaves de Set1.
    Keys1 = keys(Set1),
    
    % 2. Filtra Keys1 para manter apenas os elementos que NÃO estão em Set2.
    %    O predicado `not has_key(Set2, Elem)` é usado como filtro.
    DiffKeys = [Elem : Elem in Keys1, not has_key(Set2, Elem)],
    
    % 3. Converte a lista resultante de volta para um novo conjunto (mapa).
    Difference = new_set(DiffKeys).

