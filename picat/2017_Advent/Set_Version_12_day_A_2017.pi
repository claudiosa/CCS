/*
I am trying to solve Advent of Code 2017 day 12. 
Part 1 asks for all vertices connected by a path 
to vertex 0. I realize that I could write this 
as a recursive search, but I am trying to understand 
global constraints and wondered if I could use path. 

Here's the example graph, which is "test.txt".
0 <-> 2
1 <-> 1
2 <-> 0, 3, 4
3 <-> 2, 4
4 <-> 2, 3, 6
5 <-> 6
6 <-> 4, 5
7 <-> 8
8 <-> 7

In the example, 0 has a path to [2,3,4,5,6].

n this example, the following programs are in the group that contains program ID 0:

Program 0 by definition.
Program 2, directly connected to program 0.
Program 3 via program 2.
Program 4 via program 2.
Program 5 via programs 6, then 4, then 2.
Program 6 via programs 4, then 2.

Results:

 time(picat C_Version_12_day_A_2017.pi input_day_12_A.txt)
(map)[]
 Visited: [0,1,256,1018,1146,1527,1275,1530,769,1280,1534,1408,647,1537,1538,269,904,1413,1921,271,398,653,1417,1799,1927,277,531,912,1295,1422,661,1169,916,535,410,664,1046,31,1174,1809,1683,1811,415,1178,164,38,546,1436,1056,169,553,936,1444,1571,1952,303,1830,181,55,1199,1073,1582,313,1966,698,192,319,1082,1845,576,830,1211,579,453,1851,1471,584,1092,1346,331,1093,1348,1475,336,1352,1099,466,1484,1486,345,727,601,1998,1619,986,1242,100,482,1755,1756,1757,1250,1887,750,1005,243,1132,498,626,1134,120,122,757] 
 Size: 113
real	0m0,145s
user	0m0,137s
sys	0m0,008s

time(picat B_Version_12_day_A_2017.pi input_day_12_A.txt)
Sol size: 113
real	0m5,527s
user	0m5,446s
sys	0m0,052s

time(picat Set_Version_12_day_A_2017.pi input_day_12_A.txt )
real	0m0,169s
user	0m0,161s
sys	0m0,008s
*/

% https://adventofcode.com/2017/day/12 part1
import util.
%import ordset.
%import sys.

main([File]) =>
    Graph = new_map(),
    read_input(File, Graph),
    Visited := new_set(), 
    Nodes = keys(Graph),
    print(Visited),
    printf("\n NODES: %w \n Graph %w", Nodes, Graph),
    One_Path := new_set(), 
    Empty_Set = new_set(), %%%IMUTABLE
    %println( xxxxx_one_Path = keys(One_Path)),
    Init = 0,    
    % if (keys(One_Path) ==[]) then
    %     println(' xxxxxx___OKs___xxxxx')
    % end,
    
    foreach(EndNode in Nodes)
        %printf("\n---\nInit:%w \tEndNode atual: %w\n", Init, EndNode),
        One_Path := dfs_functional(Graph, Init, EndNode ),
         
        %printf("\n ONE PATH: %w \t Empty SET: %w \t End: %w", One_Path, Empty_Set, EndNode),
      
        %if (keys(One_Path) != keys(Empty_Set)) then
        if( One_Path != Empty_Set ) then
        %if (size(One_Path) > 0) then
        %if (len(keys(One_Path)) > 0) then
           
           Visited := union_sets_fast(Visited, One_Path),
           println(visited_1 = Visited)
           %printf("\n => Visiteds: %w \t One_Path %w \t ONE Size %w", Visited, One_Path, size(One_Path))         
        else
           %Visited := union_sets_fast(Visited, Empty_Set),
           println(visited_2 = Visited),
           printf("NOT REACHABLE From: %w  to %w (EndNode) Empty Path: %w\n", Init, EndNode, One_Path)
        end    
                    
    end, 

    %Visited = dfs_recursive(Graph, 0, new_set()),
    
    printf("\n Visited: %w \n Size: %w", keys(Visited), size(Visited)).

 
%% REUSED from NENG-FA
read_input(File,EMap) =>
    Lines = read_file_lines(File), 
    foreach (Line in Lines)
        append(Str1,['<','-','>'|Str2],Line),
        V1 = to_int(Str1),
        Neibs = [to_int(Token) : Token in split(Str2,",")],
        EMap.put(V1,Neibs)
    end.


% DFS recursivo: visita tudo a partir de Node
dfs_recursive(Graph, Node, Visited0) = Visited =>
    Visited1 = Visited0,
    put(Visited1, Node, true),
    foreach (N in Graph.get(Node, []))
        if not has_key(Visited1, N) then
            Visited1 := dfs_recursive(Graph, N, Visited1)
        end
    end,
    Visited = Visited1.

% Uso: Vis = dfs_recursive(Graph, 0, new_set()).

% KERNEL DFS as a FUNCTION ... USING SETS
/*
dfs_functional(Graph, InitNode, EndNode) = Sol =>
        S := InitNode,
        Visited := new_set(),
        put(Visited, InitNode, true),
        Unreachable := false,

        while ((S != EndNode) && (not Unreachable)) do
            Next := next_node_F(Graph, S, Visited),
            if var(Next) then  % Nenhum próximo nó disponível
                Unreachable := true 
            else
                put(Visited, Next, true),
                S := Next
            end
        end,  %% END WHILE
        
        if Unreachable then 
            println("\n[DFS] Caminho NÃO alcançável — retornando conjunto vazio."),
            Sol = new_set()  %%%% EMPTY SET
        else 
            %println("\n[DFS] Caminho encontrado — retornando conjunto de visitados."),
            Sol = Visited
        end.
*/
dfs_functional(Graph, InitNode, EndNode) = Sol =>
    Visited := new_set(),
    Stack := [InitNode],
    put(Visited, InitNode, true),
    Found := false,
    while (Stack != []) 
        Stack := [Current | RestStack],
        if (Current == EndNode) then
            Found := true
        end,
        Neighbors = get(Graph,Current),
        foreach(Neighbor in Neighbors)
            if not has_key(Visited, Neighbor) then
                put(Visited, Neighbor, true),
                RestStack := [Neighbor] ++ RestStack
            end
        end,
        Stack := RestStack
    end,
    if Found then
        Sol = Visited
    else
        Sol = new_set()
    end.




%%% NEXT node predicative version
next_node_P(Graph, Node, Next, Visited) =>
    Neighbours = Graph.get(Node,[]),
    member(Next, Neighbours), %%% with backtracking here ....
    %printf("\n Node: %w Next %w : Visited %w" ,Node, Next, Visited),
    not(has_key(Visited,Next))
    ;
    Next = _. %%% VAR .... undefined

%%% NEXT node functional version
% next_node_F(Graph, Node, Visited ) = Next =>
%     Neighbours = Graph.get(Node,[]),
%     member(Next, Neighbours), %%% with backtracking here ....
%     %printf("\n Node: %w Next %w : Visited %w" ,Node, Next, Visited),
%     not(has_key(Visited,Next))
%     ;
%     Next = _.

next_node_F(Graph, Node, Visited) = Next =>
    Neighbours = Graph.get(Node, []),
    Next := _,               % inicializa var (será var se não encontrar)
    Key := false,
    foreach (N in Neighbours, break(Key == true)) 
        if not has_key(Visited, N) then
            Next := N,
            Key := true          % sai do foreach assim que achar um vizinho livre
        end,
    end.


%%% convert a MAP to a list with arrays
%%% each array { NODE, [NEIBOURGHS] }
map_to_list_array(Map) = Graph =>
    Keys = keys(Map),
    Graph = [{K, get(Map, K)} : K in Keys].

%%%% SETs UTILs
% Helper predicate to ensure Set is not modified
copy_set(Set) = Copy =>
    Copy = new_set(),
    foreach(Key in keys(Set))
        put(Copy, Key, true)
    end.

union_sets_fast(Set1, Set2) = Union =>
    % 1. Create a copy of Set1 to be the Union set.
    Union = copy_set(Set1),
    % 2. Iterate through all keys (elements) of Set2.
    foreach(Elem in keys(Set2))
        % 3. Add each element of Set2 to the Union. 
        % If the element already exists (from Set1), put/3 simply overwrites it,
        % without duplication in the map. put without duplication
        put(Union, Elem, true)
    end.

% Convert a list to set ... necessary in union_sets
list_to_set(List) = Set =>
    Set = new_set(),
    foreach(Elem in List)
        put(Set, Elem, true)
    end.

% My union of two sets .... slow - maybe
union_sets(Set1, Set2) = Union =>
    keys(Set1) = List1,
    keys(Set2) = List2,
    L_Temp = sort_remove_dups(List1 ++ List2),
    Union = list_to_set(L_Temp).

    %if( keys(dfs_functional(Graph, Init, EndNode )) != []) then
        %if (len(keys(One_Path)) != 0) then
           %One_Path := copy_set(dfs_functional(Graph, Init, EndNode )),
           %printf("\n Init: %w EndNode: %w Visiteds: %w", Init, EndNode, One_Path),

/*
 dfs_functional(Graph, InitNode, EndNode) = Sol =>
        S := InitNode,
        Visited = new_set(),
        put(Visited, InitNode, true),

        %printf("\nS: %w Path or Visiteds %w EndNode: %w" ,S, Visited, EndNode), 
        while (S != EndNode) do
            %next_node_P(Graph, S, Next, Visited),  %%% Predicative version 
            Next := next_node_F(Graph, S, Visited), %%% Functional version for next node from S ...
            put(Visited, Next, true),
            % printf("\nS: %w New Path %w Next: %w", S, Visited, Next), 
            S := Next
        end,
        %if(keys(Visited) != []) then
        %    printf("\n Not reachable")
        %end,
        Sol = Visited. % Return a SET
*/
