/*
I am trying to solve Advent of Code 2017 day 12. 
Part 1 asks for all vertices connected by a path 
to vertex 0. I realize that I could write this 
as a recursive search, but I am trying to understand 
global constraints and wondered if I could use path. 

Here's the example graph, which is "test.txt".
0 <-> 2
1 <-> 1
2 <-> 0, 3, 4
3 <-> 2, 4
4 <-> 2, 3, 6
5 <-> 6
6 <-> 4, 5
7 <-> 8
8 <-> 7

In the example, 0 has a path to [2,3,4,5,6].

n this example, the following programs are in the group that contains program ID 0:

Program 0 by definition.
Program 2, directly connected to program 0.
Program 3 via program 2.
Program 4 via program 2.
Program 5 via programs 6, then 4, then 2.
Program 6 via programs 4, then 2.

Results:

 time(picat C_Version_12_day_A_2017.pi input_day_12_A.txt)
(map)[]
 Visited: [0,1,256,1018,1146,1527,1275,1530,769,1280,1534,1408,647,1537,1538,269,904,1413,1921,271,398,653,1417,1799,1927,277,531,912,1295,1422,661,1169,916,535,410,664,1046,31,1174,1809,1683,1811,415,1178,164,38,546,1436,1056,169,553,936,1444,1571,1952,303,1830,181,55,1199,1073,1582,313,1966,698,192,319,1082,1845,576,830,1211,579,453,1851,1471,584,1092,1346,331,1093,1348,1475,336,1352,1099,466,1484,1486,345,727,601,1998,1619,986,1242,100,482,1755,1756,1757,1250,1887,750,1005,243,1132,498,626,1134,120,122,757] 
 Size: 113
real	0m0,145s
user	0m0,137s
sys	0m0,008s

time(picat B_Version_12_day_A_2017.pi input_day_12_A.txt)
Sol size: 113
real	0m5,527s
user	0m5,446s
sys	0m0,052s

time(picat Set_Version_12_day_A_2017.pi input_day_12_A.txt )
real	0m0,169s
user	0m0,161s
sys	0m0,008s
*/

% https://adventofcode.com/2017/day/12 part1
import util.
import ordset.
%import sys.

main([File]) =>
    Graph = new_map(),
    read_input(File, Graph),
    Visited := new_set(), 
    Nodes = keys(Graph),
    print(Visited),
    printf("\n NODES: %w \n Graph %w\n", Nodes, Graph),
    Path := new_set(), 
    Empty_Set = new_set(), %%%IMUTABLE
    %println( xxxxx_one_Path = keys(One_Path)),
    InitNode = 0,    
 %   Path = dfs_functional(Graph, InitNode, InitNode),
 %   printf("\nNúmero de programas alcançáveis a partir do 0: %w\n", size(Path)).

    % if (keys(One_Path) ==[]) then
    %     println(' xxxxxx___OKs___xxxxx')
    % end,
    End_1 = 8, %%% sub-graphs ...
    End_2 = 1,
    println(test_1=keys(dfs_iterative_ONE(Graph, InitNode, End_1))),
    println(test_2=keys(dfs_iterative_ONE(Graph, InitNode, End_2))),

    %%% BUT .... all reacheable from InitNode
    Path := dfs_iterative_ALL(Graph, InitNode), 
    printf("\n DFS Transversal starting node: %w Visiteds: %w \n Lenght or Size: %w", InitNode, keys(Path), size(Path)).
 
%% REUSED from NENG-FA
read_input(File,EMap) =>
    Lines = read_file_lines(File), 
    foreach (Line in Lines)
        append(Str1,['<','-','>'|Str2],Line),
        V1 = to_int(Str1),
        Neibs = [to_int(Token) : Token in split(Str2,",")],
        EMap.put(V1,Neibs)
    end.
 
 
% KERNEL DFS as a FUNCTION ... USING SETS

/* dfs_functional(Graph, InitNode, EndNode) = Sol =>
        S := InitNode,
        Visited := new_set(),
        put(Visited, InitNode, true),
        
        Unreachable := false,

        while ((S != EndNode) && (not Unreachable)) do
            Next := next_node_F(Graph, S, Visited),
            println(next=Next),
            if var(Next) then  % Nenhum próximo nó disponível
                Unreachable := true 
            else
                put(Visited, Next, true),
                S := Next
            end
        end,  %% END WHILE
        
        if Unreachable then 
            println("\n[DFS] Caminho NÃO alcançável — retornando conjunto vazio."),
            Sol := new_set()  %%%% EMPTY SET
        else 
            println("\n[DFS] Caminho encontrado — retornando conjunto de visitados."),
            println(visited=Visited),
            Sol := Visited
        end.
 */

% KERNEL DFS as a FUNCTION ...
dfs_iterative_ALL(Graph, InitNode) = Sol =>
    %Current := InitNode,
    Visited := new_set(),
    put(Visited, InitNode, true), %% Add as Visited
    Stack := [InitNode], %%% Add in stack control
    %printf("\nS: %w Path or Visiteds %w EndNode: %w" ,S, Visited, EndNode), 
    while ( Stack != [] ) do
        Stack = [Current | RestStack],    %%% by pattern matching get the top of STACK ,,, that is Current
        Neighbors = get(Graph, Current, []),
        foreach(Next in Neighbors)
            if (not has_key(Visited, Next)) then
                put(Visited, Next, true),
                RestStack := [Next] ++ RestStack
                % OR ... RestStack := [Next | RestStack]
            end
        end,
       Stack := RestStack
    end,        
    Sol = Visited.

% A DFS iterative as a FUNCTION ...
dfs_iterative_ONE(Graph, InitNode,EndNode) = Sol =>
    %Current := InitNode,
    Visited := new_set(),
    put(Visited, InitNode, true), %% Add as Visited
    Stack := [InitNode], %%% Add in stack control
    Flag := true,
    %printf("\nS: %w Path or Visiteds %w EndNode: %w" ,S, Visited, EndNode), 
    while ( Stack != [] && Flag ) do
        Stack = [Current | RestStack],    %%% by pattern matching get the top of STACK ,,, that is Current
        Neighbors = get(Graph, Current, []),
        foreach(Next in Neighbors)
            if (not has_key(Visited, Next)) then
                put(Visited, Next, true),
                RestStack := [Next] ++ RestStack,
                % OR ... RestStack := [Next | RestStack]
                if (Next == EndNode) then
                    Flag := false  %%% to interrupt if EndNode was reached
                end
            end
        end,
       Stack := RestStack
    end,        
    if ( has_key(Visited, EndNode) ) then    
        Sol = Visited
    else
        Sol = new_set()  %%% NON REACHABLE ....
    end.


%%% NEXT node predicative version
next_node_P(Graph, Node, Next, Visited) =>
    Neighbours = Graph.get(Node,[]),
    member(Next, Neighbours), %%% with backtracking here ....
    %printf("\n Node: %w Next %w : Visited %w" ,Node, Next, Visited),
    not(has_key(Visited,Next))
    ;
    Next = _. %%% VAR .... undefined

next_node_F(Graph, Node, Visited) = Next =>
    Neighbours = Graph.get(Node, []),
    Next := _,               % inicializa var (será var se não encontrar)
    Key := false,
    foreach (N in Neighbours, break(Key == true) ) 
        if not has_key(Visited, N) then
            Next := N,
            Key := true  % sai do foreach assim que achar um vizinho livre
        end,
    end.

/* next_node_F(Graph, Node, Visited) = Next =>
    Neighbours = get(Graph, Node),
    foreach(Next in Neighbours, break(not has_key(Visited, Next) )
            end.
 */

%%% convert a MAP to a list with arrays
%%% each array { NODE, [NEIBOURGHS] }
map_to_list_array(Map) = Graph =>
    Keys = keys(Map),
    Graph = [{K, get(Map, K)} : K in Keys].

%%%% SETs UTILs
% Helper predicate to ensure Set is not modified
copy_set(Set) = Copy =>
    Copy = new_set(),
    foreach(Key in keys(Set))
        put(Copy, Key, true)
    end.

union_sets_fast(Set1, Set2) = Union =>
    % 1. Create a copy of Set1 to be the Union set.
    Union = copy_set(Set1),
    % 2. Iterate through all keys (elements) of Set2.
    foreach(Elem in keys(Set2))
        % 3. Add each element of Set2 to the Union. 
        % If the element already exists (from Set1), put/3 simply overwrites it,
        % without duplication in the map. put without duplication
        put(Union, Elem, true)
    end.

% Convert a list to set ... necessary in union_sets
list_to_set(List) = Set =>
    Set = new_set(),
    foreach(Elem in List)
        put(Set, Elem, true)
    end.

% My union of two sets .... slow - maybe
union_sets(Set1, Set2) = Union =>
    keys(Set1) = List1,
    keys(Set2) = List2,
    L_Temp = sort_remove_dups(List1 ++ List2),
    Union = list_to_set(L_Temp).

    %if( keys(dfs_functional(Graph, Init, EndNode )) != []) then
        %if (len(keys(One_Path)) != 0) then
           %One_Path := copy_set(dfs_functional(Graph, Init, EndNode )),
           %printf("\n Init: %w EndNode: %w Visiteds: %w", Init, EndNode, One_Path),

/*
 dfs_functional(Graph, InitNode, EndNode) = Sol =>
        S := InitNode,
        Visited = new_set(),
        put(Visited, InitNode, true),

        %printf("\nS: %w Path or Visiteds %w EndNode: %w" ,S, Visited, EndNode), 
        while (S != EndNode) do
            %next_node_P(Graph, S, Next, Visited),  %%% Predicative version 
            Next := next_node_F(Graph, S, Visited), %%% Functional version for next node from S ...
            put(Visited, Next, true),
            % printf("\nS: %w New Path %w Next: %w", S, Visited, Next), 
            S := Next
        end,
        %if(keys(Visited) != []) then
        %    printf("\n Not reachable")
        %end,
        Sol = Visited. % Return a SET
*/
