/*
I am trying to solve Advent of Code 2017 day 12. 
Part 1 asks for all vertices connected by a path 
to vertex 0. I realize that I could write this 
as a recursive search, but I am trying to understand 
global constraints and wondered if I could use path. 

Here's the example graph, which is "test.txt".
0 <-> 2
1 <-> 1
2 <-> 0, 3, 4
3 <-> 2, 4
4 <-> 2, 3, 6
5 <-> 6
6 <-> 4, 5
7 <-> 8
8 <-> 7

In the example, 0 has a path to [2,3,4,5,6].

n this example, the following programs are in the group that contains program ID 0:

Program 0 by definition.
Program 2, directly connected to program 0.
Program 3 via program 2.
Program 4 via program 2.
Program 5 via programs 6, then 4, then 2.
Program 6 via programs 4, then 2.

*/
% https://adventofcode.com/2017/day/12 part1
import util.
%import ordset.
%import sys.

main([File]) =>
    EMap = new_map(),
    read_input(File,EMap),
    %print(EMap),
    Nodes = keys(EMap),
  % map_to_list(EMap) = Graph_List,
    Graph = map_to_list_array(EMap),
    printf("\n Graph %w", Graph),
    %dfs_functional(Graph, InitNode, EndNode)
    Sol := [],
    Init = 0,                    
    foreach(EndNode in Nodes)
        %printf("\n End: %w", EndNode),
        %printf("\n\n PATH: %w", dfs_functional(Graph, 0, EndNode ))
        (Sol := dfs_functional(Graph, 0, EndNode ) ++ Sol  
        ;
        Sol := []++Sol) %% nodes out of the graph
        ,    
    end,     
    Sol_2 = remove_dups(Sol), %% or sort_
    printf("\n Sol list: %w", Sol_2),    
    printf("\n Sol size: %w", len(Sol_2)).
  

%% REUSED from NENG-FA
read_input(File,EMap) =>
    Lines = read_file_lines(File), 
    foreach (Line in Lines)
        append(Str1,['<','-','>'|Str2],Line),
        V1 = to_int(Str1),
        Neibs = [to_int(Token) : Token in split(Str2,",")],
        EMap.put(V1,Neibs)
    end.

% KERNEL DFS as a FUNCTION ...
dfs_functional(Graph, InitNode, EndNode) = Sol =>
        S := InitNode,
        Path_Temp := [InitNode],
        %println(path=Path_Temp),
        %println(end=EndNode),
        while (S != EndNode) do
            next_node(Graph, S , Next, EndNode),
            %println(next=Next),
            not membchk(Next, Path_Temp),
            Path_Temp := Path_Temp ++ [Next],
            %printf("\nS: %w New Path %w Next: %w" ,S, Path_Temp, Next),
            S := Next
            
        end,
        Sol = Path_Temp.

next_node([ {Node,Neighbours} | G], Node, Next, End_Node) ?=>
    member(Next, Neighbours),
    Next != End_Node.
    %%% when the node is not reachable....NOT SOLVE YET
    %Viz = neighbours(Next, [{Node, Neighbours} | G]),
    %print(viz=Viz),
    %Viz != [].
  
next_node([ {Node,Neighbours}  | _], Node, Next, End_Node) ?=>
    member(Next, Neighbours), %% to force a backtracking over list adjacencies
    Next == End_Node. %%% COMPARING AND FINISHING 

%% to avance or search in the graph for next node 
next_node([ _ | Graph], Node, Next, End_Node) =>
    next_node( Graph, Node, Next, End_Node).        

%%% NOT USED YET
neighbours(Node, Graph) = Vizinhos =>
    Vizinhos = flatten([Neighbour : {Node, Neighbours} in Graph, Neighbour in Neighbours]).

%%% convert a MAP to a list with arrays
%%% each array { NODE, [NEIBOURGHS] }
map_to_list_array(Map) = Graph =>
    Keys = keys(Map),
    Graph = [{K, get(Map, K)} : K in Keys].