/*
I am trying to solve Advent of Code 2017 day 12. 
Part 1 asks for all vertices connected by a path 
to vertex 0. I realize that I could write this 
as a recursive search, but I am trying to understand 
global constraints and wondered if I could use path. 

Here's the example graph, which is "test.txt".
0 <-> 2
1 <-> 1
2 <-> 0, 3, 4
3 <-> 2, 4
4 <-> 2, 3, 6
5 <-> 6
6 <-> 4, 5
7 <-> 8
8 <-> 7

In the example, 0 has a path to [2,3,4,5,6].

n this example, the following programs are in the group that contains program ID 0:

Program 0 by definition.
Program 2, directly connected to program 0.
Program 3 via program 2.
Program 4 via program 2.
Program 5 via programs 6, then 4, then 2.
Program 6 via programs 4, then 2.


Results:

 time(picat C_Version_12_day_A_2017.pi input_day_12_A.txt)
(map)[]
 Visited: [0,1,256,1018,1146,1527,1275,1530,769,1280,1534,1408,647,1537,1538,269,904,1413,1921,271,398,653,1417,1799,1927,277,531,912,1295,1422,661,1169,916,535,410,664,1046,31,1174,1809,1683,1811,415,1178,164,38,546,1436,1056,169,553,936,1444,1571,1952,303,1830,181,55,1199,1073,1582,313,1966,698,192,319,1082,1845,576,830,1211,579,453,1851,1471,584,1092,1346,331,1093,1348,1475,336,1352,1099,466,1484,1486,345,727,601,1998,1619,986,1242,100,482,1755,1756,1757,1250,1887,750,1005,243,1132,498,626,1134,120,122,757] 
 Size: 113
real	0m0,145s
user	0m0,137s
sys	0m0,008s

time(picat B_Version_12_day_A_2017.pi input_day_12_A.txt)
Sol size: 113
real	0m5,527s
user	0m5,446s
sys	0m0,052s

*/
% https://adventofcode.com/2017/day/12 part1
import util.
%import ordset.
%import sys.

main([File]) =>
    Graph = new_map(),
    read_input(File, Graph),
    Visited = new_set(), 
    Nodes = keys(Graph),
    print(Visited),
    %printf("\n NODES: %w \n Graph %w", Nodes, Graph),
 
    Init = 0,                 
    
    foreach(EndNode in Nodes)
        %printf("\n End: %w", EndNode),
        %printf("\n\n PATH: %w", dfs_functional(Graph, 0, EndNode ))
        if (dfs_functional(Graph, Init, EndNode ) != []) then
     
           One_Path := dfs_functional(Graph, 0, EndNode ),
           %printf("\n Init: %w EndNode: %w Visiteds: %w", Init, EndNode, One_Path),
           Visited := union_sets(Visited, list_to_set(One_Path)),
           %printf("\n Visited %w Size %w", Visited, size(Visited)),
         
        end    
                    
    end,     
    printf("\n Visiteds: %w \n Size: %w", keys(Visited), size(Visited)).

 
%% REUSED from NENG-FA
read_input(File,EMap) =>
    Lines = read_file_lines(File), 
    foreach (Line in Lines)
        append(Str1,['<','-','>'|Str2],Line),
        V1 = to_int(Str1),
        Neibs = [to_int(Token) : Token in split(Str2,",")],
        EMap.put(V1,Neibs)
    end.

% KERNEL DFS as a FUNCTION ...
% here I tried to code using a map or a set, but does not works well
dfs_functional(Graph, InitNode, EndNode) = Sol =>
        S := InitNode,
        Visited := [InitNode],
        %printf("\nS: %w Path or Visiteds %w EndNode: %w" ,S, Visited, EndNode), 
        while (S != EndNode) do
            next_node(Graph, S, Next, Visited),
            % Next := next_node(Graph, S, Next), FUTURE
            Visited := Visited ++ [Next],
     %      printf("\nS: %w New Path %w Next: %w", S, Visited, Next), 
            S := Next
        end,
        %Sol = list_to_set(Visited).
        Sol = Visited.


next_node(Graph, Node, Next, Visited) =>
    Neighbours = Graph.get(Node,[]),
    member(Next, Neighbours), %%% with backtracking here ....
    %printf("\n Node: %w Next %w : Visited %w" ,Node, Next, Visited),
    not membchk(Next,Visited).

% next_node(Graph, Node, Visited ) = Next =>
%     Neighbours = Graph.get(Node,[]),
%     member(Next_Temp, Neighbours), %%% with backtracking here ....
%     %printf("\n Node: %w Next %w : Visited %w" ,Node, Next, Visited),
%     not membchk(Next_Temp,Visited),
%     Next = Next_Temp .


%%% convert a MAP to a list with arrays
%%% each array { NODE, [NEIBOURGHS] }
map_to_list_array(Map) = Graph =>
    Keys = keys(Map),
    Graph = [{K, get(Map, K)} : K in Keys].


% Convert a list to set
list_to_set(List) = Set =>
    Set = new_set(),
    foreach(Elem in List)
        put(Set, Elem, true)
    end.

% Union of twor sets
union_sets(Set1, Set2) = Union =>
    keys(Set1) = List1,
    keys(Set2) = List2,
    L_Temp = sort_remove_dups(List1 ++ List2),
    Union = list_to_set(L_Temp).

