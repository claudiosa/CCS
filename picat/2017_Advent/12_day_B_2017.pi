/*
I am trying to solve Advent of Code 2017 day 12. 

*/
% https://adventofcode.com/2017/day/12 part2 or B
import util.
%import ordset.
%import sys.

main([File]) =>
    Graph = new_map(),
    read_input(File, Graph),
    Visited = new_set(), 
    Nodes = keys(Graph),
    print(Visited),
    printf("\n NODES: %w \n Graph %w", Nodes, Graph),
 
    Init = 0,                 
    
    foreach(EndNode in Nodes)
        %printf("\n End: %w", EndNode),
        %printf("\n\n PATH: %w", dfs_functional(Graph, 0, EndNode ))
        if (dfs_functional(Graph, Init, EndNode ) != []) then
     
           One_Path := dfs_functional(Graph, Init, EndNode ),
           %printf("\n Init: %w EndNode: %w Visiteds: %w", Init, EndNode, One_Path),
           Visited := union_sets(Visited, list_to_set(One_Path)),
           %printf("\n Visited %w Size %w", Visited, size(Visited)),
        end    
    
    end,     
    printf("\n Visiteds: %w \n Size: %w", keys(Visited), size(Visited)).

 
%% REUSED from NENG-FA
read_input(File,EMap) =>
    Lines = read_file_lines(File), 
    foreach (Line in Lines)
        append(Str1,['<','-','>'|Str2],Line),
        V1 = to_int(Str1),
        Neibs = [to_int(Token) : Token in split(Str2,",")],
        EMap.put(V1,Neibs)
    end.

% KERNEL DFS as a FUNCTION ...
% here I tried to code using a map or a set, but does not works well
dfs_functional(Graph, InitNode, EndNode) = Sol =>
        S := InitNode,
        Visited := [InitNode],
        %printf("\nS: %w Path or Visiteds %w EndNode: %w" ,S, Visited, EndNode), 
        while (S != EndNode) do
            next_node(Graph, S, Next, Visited),
            Visited := Visited ++ [Next],
     %      printf("\nS: %w New Path %w Next: %w", S, Visited, Next), 
            S := Next
        end,
     
        Sol = Visited.


next_node(Graph, Node, Next, Visited) =>
    Neighbours = Graph.get(Node,[]),
    member(Next, Neighbours), %%% with backtracking here ....
    %printf("\n Node: %w Next %w : Visited %w" ,Node, Next, Visited),
    not membchk(Next,Visited).



%%% convert a MAP to a list with arrays
%%% each array { NODE, [NEIBOURGHS] }
map_to_list_array(Map) = Graph =>
    Keys = keys(Map),
    Graph = [{K, get(Map, K)} : K in Keys].


% Convert a list to set
list_to_set(List) = Set =>
    Set = new_set(),
    foreach(Elem in List)
        put(Set, Elem, true)
    end.

% Union of twor sets
union_sets(Set1, Set2) = Union =>
    keys(Set1) = List1,
    keys(Set2) = List2,
    L_Temp = sort_remove_dups(List1 ++ List2),
    Union = list_to_set(L_Temp).

