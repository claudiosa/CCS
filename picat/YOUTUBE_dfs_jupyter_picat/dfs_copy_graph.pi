%%picat
import util.
import ordset.
import sys.
%%%%import a_graph_11_nodes.
%load("a_graph_11_nodes.pi").
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/*
Grafo orientado ciclico - NAO EH UM DAG
                     1
                    /|\ 
                   / | \
                 /  |  \
                /   |   \
            ->2    3    4
             |\    |   /|
            |  \   |  / |
            |   \  | /  | 
            |      5    |
            |     / \  |
            |    /   \|
            |   /     7----------------> 1
            |  /     (volta ao 1) 
            | /
            |/
            6     
*/
grafo() = G =>
    G = [
        {1,[2,3,4]},
        {2,[5,6]},
        {3,[5]},
        {4,[5,7]},
        {5,[6,7]},
        {6,[]},
        {7,[1]}
    ].

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
main ?=>
    
    Grafo = grafo(),
    Init_Node = 2, %%%% ficou mais interessante 
    %% End_Node =  vira do foreach,
    Nodes = all_nodes(Grafo), %%%%
    %Init_Node= min(L_Nodes),
   
    printf("\n All Nodes: %w", L_Nodes),
    
    %printf("\n Start: %w\t  End: %w\n All_Nodes: %w",Init_Node, End_Node, L_Nodes),
    %delete(Nodes, Init_Node) = Rest,

    All_Edges =[],
    foreach(End_Node in Nodes)
        printf("\n Start: %w\t  End: %w", Init_Node, End_Node),
    if ( dfs_copied(Graph, Init_Node, End_Node, [Init_Node], [], Sol) ) then
            printf("\n Path: %w",   reverse(Sol[1])),
            printf("\t Edges: %w\n", reverse(Sol[2])),
            All_Edges := All_Edges++Sol[2]
        else
            printf("\n ==> NO reachable from: %w to: %w\n", Init_Node, End_Node)
        end
    end,
    printf("\n Finally \n"),       
    Edges_Not_Repeated = remove_dups(All_Edges),
    Set_Edges_Visited = new_ordset(Edges_Not_Repeated),
    printf("\n All Edges Visited: %w ", Set_Edges_Visited ),
    %subtract(OSet1,OSet2)=OSet3: This function returns an ordered set that contains all of the elements of OSet1 which are not in OSet2.
    Set_Edges = new_ordset(L_Edges),
    Not_Visited = subtract(Set_Edges, Set_Edges_Visited),
    printf("\n NOT Visited Edges: %w ", Not_Visited ),

    %%% ARRAY usefull
    %%%% ESTUDO AQUI ....

    printf("\n\n PAUSA AQUI: UM ESTUDO "), 
    Estudo = findall(Sol,  (dfs_connected(Graph,'02', '72', ['02'], [], Sol))  ),
    Temp1 = get_second_elements(Estudo),
    printf("\n Alternative Number Paths from  '02' -> '72': %w ", len(Temp1)), 
    printf("\n Alternative Paths de  '02' -> '72': %w ", Temp1), 
    Temp2 =  remove_dups(flatten(Temp1)),
    printf("\n Estudo de  '02' atÃ© '72': %w ", Temp2),        

    printf("\n End of main: OK\n").
    %%%% 
    %spy($dfs_connected/5),
    %nospy,

main => printf("\n End of main with fail ... NO SOLUTION").   
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/*** pegar da lista */

all_nodes( Grafo ) = Nodes =>
        %Nodes = sort( [N : Termo in Grafo, {N, _} = Termo ]) . 
        Nodes = [N : Termo in Grafo, {N, _} = Termo ] .   

get_second_elements(L) = Result =>
    Result = [Array[2] : Array in L]. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% KERNEL DFS

dfs_copied(Graph, Node, End_Node, L_Nodes_Visited, L_Edges, Sol) ?=>
    Node == End_Node,
    %N = len(L_Edges),
    %N>0,
    %%%printf("\n Theres is a path!").
    Sol = {L_Nodes_Visited, L_Edges}.
    
/*
dfs_connected(Graph, Node, End_Node, L_Nodes_Visited, L_Edges, Sol) ?=>
    Node == End_Node,
    N = len(L_Edges),
    N==0,
    Sol = 'NO'.
*/   

dfs_copied(Graph, Node, End_Node, Partial_Path, Partial_Edges, Sol) =>
        % next_node(Graph, Node, Next, Edge), % ORIG
        next_node(Graph, Node, Next, End_Node, Edge), % hakank
        % nonvar(Edge), % hakank: A fix for 02 -> 222
        not membchk(Next, Partial_Path), 
        append([Next], Partial_Path,  L_Nodes_Visited),
        append([Edge], Partial_Edges, L_Edges),
    dfs_copied(Graph, Next, End_Node, L_Nodes_Visited, L_Edges, Sol).



 /*
dfs_connected(_, _, _, _, Sol) =>
    Sol='NO'.
*/
%   {[],[]},!.      

%%next_node(Graph, Node, Next, Edge) =>

%
% hakank: Added End_Node to next_node.
%
next_node([], Node, Next, End_Node) ?=>
    nonvar(Next), % hakank: A fix for 02 -> 222
    printf("\n None sucessor in this graph for the node: %w", [Node]).

next_node([(Source, Target)| Graph], Node, Next, End_Node ?=>
    Source == Node,
    Next = Target.

next_node([(Source, Target)| Graph], Node, Next, End_Node) =>
    % Source != Node, % ORIG
    Source != End_Node, % hakank
    next_node( Graph, Node, Next, End_Node).        


/* ****************************************************************************/
