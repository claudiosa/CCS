%% https://github.com/alviano/lpcp-contest-2020/tree/master/problem-4
%% usage: picat masyu instance.in

import sat, util.

main([File_Name]) =>
        
    reading_the_FILE(File_Name, Size , White, Black, Grid),   
    
    masyu_model(Dec_Grid, Size , White, Black, Grid),
    print("\n Grid read ... original:\n"),
    print_matrix( Grid, Size, Size ),
    print("\n Decision Grid  ... from model:\n"),
    print_matrix( Dec_Grid, Size, Size ),
    
   
    
    print("\n THE END ...").
       

masyu_model(Dec_Grid, N , N_White, N_Black, Grid) =>
    %writef("\n N: %w", N),
    Dec_Grid = new_array(N,N),
    Dec_Grid :: 0..1,

    %% Select all Blacks and White a priori
    %% these are reference
    foreach (I in 1..N)
     foreach (J in 1..N)
        if (Grid[I,J] == 'w') then 
            Dec_Grid[I,J] #= 1
        end,
        if (Grid[I,J] == 'b') then 
            Dec_Grid[I,J] #= 1
        end          
     end   
    end,
    %%% A channeling constraint for the possibilites
    %% for each black or white cell
    foreach (I in 1..N)
      foreach (J in 1..N)
    %VERTICAL conexion of w
    if ((Grid[I,J] == 'w') && (I > 1) && (I < N))
       then
        (Dec_Grid[I-1,J] #= 1 &&   
         Dec_Grid[I+1,J] #= 1
         ) 
       end
    %% THESE TWO CONDITIONS MUST BE CHANNELLING    
    %%% HORIZONTAL conexion of w    
    ; %% OR
    if ((Grid[I,J] == 'w') && (J > 1) && (J < N))
        then         
        (Dec_Grid[I,J-1] #= 1 &&   
         Dec_Grid[I,J+1] #= 1
        )
        end, 
     end   
    end,
    
    solve(Dec_Grid).    




reading_the_FILE(File_Name, N, White, Black, Grid) =>
    % FD : File Descriptor
    FD = open(File_Name),  %% FILE DESCRIPTOR
    [Size, White, Black] = [to_int(W) : W in read_line(FD).split()],
    %% writef("\n %w %w %w", Size, White, Black),
    N = Size + 1, %%% description ... start in 0 up to Size
    Grid = new_array(N,N),
    %% Filling a Grid with '.'
    foreach (I in 1..N)
        foreach (J in 1..N)
        Grid[I,J] := '.'
        end
    end,
    % writef("\n %w", Grid),
    % Now ... put 'w' and 'b'
    foreach (I in 1..White)  %% reading a line 
       [X , Y] = [to_int(W) : W in read_line(FD).split()],
       % writef("\t (%w %w)", X,Y),
       Grid[(X+1),(Y+1)] := 'w'
    end ,
 
    %writef("\n\n Where is  w ==> %w",Grid),
    foreach (I in 1..Black)  %% reading a line 
       [X,Y] = [to_int(W) : W in read_line(FD).split()],
       % writef("\t (%w %w)", X,Y),
       Grid[(X+1),(Y+1)] := 'b'
    end ,
    % writef("\n\n Map read ==> %w", Grid),

    print("\n End of Reading").   
    

/******************************* AUX predicates **********************/
print_matrix( M, L, C ) =>
    %L = M.length,
    %C = M[1].length,
     nl,
      foreach(I in 1  .. L)
        foreach(J in 1  ..  C)
         printf("%w " , M[I,J] )
        %% printf("(%d,%d): %w " , I, J, M[I,J] ) -- FINE
        end,
        nl
      end.   

/* 
        

        (Grid[I,J] #= w) #<=> Dec_Grid[I,J] #= 1,
      (Grid[I,J] #= b) #<=> Dec_Grid[I,J] #= 1 
*/    