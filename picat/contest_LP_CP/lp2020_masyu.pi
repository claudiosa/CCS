%% https://github.com/alviano/lpcp-contest-2020/tree/master/problem-4
%% usage: picat masyu instance.in
%% to run picat lp2020_masyu masyu_sample.in 
import sat, util.

main([File_Name]) =>
        
    reading_the_FILE(File_Name, Size , White, Black, Grid),   
    
    masyu_model(Dec_Grid, Size , White, Black, Grid),
    print("\n Grid read ... original:\n"),
    print_matrix( Grid, Size, Size ),
    print("\n Decision Grid  ... from model:\n"),
    print_matrix( Dec_Grid, Size, Size ),
    
   
    
    print("\n THE END ...").
       

masyu_model(Dec_Grid, N , N_White, N_Black, Grid) =>
    %writef("\n N: %w", N),
    Dec_Grid = new_array(N,N),
    Dec_Grid :: 0..1,
    %%% HERE NEEDS ... probably another approach
    %% to ENUMERATE a SEQUENCE of CELLS to be
    %% connected
    %% Similar KNIGHTS TOUR

    %% Select all Blacks and White a priori
    %% these are reference
    foreach (I in 1..N)
     foreach (J in 1..N)
        if (Grid[I,J] == 'w') then 
            Dec_Grid[I,J] #= 1
        end,
        if (Grid[I,J] == 'b') then 
            Dec_Grid[I,J] #= 1
        end          
     end   
    end,
    %%% A channeling constraint for the possibilites
    %% for each WHITE cell
    foreach (I in 1..N)
      foreach (J in 1..N)
    %VERTICAL conexion of w
    if ((Grid[I,J] == 'w') && (I > 1) && (I < N)
         && (J > 1) && (J < N))
       then
        ((Dec_Grid[I-1,J] #= 1) #/\   
         (Dec_Grid[I+1,J] #= 1) 
        %#/\(Dec_Grid[I,J] #= 1)
        )
        #^  %%% OR-Exclusive
        %%% HORIZONTAL conexion of w    
        ((Dec_Grid[I,J-1] #= 1) #/\      
         (Dec_Grid[I,J+1] #= 1) 
         %#/\(Dec_Grid[I,J] #= 1)
        ) 
       end
    %% THESE TWO CONDITIONS MUST BE REYFING    
     end   
    end,
%%% for Black cells ... a curve
foreach (I in 1..N)
    foreach (J in 1..N)
    %VERTICAL conexion of w
    if ((Grid[I,J] == 'b') && (I > 1) && (I < N)
    && (J > 1) && (J < N))
    then
    ((Dec_Grid[I-1,J] #= 1) #/\   
     (Dec_Grid[I,J+1] #= 1) 
    )
    #^  %%% OR-Exclusive
    ((Dec_Grid[I-1,J] #= 1) #/\   
     (Dec_Grid[I,J-1] #= 1) 
    )
    #^  %%% OR-Exclusive
    ((Dec_Grid[I+1,J] #= 1) #/\   
     (Dec_Grid[I,J+1] #= 1) 
    )
    #^  %%% OR-Exclusive
    ((Dec_Grid[I+1,J] #= 1) #/\   
     (Dec_Grid[I,J-1] #= 1) 
    )
    end
%% THESE TWO CONDITIONS MUST BE REYFING    
    end   
    end,
    %%% w in first and last line - row
    foreach (I in {1,N})
      foreach(J in 1..N)  
        if ((Grid[I,J] == 'w') )
        then
        ((Dec_Grid[I,J-1] #= 1) #/\   
        (Dec_Grid[I,J+1] #= 1)) 
        end
       end
    end, 

    %%% W in first and last Collun
   foreach (J in {1,N})
    foreach(I in 1..N)  
      if ((Grid[I,J] == 'w') )
      then
      ((Dec_Grid[I-1,J] #= 1) #/\   
      (Dec_Grid[I+1,J] #= 1)) 
      end
     end
    end,     




    solve(Dec_Grid).    




reading_the_FILE(File_Name, N, White, Black, Grid) =>
    % FD : File Descriptor
    FD = open(File_Name),  %% FILE DESCRIPTOR
    [Size, White, Black] = [to_int(W) : W in read_line(FD).split()],
    %% writef("\n %w %w %w", Size, White, Black),
    N = Size + 1, %%% description ... start in 0 up to Size
    Grid = new_array(N,N),
    %% Filling a Grid with '.'
    foreach (I in 1..N)
        foreach (J in 1..N)
        Grid[I,J] := '.'
        end
    end,
    % writef("\n %w", Grid),
    % Now ... put 'w' and 'b'
    foreach (I in 1..White)  %% reading a line 
       [X , Y] = [to_int(W) : W in read_line(FD).split()],
       % writef("\t (%w %w)", X,Y),
       Grid[(X+1),(Y+1)] := 'w'
    end ,
 
    %writef("\n\n Where is  w ==> %w",Grid),
    foreach (I in 1..Black)  %% reading a line 
       [X,Y] = [to_int(W) : W in read_line(FD).split()],
       % writef("\t (%w %w)", X,Y),
       Grid[(X+1),(Y+1)] := 'b'
    end ,
    % writef("\n\n Map read ==> %w", Grid),

    print("\n End of Reading").   
    

/******************************* AUX predicates **********************/
print_matrix( M, L, C ) =>
    %L = M.length,
    %C = M[1].length,
     nl,
      foreach(I in 1  .. L)
        foreach(J in 1  ..  C)
         printf("%w " , M[I,J] )
        %% printf("(%d,%d): %w " , I, J, M[I,J] ) -- FINE
        end,
        nl
      end.   

/* 
        

        (Grid[I,J] #= w) #<=> Dec_Grid[I,J] #= 1,
      (Grid[I,J] #= b) #<=> Dec_Grid[I,J] #= 1 
*/    