import util.
import datetime.
import planner.

%main(Args) =>
    % Leitura do arquivo e configuração inicial
main ?=>    
    File = "16_A_sample.txt",
    %File = "16_B_sample.txt",    
    %File = Args[1],
    InputLines = read_file_lines(File),
    N_Rows = length(InputLines),
    N_Cols = length(first(InputLines)),

    % Conversão do mapa para uma matriz 2D
    Grid_2D = new_array(N_Rows, N_Cols),
    CurrentRow := 1,
    foreach(Line in InputLines)
        Grid_2D[CurrentRow] = to_array(Line),
        CurrentRow := CurrentRow + 1
    end,

    % Encontrar posições iniciais e finais
    [X_s, Y_s] = find_symbol(Grid_2D, 'S'),
    [X_e, Y_e] = find_symbol(Grid_2D, 'E'),

    % Estado inicial
    Initial = {[X_s, Y_s], [], [X_e, Y_e], [N_Rows, N_Cols], Grid_2D},

    % Planejamento
    best_plan(Initial, Plan, Cost),

    % Saída do resultado
    printf("Plan: %w\nCost: %w\n", Plan, Cost),
    printf(" \n =========================================\n "),
    print("THE END").

main => println("NO").
% Função para encontrar um símbolo no mapa
find_symbol(M, Symbol) = R =>
    Positions = [ [I, J] : I in 1..M.length, J in 1..M[1].length, M[I, J] == Symbol ],
    R = Positions[1].

%% to stop the planner
final({[X, Y], Path, [X_e, Y_e], [N_Rows, N_Cols], Grid}) =>
    X == X_e,
    Y == Y_e,
    printf("\nSolution Found!\n"),
    print_map(Path).

% Ações do planejador
action({[X, Y], Path, EndPos, [N_Rows, N_Cols], Grid}, NextState, forward, Cost) ?=>
    % Calcular nova posição (movimento para frente)
    % Tentar mover para a direita
    (Y + 1 =< N_Cols, Grid[X, Y + 1] = '.', X_new = X, Y_new = Y + 1
    ;
    % Tentar mover para baixo
    X + 1 =< N_Rows, Grid[X + 1, Y] = '.', X_new = X + 1, Y_new = Y
    ;
    % Tentar mover para a esquerda
    Y - 1 >= 1, Grid[X, Y - 1] = '.', X_new = X, Y_new = Y - 1
    ;
    % Tentar mover para cima
    X - 1 >= 1, Grid[X - 1, Y] = '.', X_new = X - 1, Y_new = Y),

    % Verificar se a nova posição é válida e não visitada
    not membchk([X_new, Y_new], Path),
    Path_New := [[X_new, Y_new]] ++ Path,

    % Atualizar estado
    NextState = {[X_new, Y_new], Path_New, EndPos, [N_Rows, N_Cols], Grid},
    Cost = 1.

action({[X, Y], Path, EndPos, [N_Rows, N_Cols], Grid}, NextState, turn, Cost) ?=>
    % Girar no lugar (não muda a posição, mas simula uma rotação)
    % Como não temos direção explícita, consideramos que a rotação é válida
    % se estiver em um ponto válido (.)
    Grid[X, Y] = '.',

    % Atualizar estado
    NextState = {[X, Y], Path, EndPos, [N_Rows, N_Cols], Grid},
    Cost = 1000.

%%% AUXILIARY predicates

print_map(M) =>
    L = M.length,
    C = M[1].length,
    nl,
    foreach(I in 1..L)
        foreach(J in 1..C)
            printf("%w ", M[I,J])
        end,
        nl
    end.

count_char(M, C) = Count =>
    Count = sum([1 : I in 1..M.length, J in 1..M[I].length, M[I,J] == C]).
