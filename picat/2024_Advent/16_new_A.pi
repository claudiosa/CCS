import util.
import datetime.
import planner.

main ?=>
    %File = "16_B_sample.txt",
    File = "16_A_sample.txt",
    InputLines = read_file_lines(File),
    N_Rows = length(InputLines),
    N_Cols = length(first(InputLines)),

    Grid_2D = new_array(N_Rows, N_Cols),
    CurrentRow := 1,
    foreach(Line in InputLines)
        Grid_2D[CurrentRow] = to_array(Line),
        CurrentRow := CurrentRow + 1
    end,

    [X_s, Y_s] = find_symbol(Grid_2D, 'S'),
    [X_e, Y_e] = find_symbol(Grid_2D, 'E'),
    Dir := '^',
    %Allow_Rotate := 1,

    Initial = {[X_s, Y_s], Dir, [], [X_e, Y_e], [N_Rows, N_Cols], Grid_2D},
    printf("Initial: %w", Initial),
    printf("\n Coordenates Start: %w \t End: %w", [X_s,Y_s] , [X_e,Y_e]),

    %best_plan(Initial, Plan, Cost),
    best_plan_bb( Initial , Plan, Cost) ,
    %best_plan_unbounded(Initial,Plan,Cost),

    printf("Plan: %w\nCost: %w\n", Plan, Cost),
    printf(" \n =========================================\n "),
    print("THE END").

main => println("NO").

find_symbol(M, Symbol) = R =>
    Positions = [ [I, J] : I in 1..M.length, J in 1..M[1].length, M[I, J] == Symbol ],
    R = Positions[1].

final({[X, Y], Dir, Path,  [X_e, Y_e], [N_Rows, N_Cols], Grid}) =>
    abs(X-X_e) + abs(Y-Y_e) == 1,
    printf("\nSolution Found!\n"),
    print_path_on_grid(Path, Grid).

table
% Ação de movimento
action({[X, Y], Dir, Path,  EndPos, [N_Rows, N_Cols], Grid}, NextState, Action, Cost) ?=>
    % Calcular nova posição e direção
    
    ((Y + 1 =< N_Cols, Grid[X, Y + 1] == '.', Dir == '>',
       X_new := X, Y_new := Y + 1, 
       NewDir := Dir, Action = 'move_>')
    ;
    (X + 1 =< N_Rows, Grid[X + 1, Y]  == '.', Dir == 'v',
        X_new := X + 1, Y_new := Y, 
        NewDir := Dir, Action = 'move_v')
    ;
    (Y - 1 >= 1, Grid[X, Y - 1]  == '.', Dir == '<',
        X_new := X, Y_new := Y - 1, 
        NewDir := Dir, Action = 'move_<')
    ;
    (X - 1 >= 1, Grid[X - 1, Y]  == '.', Dir == '^',
        X_new := X - 1, Y_new := Y, 
        NewDir := Dir, Action = 'move_^')),

    % Verificar se a nova posição é válida e não visitada
    not membchk([X_new, Y_new], Path),
    Path_New := [[X_new, Y_new]] ++ Path,

    %New_Allow := 1,    
    % Atualizar estado com nova direção e custo e permitir rotação
    NextState = {[X_new, Y_new], NewDir,  Path_New, EndPos, [N_Rows, N_Cols], Grid},
    Cost = 1.

% Ação de rotação
action({[X, Y], Dir, Path, EndPos, [N_Rows, N_Cols], Grid}, NextState, Action, Cost) =>
    % Girar no lugar (não muda a posição, mas simula uma rotação)
    % Rotacionar no sentido horário
    %Allow_Rotate == 1,
    /*
    ((Dir == '^' -> NewDir := '>')
    ; (Dir == '>' -> NewDir := 'v')
    ; (Dir == 'v' -> NewDir := '<')
    ; (Dir == '<' -> NewDir := '^')),
    */
    % SENTIDO ANTI-HORARIO
    ((Dir == '^' -> NewDir := '<')
    ; (Dir == '>' -> NewDir := '^')
    ; (Dir == 'v' -> NewDir := '>')
    ; (Dir == '<' -> NewDir := 'v')),
   % New_Allow := 0, %% evitar duas rotacoes seguidas
    % Atualizar estado com nova direção e custo
    NextState = {[X, Y], NewDir, Path, EndPos, [N_Rows, N_Cols], Grid},
    Cost = 1000,
    Action = 'rotate'.

print_map(M) =>
    L = M.length,
    C = M[1].length,
    nl,
    foreach(I in 1..L)
        foreach(J in 1..C)
            printf("%w ", M[I,J])
        end,
        nl
    end.

print_path_on_grid(Path, Grid) =>
    L = Grid.length,
    C = Grid[1].length,
    nl,
    foreach (I in 1..L)
        foreach (J in 1..C)
            (membchk([I,J], Path) -> printf("* ") ; printf("%w ", Grid[I,J]))
        end,
        nl
    end.

count_char(M, C) = Count =>
    Count = sum([1 : I in 1..M.length, J in 1..M[I].length, M[I,J] == C]).
