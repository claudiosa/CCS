import os.
import util.
import math.
import datetime.
import planner.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
main ?=>
   Status = command("clear") ,
   printf("====================================== %d OK", Status),
    Map = read_Map_1("MAP_02.txt") , %%% TEM 2 AGENTES AQUI
    nl,
    printf("\n The Initial Grid or Map"),            
    print_map( Map ), nl,
       
    T1 = current_time(),
%    write(map2=Map),

    N_Total_Agents := 2,
    Current_Agent = 1, %%% action of the first agent
    %action([Current_Agent,Grid, ], 

    time(best_plan_unbounded([Current_Agent, Map, N_Total_Agents] , Plan)), %%% CPU TIME

    T2 = current_time(), 
    print_map( Map ), %%% INITIAL MAP AGAIN
    
    print_States(Plan, Map),
    printf("\n PLAN: %w", Plan), 
    Total := length(Plan) ,
    Num_Movts := (Total -1) ,
  
   % printf("\n Initial Position (state): %w ", X),
   % printf("\n Final  Position (state): %w", Y),
    printf("\n Total of states: %d", Total), 
    printf("\n Total of moviments: %w", Num_Movts),
    printf("\n CPU TIME INIC: %w  FIM: %w ", T1, T2),
    printf(" \n=========================================\n ")
    .
    
main =>  printf("\n Something Wrong !!!").

/*********** << AGENT + ACTION *************/
%%% IN FUNCTIONS: no backtrackable rules are allowed 
%%% Backtrackable rules only in predicates

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/*** check the '@' absent ****/
final( Grid ) =>
          % println(final=Grid),
          array_matrix_to_list(Grid) = List,
          not member('@', List ). 

final(_) => printf("\n There are some @ in the map!\n").
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
/* Describing the possible actions ==> for the planner */
%action([ X1,X2,X3,X4,X5,X6,X7 ], S1, Action, Action_Cost ) 

%%% FOR MAS multiagent system
action([Current_Agent, Grid,  N_Total_Agents], 
       [Next_Agent, New_Grid, N_Total_Agents],
        Action, Action_Cost ) ?=>
   
     pos_Current_Agent_XY(Current_Agent, [X,Y], Grid ), %% take the position
     %%% easy to extend or almost
     Grid_TEMP = copy_term(Grid),
     
     %%% CONDITIONS to act ...   to : move UP 
   
     (X > 1 , (Grid[X-1,Y] == '*' ; Grid[X-1,Y]=='@') ),
     %% ACTIONS
          Grid_TEMP[X,Y] := '*' ,			
          Grid_TEMP[X-1,Y] := Current_Agent,   		
          
     %%% POST CONDITIDIONS
     Action_Cost = 1,
     Action = (Current_Agent , up_move), %% action up_move done by Current Agent
     % Once that the final plan is a list of actions performed by
     %% updating the Next_agent
     Next_Agent = f_which_the_next(Current_Agent, N_Total_Agents),
     %% updating the New_grid
     New_Grid = Grid_TEMP .     

%%%% Falta arrumar os passos acima ..... nas 3 proximas regras


action([Current_Agent, Grid,  N_Total_Agents], 
       [Next_Agent, New_Grid, N_Total_Agents],
        Action, Action_Cost ) ?=>
        
    %% Getting data    
     Grid_TEMP = copy_term(Grid),
     pos_Current_Agent_XY(Current_Agent, [X,Y], Grid ), %% take the position

    %% FROM HAKAN ....
    [Row, _ ] = [Grid.length , Grid[1].length ],

    %%% CONDITIONS
    (X < Row  ,  (Grid[X+1,Y]=='*' ; Grid[X+1,Y]=='@')),
    %if( ground(X) && ground(Y) ) then
    %printf("\n Aterrados OK \n")
    %end,
     Grid_TEMP[ X , Y] := '*',   
     Grid_TEMP[X+1 ,Y] := Current_Agent,       
     
     %%% POST CONDITIDIONS
     Action_Cost = 1,
     Action = (Current_Agent , down_move), %% action up_move done by Current Agent
     % Once that the final plan is a list of actions performed by
     %% updating the Next_agent
     Next_Agent = f_which_the_next(Current_Agent, N_Total_Agents),
     %% updating the New_grid
      
     New_Grid = Grid_TEMP .
		
action([Current_Agent, Grid,  N_Total_Agents], 
       [Next_Agent, New_Grid, N_Total_Agents],
        Action, Action_Cost ) ?=>
        
    %% getting data
     pos_Current_Agent_XY(Current_Agent, [X,Y], Grid ), %% take the position
        
     Grid_TEMP = copy_term(Grid),
    
    
    % CONDITIONS
    (Y > 1  ,  (Grid[X,Y-1]=='*' ; Grid[X,Y-1]=='@') ),
        Grid_TEMP[X,Y] := '*',			
	    Grid_TEMP[X,Y-1] := Current_Agent,       

%%% POST CONDITIDIONS
     Action_Cost = 1,

     Action = (Current_Agent , left_move), %% action up_move done by Current Agent
     % Once that the final plan is a list of actions performed by
     %% updating the Next_agent
     Next_Agent = f_which_the_next(Current_Agent, N_Total_Agents),
     %% updating the New_grid
     New_Grid = Grid_TEMP . 		
     
action([Current_Agent, Grid,  N_Total_Agents], 
       [Next_Agent, New_Grid, N_Total_Agents],
        Action, Action_Cost ) ?=>
    
    %% getting data
     pos_Current_Agent_XY(Current_Agent, [X,Y], Grid ), %% take the position
     Grid_TEMP = copy_term(Grid),
    
    % println(gridXY4=Grid[X,Y]),    
    [_, Col] = [Grid.length , Grid[1].length ],


     %%% CONDITIDIONS
       (Y < Col  ,  (Grid[X,Y+1]=='*' ; Grid[X,Y+1]=='@')),
        Grid_TEMP[X,Y] := '*',			
	    Grid_TEMP[X,Y+1] := Current_Agent,       


    %%% POST CONDITIDIONS
     Action_Cost = 1,
    
    Action = (Current_Agent, right_move ),
     %% action XXXXXXXXX done by Current Agent
     % Once that the final plan is a list of actions performed by
     %% updating the Next_agent
     Next_Agent = f_which_the_next(Current_Agent, N_Total_Agents),
     %% updating the New_grid
     
     New_Grid = Grid_TEMP .  




	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% NAO FORAM USADAS ... poderiam ser removidas
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% FEITA .....

print_States([], _) => printf("\n================================ \n").
print_States([ (Agent,Action) |L_Action], Grid) ?=>

		Grid_TEMP = copy_term(Grid),
		position_c_XY( [X,Y], Grid ),

        if (Action == up_move)
        then
          %writeln(up_move),
          Grid_TEMP[X,Y] := '*' ,			
          Grid_TEMP[X-1,Y] := Agent

        elseif (Action == down_move)
        then
          %%writeln(up_move),
          Grid_TEMP[X,Y] := '*' ,			
          Grid_TEMP[X+1,Y] := Agent

		elseif (Action == right_move)
        then
          Grid_TEMP[X,Y] := '*' ,			
          Grid_TEMP[X,Y+1] := Agent

        elseif (Action == left_move)
        then
          Grid_TEMP[X,Y] := '*' ,			
          Grid_TEMP[X,Y-1] := Agent
        end,  
          
        New_Grid = Grid_TEMP,
        
        print_map( New_Grid ), 
        print_States(L_Action , New_Grid).
        
%left_move,left_move,right_move,right_move,down_move,right_move,right_move,right_move,up_move,up_move]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

f_which_the_next(Current_Agent , N_Total_Agents) = Next_Agent =>
      if(Current_Agent >= N_Total_Agents)
      then 
      Next_Agent = 1 %% 1 2 3 .... N -> 1 2 ....N 
      else
      Next_Agent = 1 + Current_Agent
      end.
 %%% some mod solution works also       


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/* Get position XY in a grid from a cell with 'c' */
 pos_Current_Agent_XY(Current_Agent, [X,Y],  Map ) =>
  L = Map.length,
  C = Map[1].length,
   
   foreach(I in 1..L , J in 1..C)
	   if (Map[I,J] == Current_Agent) then  
			 X = I,
			 Y = J
			end   %% END INNER IF 

	   end %% END  FOREACH
	 ,
	
	 if( var(X) || var(Y) ) then
	 printf("The c was not found: %d")
	 end	%% END  IF
	 .
	  
%position_c_XY( _ , _) => printf("\n Problem in XY position function \n").

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% UPDATING THE GRID=MAP
update_MAP(N,[X,Y], Map ) = Res =>  Map[X,Y] := N,
                                    Res := Map.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% READING A FILE  with a MAP or Grid....
read_Map_1(File_NAME) = Arr_2D  
    =>
    Reader = open(File_NAME), 
    Lines = read_int(Reader), %% dimentions of Grids
    Cols = read_int(Reader),
    new_array(Lines , Cols ) = Arr_2D, %% creating an array 2D
    I = 1, 
    while (not at_end_of_stream(Reader)) %% continuando a leitura
        L_read := read_line(Reader),
        delete_all( L_read, ' ') = L_aux, %% exclui ' ' do mapa
        Arr_AUX = to_array(L_aux),   %% converte lista para array
    %    printf("\n By Line: %w",  L_aux ),
    %    printf("\n  By Array %d: %w", I, Arr_AUX ),
        Arr_2D[I] := Arr_AUX ,  %% array recebe uma linha -- teste
        I := I+1
       end,
    close(Reader)  .
    %% printf("\n The Final Array: %w\n\n", Arr_2D )


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% READING A MAP  ....
read_Map_2(File_NAME) = Arr_2D  
    =>
      L_read = read_file_lines(File_NAME),
      writeln(list_read=L_read),
      L_flatten = flatten(L_read),
      L_aux= delete_all( L_flatten, ' ') ,  %% exclui ' ' do mapa
      writeln(l_aux = L_aux),
      [Lines, Cols | List] = L_aux,
      N_rows = to_int(Lines),
      N_cols = to_int(Cols),
      println([N_rows , N_cols]),
  %%% CONFERIR SE LIST estah OK
      Arr_2D = new_array(N_rows , N_cols ) , %% cria um array 2D
      writeln( l_Final = List ),
      writeln(a_array = Arr_2D ),
      
      printf("\n Size: %d\n List:%w \n", length(List), List ),
  %%%% PROBLEM HERE   >>> to be rewrite it  
      Arr_2D = to_array(List)  ,   %% converte lista para array
      writeln(a_array = Arr_2D ),
          
      printf("\n Array: %w\n List:%w \n", Arr_2D, List ).
     
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  

%% printing the GRID ....
print_map( M ) =>
 L = M.length,
 C = M[1].length,
  nl,
   foreach(I in 1  .. L)
     foreach(J in 1  ..  C)
      printf("%w " , M[I,J] )
     end,
     nl
   end.   
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
