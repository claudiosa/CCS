%% TO RUN
% Picat> cl('graph_community').
% $ picat graph_community.pi 
import util.
%import cp.

main => go.

go =>
   
   K_com = 4, %%% Number of Community
   Size_K = 5, %% Size Community
   Size =  K_com * Size_K,
   Degree = Size_K - 1, %%% Neighbours
   Graph = new_array(Size, Degree ),
   X2_CN = new_array(K_com), %% CENTER NODES of each communityt
   
  % all_different(X1_Graph),
  % THE CENTRAL NODE ARE INITILIZED
   foreach(I in 1..K_com)
       X2_CN[I] = ((Size_K * I) - 4)
       %%% see the community topology
   end,

  rows(X2_CN) = L2,
  printf("\n CENTRAL NODES: %w", L2),
%%% NEIGHBOURS OF CENTRAL NODE IN EACH COMMUNITY
  foreach(I in L2)
     (
       Graph[I, 1] = (I+1),
       Graph[I, 2] = (I+2),
       Graph[I, 3] = (I+3),
       Graph[I, 4] = (I+4)
     ) 
  end,

%%% NEIGHBOURS IN EACH COMMUNITY -- see the figure
 foreach(I in L2)
   ( %% left most corner 
      Graph[(I+1), 1] =  (I+2),
      Graph[(I+1), 2] =  I,
      Graph[(I+1), 3] =  (I+3), 

      Graph[(I+2), 1] =  (I+1),
      Graph[(I+2), 2] =  I,
      Graph[(I+2), 3] =  (I+4), 

      Graph[(I+3), 1] =  (I+1),
      Graph[(I+3), 2] =  I,
      Graph[(I+3), 3] =  (I+4), 
      
      %% right most corner 
      Graph[(I+4), 1] =  (I+2),
      Graph[(I+4), 2] =  I,
      Graph[(I+4), 3] =  (I+3) 
     ) 
   end,


  %% foreach(I in [3,8])
  %%    %foreach(J in 1..Degree)
  %%   ( %% left most corner 
  %%     Graph[(I-2), 4] =  (I+3)  mod (Size + 1),
  %%     Graph[(I-1), 4] =  (I+8)  mod (Size + 1), 
  %%     Graph[(I+1), 4] =  (I+13) mod (Size + 1),
  %%     Graph[(I+2), 4] =  (I+18) mod (Size + 1)
  %%    ) 
  %%  end,

  
 % L3 = findall([X,Y], var(Graph[X,Y]) ), 
 % printf("\n L3: %w", L3),
L3 := [], 
foreach(I in 1..Size)
 foreach(J in 1..Degree)
     if( var (Graph[I,J]) ) then
      	(% printf("\n Graph[%d,%d]: %w", I,J , Graph[I,J]),
      	 % L3 := L3 ++ [(I,J)]
      	 L3 := L3 ++ [I]
      	) 	
     end
  end
end,         
printf("\n Extern Nodes (L3): %w", L3),

%%% Marks the over each internal nodes
Aux = aux_vet_with_zero(Size),
foreach(I in L2)
	Aux[I] := 1
end,

printf("\n Aux: %w", Aux),

%%%% Marks over the others
foreach(I in 1..Size)
	%(Size-Size_K))
(
 if(Aux[I] == 0) then %% node not marked
  (
   Aux[I] := 1, %%% mark as visited	
   KI = which_community(I, Size_K ),
   
   %%% THIS FUNCTION IS NOT OK
   %Next = (Size_K * (K_com - KI) + I) mod (Size + KI),
   % mod (Size+1),
   Next = (Size_K *(K_com - KI + 1 ) + I),
   %%  mod (Size+1), %%%  mod Size_K),
   

   printf("\n ==>I: %d | KI: %d | Brute .. Next: %d ", I, KI, Next),
   %%%(Next =< Size) 
   if( Next > Size ) then
     (
       while(Next > Size) %% limit of vector
        Next := Next - 1
       end,	
       %% find a empty cell again  to change with I
       while( Aux[Next] == 1 ) %% empty cell
       Next := Next - 1
       end
      ) 
    end,
     
   if( Aux[Next] == 0 ) then %% not marked yet
   (
       Graph[I, 4] = Next,
       Graph[Next, 4] = I,
       Aux[Next] := 1
   )
   else
   ( %% advance up to next free cell 
     while( Aux[Next] == 1 )
      Next := Next+1
      end,
       printf("\n ==>Empty Cell: [%d] = %d ", I, Aux[Next]),
       printf("\n ==>I: %d | KI: %d | Next: %d ", I, KI, Next),
       printf("\n Aux: %w", Aux),
       %%% mark the free cells as occupied
       Graph[I, 4] = Next,
       Graph[Next, 4] = I,
       Aux[ Next ] := 1  
     )
 	end
  
  )% if
 end
) % foreach
end,

%%% HOW TO DO THE CONNECTION NODES? 
%%% NOT SOLVE YET ...

   printf("\n Neighbours Central: %w", Graph),
   printf("\n Central Nodes of each graph-5: %w", X2_CN),
   print_matrix( Graph ).


print_matrix( M ) =>
  L = M.length,
  C = M[1].length,
  printf("\n \n NEIGHBOURS:\n     "),
  foreach(J in 1  .. C)
    printf(" : %d ", J)
  end,
  nl,
  foreach(I in 1  .. L)
   printf("NODE %w : ", I),
    foreach(J in 1  ..  C)
      printf("%w " , M[I,J] )
    %% printf("(%d,%d): %w " , I, J, M[I,J] ) -- OK
      end,
    nl
  end.   
  
which_community(I, Size_K) = X =>
         X = round((I-1) div (Size_K))+1.

aux_vet_with_zero(N) = X =>
   X = new_array(N),
   foreach(I in 1 .. N)
    X[I] := 0
   end.