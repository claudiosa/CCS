%Picat> cl('graph_community').

import util.
%import cp.

main => go.

go =>
   
   K_com = 4, %%% Number of Community
   Size_K = 5, %% Size Community
   Size =  K_com * Size_K,
   Degree = Size_K - 1, %%% Neighbours
   Graph = new_array(Size, Degree ),
   X2_CN = new_array(K_com), %% CENTER NODES of each communityt
   
  % all_different(X1_Graph),
  % THE CENTRAL NODE ARE INITILIZED
   foreach(I in 1..K_com)
       X2_CN[I] = ((Size_K * I) - 4)
       %%% see the community topology
   end,

  rows(X2_CN) = L2,
  printf("\n CENTRAL NODES: %w", L2),
%%% NEIGHBOURS OF CENTRAL NODE IN EACH COMMUNITY
  foreach(I in L2)
     (
       Graph[I, 1] = (I+1),
       Graph[I, 2] = (I+2),
       Graph[I, 3] = (I+3),
       Graph[I, 4] = (I+4)
     ) 
  end,

%%% NEIGHBOURS IN EACH COMMUNITY -- see the figure
 foreach(I in L2)
   ( %% left most corner 
      Graph[(I+1), 1] =  (I+2),
      Graph[(I+1), 2] =  I,
      Graph[(I+1), 3] =  (I+3), 

      Graph[(I+2), 1] =  (I+1),
      Graph[(I+2), 2] =  I,
      Graph[(I+2), 3] =  (I+4), 

      Graph[(I+3), 1] =  (I+1),
      Graph[(I+3), 2] =  I,
      Graph[(I+3), 3] =  (I+4), 
      
      %% right most corner 
      Graph[(I+4), 1] =  (I+2),
      Graph[(I+4), 2] =  I,
      Graph[(I+4), 3] =  (I+3) 
     ) 
   end,


  %% foreach(I in [3,8])
  %%    %foreach(J in 1..Degree)
  %%   ( %% left most corner 
  %%     Graph[(I-2), 4] =  (I+3)  mod (Size + 1),
  %%     Graph[(I-1), 4] =  (I+8)  mod (Size + 1), 
  %%     Graph[(I+1), 4] =  (I+13) mod (Size + 1),
  %%     Graph[(I+2), 4] =  (I+18) mod (Size + 1)
  %%    ) 
  %%  end,

 % L3 = findall([X,Y], var(Graph[X,Y]) ), 
 % printf("\n L3: %w", L3),
L3 := [], 
foreach(I in 1..Size)
 foreach(J in 1..Degree)
     if( var (Graph[I,J]) ) then
      	(% printf("\n Graph[%d,%d]: %w", I,J , Graph[I,J]),
      	 % L3 := L3 ++ [(I,J)]
      	 L3 := L3 ++ [I]
      	) 	
     end
  end
end,         
printf("\n Extern Nodes (L3): %w", L3),

%%% Daux :: 1..Size,

%%% HOW TO DO THE CONNECTION NODES? 
%%% NOT SOLVE YET ...
%foreach(I in [1,2,4])
 %foreach(I in L2)
  %foreach(J in 1..Degree)
 % ( %% left most corner 
 %  	Graph[I,4] =  ((I*5)  mod Size ) + 1,
 %   Graph[((I*5)  mod Size ) + 1, 4] = I ,
 %   printf("\n I: %d (I*5)  mod Size ) + 1: %d", I, ((I*5)  mod Size ) + 1)  
     % Graph[(I-1), 4] =  (I+8)  mod (Size + 1), 
     % Graph[(I+1), 4] =  (I+13) mod (Size + 1),
     % Graph[(I+2), 4] =  (I+18) mod (Size + 1)
 %  ) 
 % end,

   printf("\n Neighbours Central: %w", Graph),
   printf("\n Central Nodes: %w", X2_CN),
   print_matrix( Graph ).


print_matrix( M ) =>
  L = M.length,
  C = M[1].length,
  printf("\n \n Neighbours:\n     "),
  foreach(J in 1  .. C)
    printf(" : %d ", J)
  end,
  nl,
  foreach(I in 1  .. L)
   printf("NODE %w : ", I),
    foreach(J in 1  ..  C)
      printf("%w " , M[I,J] )
    %% printf("(%d,%d): %w " , I, J, M[I,J] ) -- OK
      end,
    nl
  end.   
  