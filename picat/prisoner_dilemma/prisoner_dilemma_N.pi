% cl('prisoner_dilemma_N').
module prisoner_dilemma_N.
import graph_community.
import dist_vertex.   %%% module CONEXION of extern NODES 
import util.


main => go.

go =>
   
   K_com = 10 , %%% Number of Community
   Size_K = 5 , %% Size Community
   %%% other parameters
   %% C_c = 3  >>> according of the paper....
   %% B = 5
   %% I_i =


   Graph = build_graph(Size_K, K_com),
   printf("\n Graph: %w", Graph),
  %%% print_matrix( Graph ),
   Size = K_com * Size_K,
   printf("\n K_com: %d * Size_K: %d = Size: %d", K_com, Size_K, Size),
   Initial_C_D_Nodes = new_array( Size ),
   Fitness_F_Nodes = new_array( Size ),
   Weight_Neighbour_Nodes = new_array( Size, (Size_K-1) ),   

   Initial_C_D_Nodes = f_init_C_D_vector( Size_K, K_com ),
   printf("\n Initial_C_D_Values %w", Initial_C_D_Nodes),

   I_cooperation := f_how_many_in_Coop ( Initial_C_D_Nodes ),
   printf("\n I_cooperation : %d ",  I_cooperation),
   %printf("\n I cooperation %w", f_how_many_in_Coop ( Initial_C_D_Nodes ))
   %%% DATA FROM THE ARTICLE
   B :=  Size - I_cooperation, %% defection
   Cc_constant = 3,
   F_Coop_Ag := (B*I_cooperation)/Size - Cc_constant,
   F_Def_Ag :=  F_Coop_Ag + Cc_constant,
   
   printf("\n F_Coop_Ag: %f | F_Def_Ag: %f  ", F_Coop_Ag, F_Def_Ag),

   init_fitness_nodes(Fitness_F_Nodes, Initial_C_D_Nodes, F_Coop_Ag, F_Def_Ag),
   printf("\n Fitness_F_Nodes: %w", Fitness_F_Nodes),

   w_weight_conexions_init(Weight_Neighbour_Nodes) ,  
   printf("\n Weight_Neighbour_Nodes: %w", Weight_Neighbour_Nodes)



 .


 w_weight_conexions_init(M_Weight) =>
     Rows = M_Weight.length,
     Cols = M_Weight[1].length,
     foreach(I in 1..Rows)
     ( 
       foreach(J in 1..Cols)
       (
         M_Weight[I,J] = randon_number_1_N(99)/100
        )
        end 
       )
     end.   
   




init_fitness_nodes(Fit_Nodes, C_D_Nodes, V_Coop_Ag, V_Def_Ag) =>
     N = Fit_Nodes.length,
     foreach(I in 1..N)
     ( 
       if(C_D_Nodes[I] == c) then
       	Fit_Nodes[I] = V_Coop_Ag
       else
       	Fit_Nodes[I] = V_Def_Ag	
       end 
     )
 end.   




f_how_many_in_Coop ( V ) = X =>
     N = V.length,
     X = 0,
     foreach(I in 1..N, V[I] == c)
     (
       X := X + 1  %%% CONFESS
     ) 
     end %%% don't forget  
  %  writeln(temp= X)
     .

   

      


f_init_C_D_vector( Size_K, K_com ) = X => 
  %% Populating the Class -- Initial
   % Anchor nodes -- OK
   Initial_C_D_Nodes = new_array( K_com * Size_K ),
   L_anchor = [(I*Size_K)+1 : I in 0..(K_com-1)],
   %foreach(I in 1..Size_K..Size)
   foreach(I in L_anchor)
     ( 
       X = randon_return_C_or_D(),
      % printf("\n Anchor: %d X: %w", I, X), %% to be comment
       foreach(J in 0..(Size_K-1) )
       	(  %writeln(j= J),
           Initial_C_D_Nodes[ I+J ] = X
       % , printf("\n Initial %d = %w " , (I+J), Initial_C_D_Nodes[I+J] )
       	   %% to be comment
       	) 
       end 
      ) %% end extern foechac
    end,
   
   X = Initial_C_D_Nodes.
 



randon_return_C_or_D = X =>
 (  R = 1 + random() mod 2,
     if(R == 1) then
         X = c  %%% CONFESS
         else
         X = d %%% SILENT  
      end
  ).    


 randon_number_1_N (N) = R =>
   R = 1 + random() mod N.    