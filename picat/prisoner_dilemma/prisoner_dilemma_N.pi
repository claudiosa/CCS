% cl('prisoner_dilemma_N').
module prisoner_dilemma_N.
import graph_community.
import dist_vertex.   %%% module CONEXION of extern NODES 
import util.


main => go.

go =>
   
   K_com = 10 , %%% Number of Community
   Size_K = 5 , %% Size Community
   %%% other parameters
   %% C_c = 3  >>> according of the paper....
   %% B = 5
   %% I_i =

   Graph = build_graph(Size_K, K_com),
   printf("\n Graph: %w", Graph),
  %%% print_matrix( Graph ),
   Size = K_com * Size_K,
   printf("\n K_com: %d * Size_K: %d = Size: %d", K_com, Size_K, Size),
   Initial_C_D_Nodes = new_array( Size ),
   Fitness_F_Ag = new_array( Size ),
   Weight_Betw_Ag = new_array( Size, (Size_K-1) ),   

   Initial_C_D_Nodes = f_init_C_D_vector( Size_K, K_com ),
   printf("\n Initial_C_D_Values %w", Initial_C_D_Nodes),

   I_cooperation := f_how_many_in_Coop ( Initial_C_D_Nodes ),
   printf("\n I_cooperation : %d ",  I_cooperation),
   %printf("\n I cooperation %w", f_how_many_in_Coop ( Initial_C_D_Nodes ))
   %%% DATA FROM THE ARTICLE
   B :=  Size - I_cooperation, %% defection
   Cc_constant = 3,
   F_Coop_Ag := (B*I_cooperation)/Size - Cc_constant,
   F_Def_Ag :=  F_Coop_Ag + Cc_constant,
   
   printf("\n F_Coop_Ag: %6.2f | F_Def_Ag: %6.2f  ", F_Coop_Ag, F_Def_Ag),

   init_fitness_nodes(Fitness_F_Ag, Initial_C_D_Nodes, F_Coop_Ag, F_Def_Ag),
   printf("\n INITIAL Fitness_F_Ag: %w", Fitness_F_Ag), %% take care to print vector of NUMBERS

   w_weight_conexions_init(Weight_Betw_Ag) ,  
  % printf("\n Weight_Betw_Ag: %w", Weight_Betw_Ag),
   %% take care to print vector of NUMBERS

 N_Steps := 1,
   while( N_Steps > 0 )
    (
     foreach(I in 1..Size )
      ( 
       L_Neighbour := [1,2,3,4], %%% the neighbour nodes ... 1fst ... 4f 	
         %% For rule 6 -- pag 162 
         % for each agent i (x)
         % choice a strong agent y stocastic... 1 .. 4
         % update its f(x)
         Y = randon_number_1_N(4),%%% 1 .. 4
         others_from_L( L_Neighbour, Y , P1 , P2 , P3),
         %printf("\n I: NEXT Z %d Y: %d", I,Y),
       
         %% FORMULA 6 page ... 161
         Prob_I := 
         (Weight_Betw_Ag[I,Y] * Fitness_F_Ag[Graph[I,Y]] )
         / 
         ((Weight_Betw_Ag[I,P1] * Fitness_F_Ag[Graph[I,P1]])
         +	
         ( Weight_Betw_Ag[I,P2] * Fitness_F_Ag[Graph[I,P2]])
         + 
         ( Weight_Betw_Ag[I,P3] * Fitness_F_Ag[Graph[I,P3]])
         )  
         ,

        if (Prob_I > 1) then
          println(prob___1 = Prob_I)
        end,
         %% FORMULA 7 page ... 161
        Prob_II := 
        (Weight_Betw_Ag[I,Y] * Fitness_F_Ag[Graph[I,Y]] )
        / 
        ((Weight_Betw_Ag[I,P1] * Weight_Betw_Ag[Graph[I,P1],4]* Fitness_F_Ag[Graph[Graph[I,P1],4]])
        +  
        ( Weight_Betw_Ag[I,P2] * Weight_Betw_Ag[Graph[I,P2],4]* Fitness_F_Ag[Graph[Graph[I,P2],4]])
        + 
        (Weight_Betw_Ag[I,P3] * Weight_Betw_Ag[Graph[I,P3],4]* Fitness_F_Ag[Graph[Graph[I,P3],4]])
        ) ,

        if (Prob_II/10 > 1) then %%%% due 
          println(prob___2 = Prob_II)
        end,
                
       /*
        println(prob_I= Prob_I), 
        printf("\n I -> Y: %d -> %d W: %4.3f", I , Graph[I,Y], Weight_Betw_Ag[I,Y]),
        printf("\n I-> %d W: %4.3f", Graph[I,P1], Weight_Betw_Ag[I,P1]),
        printf("\n I-> %d W: %4.3f", Graph[I,P2], Weight_Betw_Ag[I,P2]),
        printf("\n I-> %d W: %4.3f", Graph[I,P3], Weight_Betw_Ag[I,P3]),
        
        println(previous= Previous_Fit),
        Fitness_F_Ag[I] := roullete_whell(Prob_I, Previous_Fit, F_Coop_Ag , F_Def_Ag )
        Fitness_F_Ag[I] := New
      */

    Previous_Fit := Fitness_F_Ag[I], 
    Rand_N := randon_number_1_N(99)/100,
    %println(random = Rand_N),
    %Fitness_F_Ag[I] := roullete_whell(Prob_I, Previous_Fit, F_Coop_Ag , F_Def_Ag )
      
   if (Rand_N < Prob_I) then %%% so Change
       (
       % printf("\n ==> Fit %4.2f F_Coop_Ag: %6.2f | F_Def_Ag: %6.2f  ", Previous_Fit , F_Coop_Ag, F_Def_Ag),
        % if(round(Previous_Fit) == round(F_Coop_Ag)) then
        if(abs(Previous_Fit - F_Coop_Ag) < 3 ) then
          Fitness_F_Ag[I] := F_Def_Ag  %% was Coop
          else 
          Fitness_F_Ag[I] := F_Coop_Ag
         end    
        )
     end
    
    /****************** IMMEDIATE neighbours ENDED ********/
    ) 
    end, %%% do foreach
        N_Steps := N_Steps -1
   ) end, %%% do while
%Picat> X = 7.543, writef("%6.2f", X).
%  7.54X = 7.543
     printf("\n FINAL Fitness_F_Ag: %w", Fitness_F_Ag), %% take care to print vector of NUMBERS
      printf("\n Final Fitness_F_Ag\n"),
      f_print_V( Fitness_F_Ag )      
   %printf("\n NEW Fitness_F_Ag: %4.2f", Fitness_F_Ag)
   % writef("\n%4.2", Fitness_F_Ag)
 .



f_print_V( V ) =>
   Size = V.length,
   foreach(I in 1..Size )
  ( 
   printf("\t V[%d]: %4.2f", I, V[I])
   ) 
  end.

 roullete_whell(Prob_I, Previous_Fit, F_Coop_Ag , F_Def_Ag ) = New =>
    Rand_N := randon_number_1_N(99)/100,
    println(random = Rand_N),
    println(prob = Prob_I),
   
    if (Rand_N < Prob_I) then %%% so Change
       (
       	%printf("\n ==> Fit %4.2f F_Coop_Ag: %6.2f | F_Def_Ag: %6.2f  ", Previous_Fit, F_Coop_Ag, F_Def_Ag),
         %if(round(Previous_Fit) == round(F_Coop_Ag)) then
         if(abs(Previous_Fit - F_Coop_Ag) < 3 ) then
         	( Y := F_Def_Ag , %% was Coop
         	 write(' x ')
           )
         else	
          (Y := F_Coop_Ag ,
           write(' y ')
          ) 
         end    
       )
     end,
    New := Y. %% IF

     
     
       



 %randon_number_1_N (N) = R =>
 %  R = 1 + random() mod N.    
 
%% simplest way
 others_from_L(Full,Y, P1,P2,P3) =>
    L = delete(Full,Y),
    L = [P1,P2,P3].


 w_weight_conexions_init(M_Weight) =>
     Rows = M_Weight.length,
     Cols = M_Weight[1].length,
     foreach(I in 1..Rows)
     ( 
       foreach(J in 1..Cols)
       ( %%% some random value .... 0.1 up to 0.99
         M_Weight[I,J] = randon_number_1_N(99)/100
        )
        end 
       )
   end.   
   




init_fitness_nodes(Fit_Nodes, C_D_Nodes, V_Coop_Ag, V_Def_Ag) =>
     N = Fit_Nodes.length,
     foreach(I in 1..N)
     ( 
       if(C_D_Nodes[I] == c) then
       	Fit_Nodes[I] = V_Coop_Ag
       else
       	Fit_Nodes[I] = V_Def_Ag	
       end 
     )
 end.   




f_how_many_in_Coop ( V ) = X =>
     N = V.length,
     X = 0,
     foreach(I in 1..N, V[I] == c)
     (
       X := X + 1  %%% CONFESS
     ) 
     end %%% don't forget  
  %  writeln(temp= X)
     .

   

      


f_init_C_D_vector( Size_K, K_com ) = X => 
  %% Populating the Class -- Initial
   % Anchor nodes -- OK
   Initial_C_D_Nodes = new_array( K_com * Size_K ),
   L_anchor = [(I*Size_K)+1 : I in 0..(K_com-1)],
   %foreach(I in 1..Size_K..Size)
   foreach(I in L_anchor)
     ( 
       X = randon_return_C_or_D(),
      % printf("\n Anchor: %d X: %w", I, X), %% to be comment
       foreach(J in 0..(Size_K-1) )
       	(  %writeln(j= J),
           Initial_C_D_Nodes[ I+J ] = X
       % , printf("\n Initial %d = %w " , (I+J), Initial_C_D_Nodes[I+J] )
       	   %% to be comment
       	) 
       end 
      ) %% end extern foechac
    end,
   
   X = Initial_C_D_Nodes.
 



randon_return_C_or_D = X =>
 (  R := 1 + random() mod 2,
     if(R == 1) then
         X = c  %%% CONFESS
         else
         X = d %%% SILENT  
      end
  ).    


 randon_number_1_N (N) = R =>
   R := 1 + random() mod N.    