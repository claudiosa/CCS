
%%% Functional or Procedural Version of BFS -- By CCS
%%% There's a small error.
bfs_iterative(Graph, InitNode, EndNode) = Sol =>
    Queue := [InitNode],  %%%% I did a queue using a list ... could be an array
    Visited := [InitNode], %%% List
    printf("\n Queue:%w  Visited:%w EndNode: %w", Queue, Visited, EndNode),

    while ( Queue != [] && (not membchk(EndNode, Visited))  ) do
     
        % || get_top(Queue) != EndNode  || (not membchk(Next, Visited)) 
        printf("\n get_top: %w", get_top(Queue)),
        Aux = dequeue(Queue), %% departure ... remove front of queue
        (Front, Temp_Queue) = Aux,  
        printf("\t Temp_Queue: %w  Front: %w  ", Temp_Queue, Front),
     
        next_nodes(Graph, Front, NextNodes),
        println(nextNODES= NextNodes),
       
        foreach (Next in NextNodes )
            if (not membchk(Next, Visited) )  then
                Queue := enqueue(Next, Temp_Queue),
                Visited := [Next] ++ Visited,
                Temp_Queue := Queue,
                printf("\n NEXT: %w  Visited: %w Temp: %w Queue: %w", Next, Visited, Temp_Queue, Queue )
            end    
        end
    end,
    
    Sol = reverse(Visited)
    ;
    printf("\n Wrong INPUT in the Graph...stopped in:  %w", Visited )   
    .


/******************* AUX PREDICATES **********/
membchk_array(Element, Array) => 
    List = to_list(Array),
    membchk(Element,List).


get_top(Queue) = R =>
    R = last(Queue).

enqueue(V,Queue) = R => 
    R = [V]++Queue.

dequeue(Queue) = R =>
    if (len(Queue) > 0) then
        Front = last(Queue),
        append(New_Queue, [Front], Queue),
        R = (Front, New_Queue)
    else
        printf("\n The queue is empty"),
        %exit()
        R = (9999,[])
    end.


/*
for arrays
dequeue(Queue) = R =>
    if (length(Queue) > 0) then
        L1 = Queue.to_list(),
        reverse(L1) = [Front|ResList],
        reverse(ResList) = L2,
        New_Queue = L2.to_array(),
        R = {Front, New_Queue}
    else
        printf("\n The queue is empty"),
        %exit()
        R = {9999,{}}
    end.
*/

next_nodes([ {Node, Neighbours} | _], N, R) ?=> 
    %printf("\n N:%w , N:%w", Node, Neighbours),
    N == Node, 
    R = Neighbours.
    
next_nodes([ _ | Graph], Node, Neighbours) => 
        next_nodes(Graph, Node, Neighbours).

/*
  
       1
      / \
     2   3
    / \ / \
   4   5   6
  / \ /     \
 7   8       9
 |           |
 10         11


*/

main =>
    % Definindo um grafo simples
    Graph = [
        {1, [2, 3]},
        {2, [4, 5]},
        {3, [5, 6, 12]},
        {4, [5, 7]},
        {5, [8]},
        {6, [9]},
        {7, [10]},
        {8, []},
        {9, [11]},
        {10, []},
        {11, []},
        {12, []}
        ],
 
    % Testando o BFS funcional
    InitNode = 1,
    EndNode = 4,
   
    Sol = bfs_iterative(Graph , InitNode, EndNode),
    printf("\n\n INPUT DAT:"), 
    printf("\n InitNode:%w  EndNode:%w  \n Graph: %w", InitNode, EndNode, Graph),
    printf("\n Visiting sequence: %w \n", Sol).
