import os.
import util.
import math.
import datetime.
import planner.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


main ?=> Status = command("clear") ,
		printf("====================================== %d OK", Status),
    Map = read_Map_1("MAP_03.txt") , 
   /*
    Map =  {{*,#,#,*,@,* },
            {*,*,c,*,#,* },
            {*,#,*,@,*,* }},   
    */
    printf("\n The Initial Grid or Map"),            
    print_map( Map ), nl,
       
    T1 = current_time(),
       write(Map),
       time(best_plan_unbounded( Map , Solucao)), %%% CPU TIME
    
    T2 = current_time(), 
    print_map( Map ),
   write(Solucao), nl,
    writeln(Solucao), 
  
    Total := length(Solucao) ,
    Num_Movts := (Total -1) ,
   % T_CPU :=T2-T1, %%% think in something better
   % printf("\n Initial Position (state): %w ", X),
   % printf("\n Final  Position (state): %w", Y),
    printf("\n Total of states: %d", Total), 
    printf("\n Total of moviments: %w", Num_Movts),
    printf("\n CPU TIME INIC: %w  FIM %w",     T1, T2),
    
    printf(" \n=========================================\n ")
    .
    
main =>  printf("\n Something Wrong !!!").

/*********** << AGENT + ACTION *************/
%%% IN FUNCTIONS: no backtrackable rules are allowed 
%%% Backtrackable rules only in predicates

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/*** check the '@' absent ****/
final( Grid ) =>
          array_matrix_to_list(Grid) = List,
          not member('@', List ). 

final(_) => printf("\n There are some @ in the map!\n").
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 				

/* Describing the possible actions ==> for the planner */
%action([ X1,X2,X3,X4,X5,X6,X7 ], S1, Action, Action_Cost ) 

action(Grid, New_Grid, Action, Action_Cost ) ?=>

    Action_Cost = 1,
    Action = down_move,
    position_c_XY( [X,Y], Grid ), %% take the position
     
    [Row, _ ] = [Grid.length , Grid[1].length ],

    (X < Row  ,  (Grid[X+1,Y]=='*' ; Grid[X+1,Y]=='@')  ),
     println(xxy2=[X,Y]),
    %if( ground(X) && ground(Y) ) then
    %printf("\n Aterrados OK \n")
    %end,
    
     println(xyOK=[X,Y]),
     println(grid=Grid),
     %trace,
     Grid[ X , Y] = '*',    %%%%%?????  
     println(xxxy2=[X,Y]),
     
     Grid[X+1 ,Y] = 'c',       
   
     println(xxxxy2=[X,Y]),
     %notrace,  
     println(grid=Grid),
     
     New_Grid = Grid,
     printf("\n down_move = OK").     


action(Grid, New_Grid, Action, Action_Cost ) ?=>
     /** UP **/
     
     Action_Cost = 1,
     Action = up_move,
     position_c_XY( [X,Y], Grid ), %% take the position
     %%% CONDITIONS
     (X > 1 , (Grid[X-1,Y] == '*' ; Grid[X-1,Y]=='@') ),
     %% ACTIONS
          Grid[X,Y] = '*' ,			
          Grid[X-1,Y] = 'c',   		
     
     println(xy1=[X,Y]),
     %% updating the New_grid
     New_Grid = Grid,
     printf("\n up_move = OK").     

		
action(Grid, New_Grid, Action, Action_Cost ) ?=>

    Action_Cost = 1,
    Action = left_move,
    position_c_XY( [X,Y], Grid ), %% take the position

   (Y > 1  ,  (Grid[X,Y-1]=='*' ; Grid[X,Y-1]=='@') ),
        Grid[X,Y] = '*',			
	    Grid[X,Y-1] = 'c',       

    println(xy3=[X,Y]),

     New_Grid = Grid.   		
     
action(Grid, New_Grid, Action, Action_Cost ) ?=>

    Action_Cost = 1,
    Action = right_move,
    position_c_XY( [X,Y], Grid ), %% take the position

    [_, Col] = [Grid.length , Grid[1].length ],
    
   (Y < Col  ,  (Grid[X,Y+1]=='*' ; Grid[X,Y+1]=='@')),
        Grid[X,Y] = '*',			
	    Grid[X,Y+1] = 'c',       

    println(xy4=[X,Y]),

    New_Grid = Grid.  
	

	/**** Rows and coluns in extremities of the grid ******/
	/** upper line **/	
	action(Grid, New_Grid, Action, Action_Cost ) ?=>

    Action_Cost = 1,
    Action = up_move_UPPER,
    position_c_XY( [X,Y], Grid ), %% take the position

    (X == 1  ,  (Grid[X+1,Y]=='*' ; Grid[X+1,Y]=='@') ),
        Grid[X,Y] = '*',			
	    Grid[X+1,Y] = 'c',       
    New_Grid = Grid.

/** lower line **/
action(Grid, New_Grid, Action, Action_Cost ) ?=>

    Action_Cost = 1,
    Action = down_move_LOWER,
    position_c_XY( [X,Y], Grid ), %% take the position
    [Row, _] = [Grid.length , Grid[1].length ],

    (X == Row  ,  (Grid[X-1,Y]=='*' ; Grid[X-1,Y]=='@')  ),
      Grid[X,Y] = '*',			
	    Grid[X-1,Y] = 'c',       
    New_Grid = Grid.


action(Grid, New_Grid, Action, Action_Cost ) ?=>

    Action_Cost = 1,
    Action = down_move_LEFTMOST,
    position_c_XY( [X,Y], Grid ), %% take the position

    (Y == 1,  (Grid[X,Y+1]=='*' ; Grid[X,Y+1]=='@')  ),
        Grid[X,Y] = '*',			
	    Grid[X,Y+1] = 'c',       
    New_Grid = Grid.


action(Grid, New_Grid, Action, Action_Cost ) ?=>

    Action_Cost = 1,
    Action = down_move_RIGHTMOST,
    position_c_XY( [X,Y], Grid ), %% take the position
    [ _, Col] = [Grid.length , Grid[1].length ],

    (Y == Col  ,  (Grid[X,Y-1]=='*' ; Grid[X,Y-1]=='@')  ),
        Grid[X,Y] = '*',			
	    Grid[X,Y-1] = 'c',       
    New_Grid = Grid.

/*

action( _ , _ ,  _ , _ ) =>
       printf("\n Any movement was possible in this step --- call HOUSTON").
*/	 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/* Get position XY in a grid from a cell with 'c' */
position_c_XY( [X,Y], Map ) =>
  L = Map.length,
  C = Map[1].length,
   
   foreach(I in 1..L , J in 1..C)
	   if (Map[I,J] == 'c') then  
			 X = I,
			 Y = J
			end   %% END  IF INNER

	   end %% END  FOREACH
	 ,
	
	 if( var(X) || var(Y) ) then
	 printf("The c was not found: %d")
	 end	%% END  IF
	 .
	  
%position_c_XY( _ , _) => printf("\n Problem in XY position function \n").

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% UPDATING THE GRID=MAP
update_MAP(N,[X,Y], Map ) = Res =>  Map[X,Y] := N,
                                    Res := Map.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% READING A FILE  with a MAP or Grid....
read_Map_1(File_NAME) = Arr_2D  
    =>
    Reader = open(File_NAME), 
    Lines = read_int(Reader), %% dimentions of Grids
    Cols = read_int(Reader),
    new_array(Lines , Cols ) = Arr_2D, %% creating an array 2D
    I = 1, 
    while (not at_end_of_stream(Reader)) %% continuando a leitura
        L_read := read_line(Reader),
        delete_all( L_read, ' ') = L_aux, %% exclui ' ' do mapa
        Arr_AUX = to_array(L_aux),   %% converte lista para array
    %    printf("\n By Line: %w",  L_aux ),
    %    printf("\n  By Array %d: %w", I, Arr_AUX ),
        Arr_2D[I] := Arr_AUX ,  %% array recebe uma linha -- teste
        I := I+1
       end,
    close(Reader)  .
    %% printf("\n The Final Array: %w\n\n", Arr_2D )


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% READING A MAP  ....
read_Map_2(File_NAME) = Arr_2D  
    =>
      L_read = read_file_lines(File_NAME),
      writeln(list_read=L_read),
      L_flatten = flatten(L_read),
      L_aux= delete_all( L_flatten, ' ') ,  %% exclui ' ' do mapa
      writeln(l_aux = L_aux),
      [Lines, Cols | List] = L_aux,
      N_rows = to_int(Lines),
      N_cols = to_int(Cols),
      println([N_rows , N_cols]),
  %%% CONFERIR SE LIST estah OK
      Arr_2D = new_array(N_rows , N_cols ) , %% cria um array 2D
      writeln( l_Final = List ),
      writeln(a_array = Arr_2D ),
      
      printf("\n Size: %d\n List:%w \n", length(List), List ),
  %%%% PROBLEM HERE   >>> to be rewrite it  
      Arr_2D = to_array(List)  ,   %% converte lista para array
      writeln(a_array = Arr_2D ),
          
      printf("\n Array: %w\n List:%w \n", Arr_2D, List ).
     

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  

%% printing mapa ....
print_map( M ) =>
 L = M.length,
 C = M[1].length,
  nl,
   foreach(I in 1  .. L)
     foreach(J in 1  ..  C)
      printf("%w " , M[I,J] )
     end,
     nl
   end.   
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
