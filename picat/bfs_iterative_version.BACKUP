
%%% Functional or Procedural Version of BFS -- By CCS
%%% There's a small error.
/*
  
       1
      / \
     2   3  ---------- 12
    / \ / \
   4   5   6 
  / \ /     \
 7   8       9
 |           |
 10         11

*/


bfs_iterative(Graph, InitNode, EndNode) = Sol =>
    Queue := [InitNode],  %%%% I did a queue using a list ... could be an array
    Visited := [InitNode], %%% List
    printf("\n Queue:%w  Visited:%w  EndNode: %w", Queue, Visited, EndNode),

    while ( Queue != [] && (not membchk(EndNode, Visited))) do
     
        % || get_top(Queue) != EndNode  || (not membchk(Next, Visited)) 
        printf("\n Get_top: %w", get_top(Queue)),
        Aux = dequeue(Queue), %% departure ... remove front of queue
        (Front, Temp_Queue) = Aux,  
        printf("\t Temp_Queue: %w  Front: %w  ", Temp_Queue, Front),
     
        next_nodes(Graph, Front, NextNodes),
        println(nextNODES= NextNodes),
        %%%(Next != EndNode)
        foreach (Next in NextNodes )
            if ((not membchk(Next, Visited)) )  then
                Queue := enqueue(Next, Temp_Queue),
                Visited := [Next] ++ Visited,
                Temp_Queue := Queue,
                printf("\n NEXT: %w  Visited: %w Temp: %w Queue: %w", Next, Visited, Temp_Queue, Queue )
            end
           %%% if (NextNodes == []) then


                
        end,
    end,
    /** Here it gets all nodes not included in that level/layer ***/
    nth(Index,Visited,EndNode), 
    slice(Visited,Index,Visited.length) = Sub_L,
    Sol = reverse(Sub_L)
    ;
    printf("\n Wrong INPUT in the Graph...stopped in:  %w", Visited )   
    .


/******************* AUX PREDICATES **********/
membchk_array(Element, Array) => 
    List = to_list(Array),
    membchk(Element,List).


get_top(Queue) = R =>
    R = last(Queue).

enqueue(V,Queue) = R => 
    R = [V]++Queue.

dequeue(Queue) = R =>
    if (len(Queue) > 0) then
        Front = last(Queue),
        append(New_Queue, [Front], Queue),
        R = (Front, New_Queue)
    else
        printf("\n The queue is empty"),
        %exit()
        R = (9999,[])
    end.


/* e) > 0) then
        L1 = Queue.to_list(),
        reverse(L1) = [Front|ResList],
        reverse(ResList) = L2,
        New_Queue = L2.to_array(),
        R = {Front, New_Queue}
    else
        printf("\n The queue is empty"),
        %exit()
        R = {9999,{ 

next_nodes([ {Node, Neighbours} | _], N, R) ?=> 
    N == Node, 
    R = Neighbours.
    
next_nodes([ _ | Graph], Node, Neighbours) => 
        next_nodes(Graph, Node, Neighbours).

all_nodes( Graph ) = Nodes =>
        %Nodes = sort( [N : Termo in Graph, {N, _} = Termo ]) . 
        Nodes = [N : Termo in Graph, {N, _} = Termo ] .   

/*
  
       1
      / \
     2   3  ---------- 12
    / \ / \
   4   5   6 
  / \ /     \
 7   8       9
 |           |
 10         11


*/

main ?=>
    % Definindo um grafo simples
    Graph = [
        {1, [2, 3]},
        {2, [4, 5]},
        {3, [5, 6, 12]},
        {4, [5, 7]},
        {5, [8]},
        {6, [9]},
        {7, [10]},
        {8, []},
        {9, [11]},
        {10, []},
        {11, []},
        {12, []}
        ],
 
    % Testando o BFS funcional
    InitNode = 1,
    EndNode = 12,
    Sol = bfs_iterative(Graph , InitNode, EndNode),
    printf("\n InitNode:%w  EndNode:%w  ", InitNode, EndNode),
    printf("\n Visiting sequence: %w \n", Sol),

    T = all_nodes(Graph),
    Nodes_Sorted = sort(T),
   /* foreach(EndNode in Nodes_Sorted)
        Sol = bfs_iterative(Graph , InitNode, EndNode),
        printf("\n\n INPUT DAT:"), 
        printf("\n InitNode:%w  EndNode:%w  ", InitNode, EndNode),
        printf("\n Visiting sequence: %w \n", Sol)
    end,
    */
        printf("\n End of main: OK\n").   

main => printf("\n End of main with fail ... NO SOLUTION"). 