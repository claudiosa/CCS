What is OPA?
OPA is a lightweight general-purpose policy engine that can be co-located with your service. You can integrate OPA as a sidecar, host-level daemon, or library.

What is the OPA Document Model?
* OPA policies (written in Rego) make decisions based on hierarchical structured data
* OPA itself is not tied to any particular domain model. Similarly, OPA policies can represent decisions as arbitrary structured data (e.g., booleans, strings, maps, maps of lists of maps, etc.)
* Data can be loaded into OPA from outside world using push or pull interfaces that operate synchronously or asynchronously with respect to policy evaluation.
* OPA has excellent support for loading JSON and YAML because they are prevalent in modern systems; however, OPA is not tied to any particular data format. OPA uses its own internal representation for structures like maps and lists (a.k.a., objects and arrays in JSON.)


What is Rego?
* Rego was inspired by Datalog (https://pt.wikipedia.org/wiki/Datalog fortunately, it is not hard), which is a well understood, decades old query language. Rego extends Datalog to support structured document models such as JSON.
* Rego queries are assertions on data stored in OPA. These queries can be used to define policies that enumerate instances of data that violate the expected state of the system.

Why use Rego?
* Use Rego for defining policy that is easy to read and write.
* Rego focuses on providing powerful support for referencing nested documents and ensuring that queries are correct and unambiguous.
* Rego is declarative so policy authors can focus on what queries should return rather than how queries should be executed. These queries are simpler and more concise than the equivalent in an imperative language.


About REGO:

ex1:
v if "hello" == "world"
If we evaluate v, the result is undefined because the body of the rule never evaluates to true. As a result, the document generated by the rule is not defined.

ex2:
We can define rules in terms of Variables as well:
t if { x := 42; y := 41; x > y }
The formal syntax uses the semicolon character ; to separate expressions. Rule bodies can separate expressions with newlines and omit the semicolon:
t2 if {
    x := 42
    y := 41
    x > y
}

ex3:
The future keyword if is optional. We could have written v and t2 like this:
v { "hello" == "world" }
and
t2 {
    x := 42
    y := 41
    x > y
}

Building rules:

The rule itself can be understood intuitively as:
rule-name IS value IF body
If the value is omitted, it defaults to true.

r if {
    some site in sites
    site.name == "prod"
}
AND
sites := [{"name": "prod"}, {"name": "smoke1"}, {"name": "dev"}]

so: true in this case ... undefined otherwise


Scalar Values:

greeting   := "Hello"
max_height := 42
pi         := 3.14159
allowed    := true
location   := null

Doing a query: [greeting, max_height, pi, allowed, location]
Output is:
[
  "Hello",
  42,
  3.14159,
  true,
  null
]

Composite Values:
Composite values define collections.
cube := {"width": 3, "height": 4, "depth": 5}
The result:
for: cube.width
3

Objects:
see the DOC - trivial

Sets:
 Sets are unordered collections of unique values. 
s := {cube.width, cube.height, cube.depth}

PS: Set documents are collections of values without keys. OPA represents set documents as arrays when serializing to JSON or other formats that do not support a set data type. The important distinction between sets and arrays or objects is that sets are unkeyed while arrays and objects are keyed, i.e., you cannot refer to the index of an element within a set.


References:
References are used to access nested documents.


sites[0].servers[1].hostname == sites[0]["servers"][1]["hostname"] = helium
for
sites := [
    {
        "region": "east",
        "name": "prod",
        "servers": [
            {
                "name": "web-0",
                "hostname": "hydrogen"
            },
            {
                "name": "web-1",
                "hostname": "helium"
            },
            {
                "name": "db-0",
                "hostname": "lithium"
            }
        ]
    }
    ]

Related with these References, there are concepts such: 
Variable Keys
Composite Keys
Multiple Expressions
Self-Joins

Jump it meanwhile !!!!!

Comprehensions:
  * Array Comprehensions
  * Object Comprehensions
  * Set Comprehensions
  
Jump it meanwhile !!!!!
  
UNTIL HERE ....

Complete Definitions:

    
    









