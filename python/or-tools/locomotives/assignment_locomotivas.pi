/* input data  */

import data_26_services.
import util.

main =>
    services(Services), %% from Excell
    printf("\n Num de servicos: %w\n", len(Services)),

    locomotives(Loc),
    printf("\n Num de Loc: %w\n", len(Loc)),
    
    %% where are the locomotives in each time
    locomotive_Class(Loc_Class),
    printf("\n Num de Loc-CLASS: %w\n", len(Loc_Class)),

    serv_class_equiv(Serv_Class_Equiv),
    printf("\n Num de Serv_Class_Equiv: %w\n", len(Serv_Class_Equiv)).

    %L = findall(R,assign(Services, Loc_Place_Time, [], R , W)),  % , {0,W}
    %printf("\n\n TOTAL de: %w", len(L)).
    %         
    assign(Services, Loc,  [], Resp, P)   .
    %,
    %fail.
    
%main => printf("\n\n NO MORE SOLUTIONS").

%%% always with current position of ALL locomotives 
%table(+,+,+,-, min)
% para quando todos serviços forem designados
assign(Sevices_OVER, Loc,  Current, All_Serv, P) ?=>
    Sevices_OVER == [],      
    All_Serv = Current,
    P = 0.
    %Sevices_OVER == []  ;  
       
%%% always with current position of ALL locomotives  in Loc_Places
%%%Loc_Class, Serv_Class_Equiv ==> tabelas de consulta
%Loc_Class, Serv_Class_Equiv ===> usar como consulta apenas

assign(Services_To_Do, Loc, Current, All_Serv, P) =>    
    % Current: lista das designações  até em então, começa com vazia
    % All_Serv: usado para retorno de Current, pois Current veio como vazia inicialmente
    % It is a function to get the early service in the list
    find_soon_service(Services_To_Do, A_Candidate),
    %% Ver localização, T_Start, e Classe de Servico
    find_a_locomotive(A_Candidate, Loc, New_Loc, Loc_Assigned ),
    %% caso encontre uma locomotiva ... esta será atualizada
    %% predicados para o backtracking
    %%% ESTE EH O SERVICO
    (Id_Serv, Start_P, Start_T, End_P, End_T, Class) = A_Candidate,
  %  Todas_Local_Tempo = findall(find_soon_service(Services_To_Do)),
  %  printf("\n Todas: %w", Todas_Local_Tempo),
    % (S_Next: where my service start STATION, Loc_Place_Time, - )        
    % T1_Next: when this service starts
    % E_Next: where this service finish
    % T2_Next: when this service ends
    
    % printf("\n => Serv: %w Precisa_em: %w  no_T1:%w  FIM_em:%w no_T2:%w ", Id_Next, S_Next, T1_Next, E_Next, T2_Next),
    % As a predicate to allow backtracking over this search
    
    /*** 
        tomar tempo da locomotiva escolhida ... que eh o quanto ela esperava lá desde entao
    ****/
    if ( Loc == New_Loc ) then %% NAO CONSEGUIU ATRIBUIR UMA LOCOMOTIVA A ESTE SERVICO
    %% NAO encontra locomotiva naquela estacao de partida
    %% Esta locomotiva eh atualizada na sua posição e quando ficará livre
    (
        printf("\n PULOU: %w ", A_Candidate),
        printf("\n As locomotivas estão em: %w", New_Loc),
        %%%% nao altera lista das locomotivas
        %% Exclui este serviço
        Others_Services = delete(Services_To_Do, A_Candidate),
        %% Adiciona esta mensagem para este serviço
        %append([(Id_Next ,'NO SOLUTION FOR THIS SERVICE')], Current, New_Current)
        append([(Id_Serv ,'no locomotive')], Current, New_Current)
    )    
    else (
        %%% find a locomotive in that station
        %New_Loc = update_position(A_Candidate, Loc),
        printf("\n SERV:%w  ", A_Candidate),
                
        Others_Services = delete(Services_To_Do, A_Candidate),
        append([(Id_Serv, Loc_Assigned)], Current, New_Current)
        )
    end,
    assign(Others_Services, New_Loc, New_Current, All_Serv, P_temp),
    P = P_temp + Penalty.

    %  printf(" -> %w", W ).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

find_soon_service([], A_Candidate) ?=> A_Candidate = '()'.
find_soon_service([A], A_Candidate) ?=> A_Candidate = A.
find_soon_service([A,B|Services_To_Do], A_Candidate) ?=>
    (_, _, Start_T_A, _, _, _) = A,
    (_, _, Start_T_B, _, _, _) = B,
    Start_T_A =< Start_T_B,
    find_soon_service([A|Services_To_Do], A_Candidate).

find_soon_service([A,B|Services_To_Do], A_Candidate) =>
        (_, _, Start_T_A, _, _, _) = A,
        (_, _, Start_T_B, _, _, _) = B,
        Start_T_A > Start_T_B,
        find_soon_service([B|Services_To_Do], A_Candidate).

/*
        Picat> "250"==to_string(250).
        Picat> '111'==to_atom("111").

Picat> X=to_string(250). 
X = ['2','5','0']
yes

Picat> X=to_string('250').
X = ['2','5','0']

*/       
%% id	locomotiveClass 	location	locationDatetime
%%%find_a_locomotive(A_Candidate, Loc, New_Loc, Loc_Assigned )
find_a_locomotive(_, [], [], Loc_Assigned ) ?=> true.
find_a_locomotive(Serv_Candidate, [A|Loc], [B| Loc], Loc_Assigned ) ?=>
    (Id_Serv, Start_P, Start_T, End_P, End_T, Class) = Serv_Candidate,
    locomotive_Class(Loc_Classes),
    %% vai ldual, sdiesel, mdiesel etc...
    %% TODAS LOCOMOTIVAS DESTA CLASSE
    find_locs_in_class(Loc_Classes, Class, L_loc_in_class),
    !,
    %% backtracking AQUI ....
    member(Loc_Candidate, L_loc_in_class)
    (Id_Loc, Loc_Class, Position, Time) = Loc_Candidate,
    Loc_Class == Which_Class,
    Position == Start_P,
    Time =< Start_T,
    B = (Id_Loc, Loc_Class, End_P, End_T),
    Loc_Assigned = Id_Loc.

find_a_locomotive(Serv_Candidate, [A|Loc],  New_Loc, Loc_Assigned ) =>
        (Id_Serv, Start_P, Start_T, End_P, End_T, Class) = Serv_Candidate,
        (Id_Loc, Loc_Clas, Position, Time) = A,
        %% basta a posição diferente e classe diferentes
        %% pensar depois aqui.
        (Position \= Start_P ;
        Loc_Class \= Class),
        find_a_locomotive(Serv_Candidate, Loc, New_Loc, Loc_Assigned ).   
        
%%%     Which_Class = find_loc_in_class(Class, Loc_Classes),
%% Retorna a lista de locomotivas DAQUELA CLASSE
find_locs_class([] , _, L_Candidate ) ?=> L_Candidate = [].

find_locs_class([ A | Rest], Which_Class,  L_ATENCAO ) ?=>
     (Id_Loc, Loc_Class, Position, Time) = A,
     to_string(Loc_Class) == to_string(Which_Class),
     Uma_Loc = A,
     L_ATENCAO = [ Uma_Loc | L_Candidate ],
     find_locs_class( Rest, Which_Class, L_Candidate) .

find_locs_class([A|Rest], Which_Class, L_Candidate) =>
    (Id_Loc, Loc_Class, Position, Time) = A,
     to_string(Loc_Class) != to_string(Which_Class),
     find_locs_class( Rest, Which_Class, L_Candidate ).


%%%Picat> locomotives(X), init_location(Y), T= build_tuple(X,Y), find_a_L(ahroo, T)= Z.
%update_position((A_Candidate, E_Next, T2_Next), Loc_Place_Time),
update_position((A_Candidate, E_Next, T2_Next), [] ) = R => R = [].
update_position((A_Candidate, E_Next, T2_Next), [(Loc_Curr, Where_is, When) | Rest]) =  New_Loc_Place
              , (A_Candidate == Loc_Curr) =>
               New_Loc_Place = [(A_Candidate, E_Next, T2_Next) | Rest].
update_position((A_Candidate, E_Next, T2_Next), [(Loc_Curr, Where_is, When)|Rest]) = New_Loc_Place
        , (A_Candidate != Loc_Curr) => 
        New_Loc_Place = [(Loc_Curr,Where_is,When) | update_position((A_Candidate, E_Next, T2_Next), Rest) ].

/*
x => L=  [('159-008',ahroo,0),('159-002',bwur,0),('159-219',bwur,0),('159-010',bwur,0),('159-004',lqb,0)],
    write(L),
    update_position(('159-002',flor,0), L) = K,
    write(K).

Picat> update_position(('159-010',flor,10) , [('159-008',ahroo,0) , ('159-002',bwur,0) , ('159-010', bwur,0)]) = X.  
X = [('159-008',ahroo,0),('159-002',bwur,0),('159-010',flor,10)]
yes
*/

% Fazer recursiva - predicativa

%n_3_tupla((_, _, X, _, _)) = X.


fil_1(L) = R , len(L) == 0 => R = [].
fil_1([(A,B)|L]) = R , B == 'xxx' =>
    R = [(A,B) | fil_1(L)].
fil_1([(A,B)|L]) = R  =>
    R =  fil_1(L).


fil_2(L) = R , len(L) == 0 => R = [].
fil_2([(A,B)|L]) = R , B != 'xxx' =>
    R = [(A,B) | fil_2(L)].
fil_2([(A,B)|L]) = R  => R = fil_2(L).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%