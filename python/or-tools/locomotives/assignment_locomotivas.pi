/* input data  */
%import input_100.
import input_27.

main =>
    input_tuples(Services), %% from Excell
    %Services = [(Id, Start, T1, End, T2)| Others_Services], 
    printf("\n Num de servicos: %w\n", len(Services)),

    locomotives(Loc),
    init_location(Init_Location),  
    Loc_Place_Time = build_tuple_3(Loc, Init_Location),
    print(Loc_Place_Time),
    %% where are the locomotives in each time
   
    %L = findall(R,assign(Services, Loc_Place_Time, [], R , W)),  % , {0,W}
    %printf("\n\n TOTAL de: %w", len(L)).
    assign(Services, Loc_Place_Time, [], R , W),
    
    printf("\n\n Planos: "),
    Plan = reverse( R ),
    printf("\n\n TOTAL de Servicos: %w", len(Plan)),

    printf("\n REALIZADOS: %w", fil_2(Plan)),
    printf("\n QUANTOS REALIZADOS: %w", len(fil_2(Plan))),

    printf("\n\n NAO REALIZADOS: %w", fil_1(Plan)),
    printf("\n QUANTOS NAO REALIZADOS: %w", len(fil_1(Plan))),
    printf("\n\n T_FINAL: %w\n",W).
    %,
    %fail.
    
%main => printf("\n\n NO MORE SOLUTIONS").

%%% always with current position of ALL locomotives 
%table(+,+,+,-, min)
assign(Sevices_OVER, Loc_Place_Time, Current, All_Serv, W),
% para quando todos serviços forem designados
   %(len(fil_2(Current)) >=26 )
    Sevices_OVER == []  
    ?=>
    All_Serv = Current,
    W = 0.
    %Sevices_OVER == []  ;  
       
%%% always with current position of ALL locomotives  in Loc_Places
assign(Services_To_Do, Loc_Place_Time, Current, All_Serv, W) =>
    % Current: lista das designações  até em então, começa com vazia
    % All_Serv: usado para retorno de Current, pois Current veio como vazia inicialmente
    % It is a function to get the early service in the list
    (Id_Next, S_Next, T1_Next, E_Next, T2_Next) = find_soon_service(Services_To_Do),
    
    % (S_Next: where my service start STATION, Loc_Place_Time, - )        
    % T1_Next: when this service starts
    % E_Next: where this service finish
    % T2_Next: when this service ends
    
    % printf("\n => Serv: %w Precisa_em: %w  no_T1:%w  FIM_em:%w no_T2:%w ", Id_Next, S_Next, T1_Next, E_Next, T2_Next),
    % As a predicate to allow backtracking over this search
    find_a_locomotive((S_Next, T1_Next), Loc_Place_Time, {A_Candidate, T_Wait}),
    /*** 
        tomar tempo da locomotiva escolhida ... que eh o quanto ela esperava lá desde entao
    ****/
    if ( A_Candidate == 'no_locomotive' ) then
    %% NAO encontra locomotiva naquela estacao de partida
    %% Esta locomotiva eh atualizada na sua posição e quando ficará livre
    (
        printf("\n PULOU: %w PRECISAVA em: %w", Id_Next, S_Next),
        printf("\n As locomotivas estão em: %w", Loc_Place_Time),
        New_Loc_Place_Time = Loc_Place_Time, %%%% nao altera lista das locomotivas
        %% Exclui este serviço
        Others_Services = delete(Services_To_Do, (Id_Next, S_Next, T1_Next, E_Next, T2_Next)),
        %% Adiciona esta mensagem para este serviço
        %append([(Id_Next ,'NO SOLUTION FOR THIS SERVICE')], Current, New_Current)
        append([(Id_Next ,'xxx')], Current, New_Current)
    )    
    else (
        %%% find a locomotive in that station
        New_Loc_Place_Time = update_position((A_Candidate, E_Next, T2_Next), Loc_Place_Time),
        printf("\n SERV:%w ACHOU:%w EM %w DEIXOU EM %w ", Id_Next, A_Candidate, S_Next, E_Next),
        Others_Services = delete(Services_To_Do, (Id_Next, S_Next, T1_Next, E_Next, T2_Next)),
        append([(Id_Next , A_Candidate)], Current, New_Current)
        )
    end,

    assign(Others_Services, New_Loc_Place_Time, New_Current, All_Serv, W_temp ),
    W = W_temp + (T1_Next - T_Wait).
    %  printf(" -> %w", W ).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

build_tuple_3([],[]) = [].
build_tuple_3([A|L1], [B|L2]) = Ys =>
            Ys = [ (A,B,0) | build_tuple_3(L1,L2)]. 
%% locomotive_ID, Position and time = 0 
%find_a_locomotive(Start, [], Answer) ?=> Answer = 'NOT MORE LOCOMOTIVES'.
%%% PREDICATIVE CLAUSE -- need a backtracking
%%% em caso de falha????

/*
find_a_locomotive(_, [], {no_locomotive, 0}) => true, !.
MAS NAO ADICIONA A MENSAGEM CORRETAMENTE DE SERVICOS
INVALIDOS
*/
find_a_locomotive((_, _), [],  {L, T}) ?=> 
    L = 'no_locomotive', %'NO LOC in this PLACE',
    T = 9999999, !.

find_a_locomotive((Station_S, Start_T), [(Lomotive, Where_is, T_Wait)|Rest], {L, T}),
    (Station_S == Where_is, 
    Start_T >= T_Wait)
    ?=>  
    L = Lomotive,
    T = T_Wait.

find_a_locomotive((Station_S, Start_T), [(_,_,_) |Rest],  {L, T}) =>  
    find_a_locomotive((Station_S, Start_T), Rest,  {L, T} ).

/*
Picat> L = [('159-008',ahroo,0),('159-002',bwur,0),('159-010',bwur,0)], find_a_locomotive((bwur,10),L, {X,Y}).
L = [('159-008',ahroo,0),('159-002',bwur,0),('159-010',bwur,0)]
X = '159-002'
Y = 0 ?;
L = [('159-008',ahroo,0),('159-002',bwur,0),('159-010',bwur,0)]
X = '159-010'
Y = 0 ?;
L = [('159-008',ahroo,0),('159-002',bwur,0),('159-010',bwur,0)]
X = no_locomotive
Y = 0
yes

*/

%%%Picat> locomotives(X), init_location(Y), T= build_tuple(X,Y), find_a_L(ahroo, T)= Z.
%update_position((A_Candidate, E_Next, T2_Next), Loc_Place_Time),
update_position((A_Candidate, E_Next, T2_Next), [] ) = R => R = [].
update_position((A_Candidate, E_Next, T2_Next), [(Loc_Curr, Where_is, When) | Rest]) =  New_Loc_Place
              , (A_Candidate == Loc_Curr) =>
               New_Loc_Place = [(A_Candidate, E_Next, T2_Next) | Rest].
update_position((A_Candidate, E_Next, T2_Next), [(Loc_Curr, Where_is, When)|Rest]) = New_Loc_Place
        , (A_Candidate != Loc_Curr) => 
        New_Loc_Place = [(Loc_Curr,Where_is,When) | update_position((A_Candidate, E_Next, T2_Next), Rest) ].

/*
x => L=  [('159-008',ahroo,0),('159-002',bwur,0),('159-219',bwur,0),('159-010',bwur,0),('159-004',lqb,0)],
    write(L),
    update_position(('159-002',flor,0), L) = K,
    write(K).

Picat> update_position(('159-010',flor,10) , [('159-008',ahroo,0) , ('159-002',bwur,0) , ('159-010', bwur,0)]) = X.  
X = [('159-008',ahroo,0),('159-002',bwur,0),('159-010',flor,10)]
yes
*/


retorna_3o_da_tupla((_, _, X, _, _)) = X.

menor([]) = R, len([]) == 0 => R = '()'.
menor([A]) = R, len([A]) == 1 => R = A.              
menor([A, B | L]) = R, retorna_3o_da_tupla(A) < retorna_3o_da_tupla(B) => R = menor([A | L]).    
menor([A, B | L]) = R, retorna_3o_da_tupla(B) =< retorna_3o_da_tupla(A) => R = menor([B | L]).

% Função que encontra a tupla com o menor elemento na terceira posição
find_soon_service(Lista) = R =>
    R = menor(Lista).
/*
Testes
 input_tuples(L), (Id_Next, S_Next, T1_Next, E_Next, T2_Next) = find_soon_service(L).
x => L = [('a001', 'ahroo', 16, 'dro', 168), 
     ('a002', 'dro', 18, 'bno', 184),
     ('a003', 'bno', 10, 'dro', 1800), 
     ('a002', 'dro', 1400, 'bno', 8800)],

    Resultado = encontra_menor_tupla(L),
    print(Resultado),
    delete(L, Resultado) = Y,
    printf("\n NEW: %w", Y).
*/
fil_1(L) = R , len(L) == 0 => R = [].
fil_1([(A,B)|L]) = R , B == 'xxx' =>
    R = [(A,B) | fil_1(L)].
fil_1([(A,B)|L]) = R  =>
    R =  fil_1(L).


fil_2(L) = R , len(L) == 0 => R = [].
fil_2([(A,B)|L]) = R , B != 'xxx' =>
    R = [(A,B) | fil_2(L)].
fil_2([(A,B)|L]) = R  => R = fil_2(L).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%