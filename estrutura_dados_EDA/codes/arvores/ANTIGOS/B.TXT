 /* Move: moves count disks from start to finish using temp for temporary storage   *//* nonrecursive version */void Move(int count, int start, int finish, int temp){    Stack stack;    int return_address; /* selects place to return after recursion  */    stack.count = 0;                /* Initialize the stack.    */L0:     /* marks the start of the original recursive function   */    if (count > 0) {        Push(count, start, finish, temp, 1, &stack);        count--;        Swap(&finish, &temp);        goto L0;L1:     /* marks the return from the first recursive call   */        printf("Move a disk from %2d to %2d\n", start, finish);        Push(count, start, finish, temp, 2, &stack);        count--;        Swap(&start, &temp);        goto L0;    }L2:     /* marks the return from the second recursive call  */    if (stack.count > 0) {        Pop(&count, &start, &finish, &temp, &return_address, &stack);        switch (return_address) {        case 1 :            goto L1;            break;        case 2 :            goto L2;            break;        }    }} void Push(int count, int start, int finish, int temp, int address, Stack *stack){    int i = stack->count;    stack->entry[i].count = count;    stack->entry[i].start = start;    stack->entry[i].finish = finish;    stack->entry[i].temp = temp;    stack->entry[i].address = address;    stack->count++;} void Pop(int *count, int *start, int *finish, int *temp,        int *address, Stack *stack){    int i = --stack->count;    *count = stack->entry[i].count;    *start = stack->entry[i].start;    *finish = stack->entry[i].finish;    *temp = stack->entry[i].temp;    *address = stack->entry[i].address;}void Swap(int *x, int *y){    int tmp;    tmp = *x;    *x = *y;    *y = tmp;} void P( /* parameters */ )      /* recursive version */{    /* local declarations to be inserted here */    while (!termination) {        Block A;    /* first part of program; empty for example */        P;          /* only recursive call to function itself   */        Block B;    /* next part of program                     */    }    Block C;        /* final part of program; empty for our example */} void P( /* parameters */ )  /* preliminary nonrecursive version */{    /* local declarations to be inserted here   */    /* Declaration of stack goes here.          */    Set stack to be empty;L0:    while (!termination) {        Block A;    /* first part of program    */        Push data onto stack and change parameters;        goto L0;L1:        Block B;    /* next part of program     */    }    Block C;        /* final part of program    */    if (stack not empty) {        Pop data from stack;        goto L1;    }} void P( /* parameters */ )  /* nonrecursive version */{    /* local declarations to be inserted here   */    /* Declaration of stack goes here.          */    Set stack to be empty;    do {        if (stack not empty) {            Pop data from stack;            Block B;    /* next part of program     */        }        while (!termination) {            Block A;    /* first part of program    */            Push data onto stack and change parameters;        }        Block C;        /* final part of program    */    } while (stack not empty);} /* Move: moves count disks from start to finish using temp fortemporary storage   *//* folded nonrecursive version                                      */void Move(int count, int start, int finish, int temp){    Stack stack;    stack.count = 0;    do {        if (stack.count != 0) {            Pop(&count, &start, &finish, &temp, &stack);            printf("Move a disk from %2d to %2d\n", start, finish);            count--;            Swap(&start, &temp);        }        while (count > 0) {            Push(count, start, finish, temp, &stack);            count--;            Swap(&finish, &temp);        }    } while (stack.count > 0);} #include "node.h"void Visit(Node_type *);/* Preorder: without tail recursion */void Preorder(Node_type *root){    while (root) {        Visit(root);        Preorder(root->left);        root = root->right;    }} #include "node.h"#include "stack.h"void Visit(Node_type *);void Pop(Item_type *, Stack_type *);void Push(Item_type, Stack_type *);/* Preorder: non-recursive  */void Preorder(Node_type *root){    Stack_type S;    S.count = 0;    do {        if (S.count != 0) {            Pop(&root, &S);            root = root->right;        }         while (root) {            Push(root, &S);            Visit(root);            root = root->left;        }    } while (S.count > 0);} #include "node.h"void Visit(Node_type *);/* Inorder: without tail recursion  */void Inorder(Node_type *root){    while (root) {        Inorder(root->left);        Visit(root);        root = root->right;    }} #include "node.h"#include "stack.h"void Visit(Node_type *);void Pop(Item_type *, Stack_type *);void Push(Item_type, Stack_type *);/* Inorder: non-recursive   */void Inorder(Node_type *root){    Stack_type S;    S.count = 0;    do {        if (S.count != 0) {            Pop(&root, &S);            Visit(root);            root = root->right;        }         while (root) {            Push(root, &S);            root = root->left;        }    } while (S.count > 0);} #include "general.h"#include "node.h"#include "stkpost.h"void Pop(Item_type *, Stack_type *);void Push(Item_type, Stack_type *);void Visit(Node_type *);/* Postorder: non-recursive */void Postorder(Node_type *root){    Stack_type S;    Item_type stkitem;    S.count = 0;    do {        while (root) {            stkitem.link = root;            stkitem.leftbranch = TRUE;            Push(stkitem, &S);            root = root->left;        }         if (S.count != 0) {            Pop(&stkitem, &S);            if (stkitem.leftbranch) {                stkitem.leftbranch = FALSE;                Push(stkitem, &S);                root = stkitem.link->right;             } else {                Visit(stkitem.link);                root = NULL;            }        }    } while (S.count > 0);} typedef double Key_type;typedef struct node_tag {    Key_type info;    struct node_tag *left;    struct node_tag *right;} Node_type; #define MAXSTACK    20typedef struct item_tag {    Node_type *link;    Boolean_type leftbranch;    /* is the pointer a left branch?    */} Item_type;typedef struct stack_tag {    int count;    Item_type entry[MAXSTACK];} Stack_type; void P(void){/* local declarations for P */    while (!termP) {        Block A;        Q();        Block B;    }    Block C;} void Q(void){/* local declarations for Q */    while (!termQ) {        Block X;        P();        Block Y;    }    Block Z;} void P(void){    /* local declarations for P and Q and for   */    /* a stack of local variables and parameters    */    Initialize stack to empty;L1:    while (!termP) {        /* Begin call to P    */        Block A;        while (!termQ) {    /* Begin call to Q    */            Block X;            Push local variables and parameters onto stack;            goto L1;            /* Recursively call P */L2:            Block Y;    /* Return (to Q) from recursive call to P   */        }        Block Z;        Block B;        /* Return (to P) from call to Q */    }    Block C;    if (!empty(stack) { /* Prepare to return from a recursive call.     */        Pop local variables and parameters from stack;        goto L2;        /* Return (to Q) from a recursive call to P */    }} void P(){/* local declarations for P and Q and fora stack of local variables and parameters    */    /* used to select code to do next   */    enum step {STARTP, STARTQ, STOP} Step;    Initialize(stack);    step = STARTP;    do {        switch (step) {        case STARTP:    /* Begin call to P.   */            if (termP) {                Block C;    /* part of P after loop terminates    */                if (empty(stack))                /* This is the outermost call; function terminates. */                    step = STOP;                else {                /* Prepare to return from a recursive call to P.  */                    Pop local variables, parameters from stack;                    Block Y;    /* Return (to Q) from call to P */                    step = STARTQ;                }            } else {    /* Start the main loop of P.  */                Block A;                step = STARTQ;            }            break;        case STARTQ:    /* Begin call to Q.   */            if (termQ) {                Block Z;                Block B;    /* Return (to P) from call to Q.    */                step = STARTP;            } else {                Block X;                Push local variables, parameters onto stack;                step = STARTP;  /* Begin a recursive call to P.   */            }            break;        }    } while (step != STOP);} #include "general.h"extern int col[];extern Boolean_type colfree[];extern Boolean_type upfree[];extern Boolean_type downfree[];void AddQueen(int row, int c){    while (row < 8 && c < 8) {        if (colfree[c] && upfree[row+c] && downfree[row-c]) {        /* The previous lines give the termination condition.         Block A starts here.  Put a queen in position [row][c]. */            col[row] = c;            colfree[c] = FALSE;            upfree[row+c] = FALSE;            downfree[row-c] = FALSE;            AddQueen(row + 1, 1);             /* Now backtrack by removing the queen; this starts Block B */            colfree[c] = TRUE;            upfree[row+c] = TRUE;            downfree[row-c] = TRUE;        }        c++;    }     if (row >= 8)        WriteBoard();   /* This starts Block C. */} #include "general.h"typedef struct item_tag {    int row, col;} Item_type;extern int col[];extern Boolean_type colfree[];extern Boolean_type upfree[];extern Boolean_type downfree[];void AddQueen(int row, int c){    Item position;    /* Insert standard declarations for a stack S of items.   */    Initialize(S);    do {        if (!Empty(S)) {            position = Pop(S);            row = position.row;            c = position.col;            colfree[c] = TRUE;      /* This starts Block B. */            upfree[row+c] = TRUE;            downfree[row-c] = TRUE;            c++;        }         while (row < 8 && c < 8)            if (colfree[c] && upfree[row+c] && downfree[row-c]) {    /* The previous lines give the termination condition.    Block A starts here.  Put a queen in position [row][c]. */                col[row] = c;                colfree[c] = FALSE;                upfree[row+c] = FALSE;                downfree[row-c] = FALSE;                position.row = row; /* Save current parameters on stack.    */                position.col = c;                Push(position, S);                row++;  /* Change parameters to new values.     */                c = 1;             } else                c++;    /* Force progress toward termination.   */        if (row >= 8)   /* This starts Block C. */            WriteBoard();    } while (!Empty(S));} /* Sort: removed tail recursion */void Sort(List *list, int low, int high){    int pivotloc;    while (low < high) {        pivotloc = Partition(list, low, high);        Sort(list, low, pivotloc - 1);        low = pivotloc + 1;    }} #define MAXSTACK 20     /* allows sorting up to 1,000,000 items *//* NRQuickSort: nonrecursive quicksort  */void NRQuickSort(List *list){int low, high;           /* bounds of list being sorted          */int pivotpos;int lowstack[MAXSTACK]; /* Declare two arrays for the stack.     */int highstack[MAXSTACK];int nstack = 0;     low = 0;     high = list->count - 1;     do {        if (nstack > 0) {   /* Pop the stack.   */            nstack--;            low = lowstack[nstack];            high = highstack[nstack];        }          while (low < high) {               pivotpos = Partition(list, low, high);               /* Push larger sublist onto stack, and do smaller.     */               if (pivotpos - low < high - pivotpos) {                    /* Stack right sublist and do left.     */                    if (nstack >= MAXSTACK)                       Error("overflow");                    lowstack[nstack] = pivotpos + 1;                    highstack[nstack] = high;                    nstack++;                    high = pivotpos - 1;               } else {                    /* Stack left sublist and do right.     */                    if (nstack >= MAXSTACK)                       Error("overflow");                    lowstack[nstack] = low;                    highstack[nstack] = pivotpos - 1;                    nstack++;                    low = pivotpos + 1;               }          }     } while (nstack != 0);} #define MAXLOG 20   /* allows over 1,000,000 entries in list    *//* NRMergeSort: nonrecursive mergesort  */void NRMergeSort(List *list){    ListNode *sublist[MAXLOG+1];    ListNode *p;        /* first unsorted item from list    */    ListNode *q;        /* a (partial) merged list          */    int i;    int c = 0;          /* counter (index) of current item  */    int mergecount;     /* largest power of 2 dividing c  */    int d;              /* a digit in binary representation of c  */    for (i = 0; i <= MAXLOG; i++)        sublist[i] = NULL;    p = list->head;    while (p) {     /* Traverse the unsorted list.      */        c++;        mergecount = Power2(c);        q = p;        p = p->next;        q->next = NULL; /* Split off q as a sublist of size 1.    */        for (i = 1; i < mergecount; i++)            q = Merge(q, sublist[i]);        sublist[mergecount] = q;    }    /* At this point, the list has been traversed. The unmerged       sublists correspond to the 1's in the binary representation       of the counter c. Note that p == NULL at this point.       */    mergecount = 0;    while (c != 0) {        d = c % 2;      /* d is a binary digit in c.    */        c /= 2;        mergecount++;        if (d != 0)            if (p == NULL)  /* This only occurs for first nonzero d.  */                p = sublist[mergecount];            else                p = Merge(p, sublist[mergecount]);    }    list->head = p;} #include "common.h"int Power2(int);#define MAXDISK 64#define ODD(x) ((x)/2*2 != x)/* nonrecursive solution to Towers of Hanoi */main(int argc, char *argv[]){    int t;          /* used to exchange needles         */    int a = 1;      /* source where disks are initially */    int b = 2;      /* destination needle               */    int c = 3;      /* needle for intermediate storage  */    int ndisks;     /* number of disks to move          */    int d;          /* current disk                     */    int count;      /* index of current move            */    int last;       /* total number of moves needed     */    switch(argc) {    case 2 :        ndisks = atoi(argv[1]);        if (ndisks < 0 || ndisks > MAXDISK) {            fprintf(stderr, "The number of disks must be between ");            fprintf(stderr, "0 and %d\n", MAXDISK);            exit(1);        }        break;    default :        fprintf(stderr, "Usage: %s <ndisks>\n", argv[0]);        exit(1);    }    if (ODD(ndisks)) { /* Adjust to correct the destination disk.   */        c = 2;        b = 3;    }    last = 1;   /* Calculate number of moves: 2 ^ ndisks - 1.   */    for (count = 1; count <= ndisks; count++)        last += last;    last--;    for (count = 1; count <= last; count++) {   /* main loop on moves   */        d = Power2(count);      /* Determine the disk number to move.   */        if (ODD(d))            printf("Move disk %d from %d to %d\n", d+1, c, a);        else            printf("Move disk %d from %d to %d\n", d+1, a, c);        t = a;      /* Rotate the three needles.    */        a = b;        b = c;        c = t;    }    return 0;}/* Power2: find highest power of 2 for count  */int Power2(int count){    int level;    for (level = 0; !ODD(count); level++)        count /=2;    return level;}     p = root;        /* pointer that moves through the tree */    while (p) {        while (p->left)            p = p->left;        Visit(p);        p = p->right;    } #define MAXNODES    50typedef int Key;typedef struct node {    Key key;    /* Other information fields go here.    */    int left, right;} Node;extern Node ws[];       /* workspace for linked trees       */extern int root;        /* root of the threaded binary search tree  */typedef enum action {GOLEFT, GORIGHT, VISITNODE} Action;void Visit(int);int Insert(int, int);void LeftInsert(int, int);void RightInsert(int, int);void Parent(int, int *, Action *);void PreOrder(int, void (*)(int));void InOrder(int, void (*)(int));void PostOrder(int, void (*)(int)); /* Inorder: inorder traversal of a threaded binary tree */void Inorder(int p){    if (p > 0)  /* Find the first (leftmost) node for inorder traversal.    */        while (ws[p].left > 0)            p = ws[p].left;     while (p) {     /* Now visit the node, and go to its successor.     */        Visit(p);        p = ws[p].right;        if (p < 0)  /* If this is a thread link, it gives the successor.    */            p = -p;        else if (p > 0)     /* Otherwise, move as far left as possible. */            while (ws[p].left > 0)                p = ws[p].left;          /* If neither section is done, p == 0 and the traversal is done.   */    }} /* Preorder: preorder traversal of a threaded binary tree   */void Preorder(int p){  while (p > 0) {    Visit(p);    if (ws[p].left > 0)      p = ws[p].left;    else if (ws[p].right > 0)      p = ws[p].right;    else {                    /* Otherwise, p is a leaf. We take its right thread,*/      while (ws[p].right < 0) /* which will return to a node already visited,*/        p = -ws[p].right;     /* and move to the right again. */        p = ws[p].right;      }   }} /* LeftInsert: inserts the node at q as the left subtree of the node at p   */void LeftInsert(int q, int p){    if (ws[p].left > 0) {        Error("non-empty left subtree");    } else {        ws[q].left = ws[p].left;        ws[q].right = -p;        ws[p].left = q;    }} /* Insert: Pre:  q is a node to insert.  root is a threaded tree.Post: q has been inserted and the root of the tree is returned. */int Insert(int q, int root){int k;  if (root == 0) { /* Insert into an empty tree.    */    ws[q].left = 0;    ws[q].right = 0;    return q;  } else { /* Look for the place for the new key, starting at the root. */    k = root;    do {      if (ws[q].key < ws[k].key) {        if (ws[k].left <= 0) { /* We have an empty left subtree, insert the node.*/          LeftInsert(q,k);          break;        } else    /* Move to left subtree and continue search. */          k = ws[k].left;      } else if (ws[q].key > ws[k].key) {          if (ws[k].right <= 0) { /* We have an empty right subtree, insert the node.    */            RightInsert(q,k);            break;          } else    /* Move to right subtree and continue search.     */          k = ws[k].right;        } else {  /* We have found a duplicate of the new key. */          printf("Duplicate key: %d at positions %d and %d\n", ws[q].key, q, k);          break;      }    } while (1);        return root;  }} void PostOrder(void){    while (not all nodes have been visited)        switch (nextaction) {        case GOLEFT: Traverse the left subtree;                     Return to the node;                     nextaction = GORIGHT; break;        case GORIGHT: Traverse the right subtree;                      Return to the node;                      nextaction = VISITNODE; break;        case VISITNODE: Visit the node;                        Find the parent of the node;                        Set nextaction appropriately for the parent; break;        }} /* PostOrder: postorder traversal of binary tree with (inorder) threads */void PostOrder(int p){    Action_type nextaction;    nextaction = GOLEFT;    while (p)        switch (nextaction) {               /* Traverse the left subtree if it is nonempty.   */          case GOLEFT:            if (ws[p].left > 0)                p = ws[p].left;            else                nextaction = GORIGHT;            break;               /* Traverse the right subtree if it is nonempty.  */          case GORIGHT:            if (ws[p].right > 0) {                p = ws[p].right;                nextaction = GOLEFT;            } else                nextaction = VISITNODE;            break;               /* Visit the node and find its parent.  */          case VISITNODE:            Visit(p);            Parent(p, &p, &nextaction);               break;    }} /* Parent: Finds the parent of node p, and sets q to the parent.   Returns nextaction = GORIGHT if p is the left child of q,   and nextaction = VISITNODE if p is the right child of q.   If p is the root, returns q = 0.   */void Parent(int p, int *q, Action *nextaction){    *q = p;     /* Locate the inorder successor of p; set it to q.  */    while (*q > 0)        *q = ws[*q].right;    if (*q == 0)    /* No successor: p cannot be a left child.    */        *nextaction = VISITNODE;    else if (ws[-*q].left == p) {   /* p is left child of -q. */        *nextaction = GORIGHT;        *q = -*q;    } else        *nextaction = VISITNODE; /* If nextaction = GORIGHT, then we are finished.  If nextaction = VISITNODE,   find the parent as the inorder predecessor of subtree of p. */    if (*nextaction == VISITNODE) {        *q = p;        while (*q > 0)            *q = ws[*q].left;        *q = -*q;    }} typedef struct item_tag {    int key;} Item_type;/* new declaration of node for threaded trees */typedef struct node_tag {    Item_type info;    struct node_tag *left;      /* act as either branch or thread   */    struct node_tag *right;    Boolean_type lthread;       /* Is the left branch a thread?     */    Boolean_type rthread;       /* Is the right branch a thread?    */} Node_type; #include "general.h"#include "node.h"/* LeftInsert: Inserts a node into a threaded tree.  Links of the new node are inserted as threads.  */void LeftInsert(Node_type **q, Node_type **p){    if (!(*p)->lthread)        Error("Left branch is not a thread.");    else {        (*q)->left = (*p)->left;        (*q)->lthread = TRUE;        (*q)->right = *p;        (*q)->rthread = TRUE;        (*p)->left = *q;        (*p)->lthread = FALSE;    }} #include "general.h"#include "node.h"void Visit(Node_type *);/* Inorder: traversal of a threaded tree    */void Inorder(Node_type *root){    if (root)        while (!root->lthread)            root = root->left;     while (root) {        Visit(root);        if (root->rthread)            root = root->right;         else {            root = root->right;            while (!root->lthread)                root = root->left;        }    }} #include "general.h"#include "node.h"void Visit(Node_type *);/* Preorder: traversal of a threaded tree   */void Preorder(Node_type *root){    while (root) {        Visit(root);        if (!root->lthread)            root = root->left;         else if (root->rthread) {        /* root is a leaf take right thread, then move right.   */            while (root->rthread && root->right)                root = root->right;            root = root->right;         } else            root = root->right;    }} #include "general.h"#include "cursor.h"/* RightInsert: inserts the node at q as the right subtree of the node at p */void RightInsert(int q, int p){    if (ws[p].right > 0)        Error("Right branch not a thread.");    else {        ws[q].right = ws[p].right;        ws[q].left = -p;        ws[p].right = q;    }} #define MAX 10typedef struct node_tag {    int left;    int right;} Node_type;Node_type ws[MAX]; #include "general.h"#include "cursor.h"void DisposeNode(int);/* Delete: remove node from a threaded binary tree  */int Delete(int p){    int q, r; /* used to search for immediate predecessor or successor  */    if (p <= 0)        Error("can not delete a nonexistent node");    else if (ws[p].left > 0) {        /* Replace p by its immediate predecessor.  */        q = ws[p].left;        r = ws[q].right;    /* move right to find immediate predecessor */         if (r == -p) {  /* Immediate left child q of p can be moved up  */            ws[q].right = ws[p].right;            r = p;  /*Temporarily remember the node being deleted.      */            p = q;  /*Change the link in the tree to skip deleted node. */            DisposeNode(r);        } else if (r <= 0)            Error("Bad thread found");         else {            while (ws[r].right > 0) {                q = r;  /* Keep q one position before r in right chain. */                r = ws[q].right;            }   /* r is the predecessor of p and q is parent of r.  */             if (ws[r].right != -p)                Error("Successor of r must be p");            ws[r].right = ws[p].right;    /*Move r into position of p.*/             if (ws[r].left > 0)                ws[q].right = ws[r].left;            else                ws[q].right = -r;            ws[r].left = ws[p].left;            q = p;  /* Temporarily remember node to be deleted  */            p = r;  /* Change actual link in tree   */            DisposeNode(q);        }         if (ws[p].right > 0) {  /* Correct left thread from right subtree   */            q = ws[p].right;            while (ws[q].left > 0)                q = ws[q].left;            ws[q].left = -p;        }     } else if (ws[p].right > 0) {        /* Replace p by its immediate successor.    */        q = ws[p].right;        r = ws[q].left; /* move left to find immediate successor of p */         if (r == -p) {  /* Immediate right child q of p can be moved up */            ws[q].left = ws[p].left;            r = p;  /* Temporarily remember the node being deleted      */            p = q;  /* Change the link in the tree to skip deleted node */            DisposeNode(r);        } else if (r <= 0)            Error("Bad thread found");         else {            while (ws[r].left > 0) {                q = r;  /* Keep q one position before r in left chain   */                r = ws[q].left;            }   /* r is the successor of p and q is parent of r */             if (ws[r].left != -p)                Error("Predecessor of r must be p.");            ws[r].left = ws[p].left;    /* Move r into position of p    */            if (ws[r].right > 0)                ws[q].left = ws[r].right;            else                ws[q].left = -r;             ws[r].right = ws[p].right;            q = p;  /* Temporarily remember node to be deleted  */            p = r;  /* Change actual link in tree               */            DisposeNode(q);        }     } else  /* p is a leaf; determine if it is left, right, or only node  */        if (ws[p].left < 0) {            q = -ws[p].left;            if (ws[q].right == p) { /* p is right child of its parent q */                r = p;          /* Temporarily remember node being deleted  */                ws[q].right = ws[p].right;  /* Move thread up to the parent */                DisposeNode(r);            }         } else if (ws[p].right < 0) {            q = -ws[p].right;            if (ws[q].left == p) {  /* p is left child of its parent q  */                r = p;          /* Temporarily remember node being deleted  */                ws[q].left = ws[p].left;    /* Move thread up to the parent */                DisposeNode(r);            }         } else {    /* p is the only node in the tree */            DisposeNode(p);            p = 0;        }    return p;} #include "general.h"#include "cursor.h"typedef struct stkitem_tag {    int current;    /* node to be processed, will be popped from stack  */    int predecessor;    /* node preceding the tree rooted at current    */    int successor;      /* node following the tree rooted at current    */} Stkitem_type;typedef Stkitem_type Stack_type[MAX];void Pop(Stkitem_type *, Stack_type);void Initialize(Stack_type);void Push(Stkitem_type, Stack_type);Boolean_type Empty(Stack_type);/* Insert standard declarations for a contiguous stack from Chapter 3.  *//* Thread: takes an unthreaded binary tree, traverses it using a stack, *//* and inserts threads  */void Thread(int root){    Stkitem_type p;     /* record currently being processed */    Stkitem_type q;     /* record to be stacked             */    Stack_type S;       /* contains items; see Chapter 3    */    Initialize(S);    p.current = root;    p.predecessor = 0;  /* No vertex precedes or follows the entire tree    */    p.successor = 0;     while (p.current) { /* Hitting an empty tree terminates the function    */        if (ws[p.current].right == 0)            /* If no right subtree, insert thread   */            ws[p.current].right = -p.successor;        else {            q.current = ws[p.current].right;            q.predecessor = p.current;            q.successor = p.successor;            Push(q, S);        }         if (ws[p.current].left == 0) {            /* Set left thread and use stack to find next vertex to process */            ws[p.current].left = -p.predecessor;            if (Empty(S))                p.current = 0;  /* Use NULL value to signal end of process */            else                Pop(&p, S);         } else {    /* Move to the left subtree */            p.successor = p.current;            p.current = ws[p.current].left;        }    }} #include "general.h"#include "cursor.h"/* Thread: The function traverses the unthreaded binary tree in preorder. When each node is visited, its immediate predecessor and successor are found, and threads are inserted as appropriate.  These threads then allow the preorder traversal to continue.  */void Thread(int p){    int q;  /* used to find predecessors and successors */    while (p > 0) { /* p<0 is an error; p==0 terminates traversal   */        if (ws[p].left > 0) {   /* Find immediate predecessor of p    */            q = ws[p].left;            while (ws[q].right > 0)                q = ws[q].right; /* q gives immediate predecessor of p */            ws[q].right = -p;        }         if (ws[p].right > 0) {  /* Find immediate successor of p  */            q = ws[p].right;            while (ws[q].left > 0)                q = ws[q].left; /* q gives immediate successor of p */            ws[q].left = -p;        }         if (ws[p].left > 0)         /* Continue traversal by moving left    */            p = ws[p].left;        else if (ws[p].right > 0)   /* Continue traversal by moving right   */            p = ws[p].right;         else {  /* Find first unvisited node by taking threads, then a link */            while (ws[p].right < 0)                p = -ws[p].right;            p = ws[p].right;        }    }} #include "general.h"#include "cursor.h"/* LeftInsert: inserts q as left subtree of p moving subtrees as required */void LeftInsert(int q, int p){    if (p <=0 || q <= 0)        Error("Both must be real nodes");    ws[q].left = ws[p].left; /* Left subtree of q is that formerly of p */    ws[q].right = -p; /* Right thread shows that p immediately follows q */    ws[p].left = q;     /* Link q as the left child of p    */}