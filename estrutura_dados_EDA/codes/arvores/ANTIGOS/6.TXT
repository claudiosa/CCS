 typedef ... KeyType;typedef struct listentry {    ...    KeyType key;    ...} ListEntry; typedef float  KeyType;typedef int    KeyType;typedef char  *KeyType; Boolean EQ(KeyType key1, KeyType key2);Boolean LT(KeyType key1, KeyType key2); #define EQ(a,b) ((a) == (b))#define LT(a,b) ((a) < (b)) #define EQ(a,b) (!strcmp((a),(b)))#define LT(a,b) (strcmp((a),(b)) < 0) /* SequentialSearch: contiguous version. Pre:   The contiguous list list has been created.Post: If an entry in list has key equal to target, then the function    returns the location of the first such entry (success).    Otherwise the function returns -1 (failure). */int SequentialSearch(List list, KeyType target){    int location;    for (location = 0; location < list.count; location++)        if (EQ(list.entry[location].key, target))            return location;    return -1;} /* RandomInt: generate a pseudorandom integer. Pre:  The seed contains an arbitrary value.Post: Return a pseudorandom integer uniformly distributed over the    range from low to high, inclusive.Uses: rand. */int RandomInt(int low, int high){    if (low > high)        Error("RandomInt: low cannot be greater than high.");    return (high - low + 1) * (rand() / (double) INT_MAX) + low;} /* TestSearch: test a search routine. Pre:   The contiguous list list has been created.Post: If an entry in list has key equal to target, then the function    returns the location of one such entry (success).    Otherwise the function returns -1 (failure). */void TestSearch(List list, int (*Search)(List list, KeyType target),               int searchcount){    float elapsedtime;      /* elapsed time between START and END       */    int i, target;    float average;          /* comparisons / searchcount                    */    extern long compcounter;    compcounter = 0;            /* initialize the comparison counter        */    (void) Time(START);    if (list.count <= 0)        average = 0.;    else {                      /* Test with successful searches.           */        for (i = 0; i < searchcount; i++) {            target = 2 * RandomInt(1, list.count) - 1;      /* must be odd  */            if (Search(list, target) == -1)                printf("Error: %d not found\n", target);        }        average = (float) compcounter / searchcount;    }    elapsedtime = Time(END);    printf("Successful search: %f comparisons\n", average);    printf("Elapsed time to complete %d searches is %f seconds\n",                            searchcount, elapsedtime);    compcounter = 0;            /* initialize the comparison counter        */    (void) Time(START);    if (list.count <= 0)        average = 0.;    else {                      /* Test with unsuccessful searches.         */        for (i = 0; i < searchcount; i++) {            target = 2 * RandomInt(0, list.count);          /* must be even */            if (Search(list, target) != -1)                printf("Error: %d found improperly\n", target);        }        average = (float) compcounter / searchcount;    }    elapsedtime = Time(END);    printf("Unsuccessful search: %f comparisons\n", average);    printf("Elapsed time to complete %d searches is %f seconds\n",                            searchcount, elapsedtime);} #include    <time.h>/* Time: calculate run time between two points. Pre:   START sets the starting time. END terminates the run time.Post: At START return 0. At END return the time run since the function    was called with START. */float Time(int flag){    static clock_t start;    clock_t end;    if (flag == START) {        start = clock();        return 0.0;    } else {        end = clock();        return (end - start) / CLK_TCK;    }} typedef int Tag; typedef int Coat; /* Mixup: rearrange a list using random numbers. Pre:   list is a list that has been created.Post: The order of the entries in list has been permuted randomly.Uses: RandomInt, RetrieveList, ReplaceList, ListSize. */void Mixup(List *list){    ListEntry temp1, temp2;    int curposition, newposition;    for (curposition = 0; curposition < ListSize(*list) - 1; curposition++) {         newposition = RandomInt(curposition, ListSize(*list) - 1);        temp1 = RetrieveList(*list, curposition);        temp2 = RetrieveList(*list, newposition);        ReplaceList(list, temp2, curposition);        ReplaceList(list, temp1, newposition);    }} /* InsertOrder: insert an item into list maintaining correct order. Pre:   The contiguous list list has been created, is an ordered list,    and is not full.Post: The entry x has been inserted into list in a position such that    the keys in all entries of list remain in correct order. */void InsertOrder(List *list, ListEntry x){    int current;    ListEntry currententry;    for (current = 0; current < ListSize(*list); current++) {        currententry = RetrieveList(*list, current);        if (LE(x.key, currententry.key))            break;    }    InsertList(list, x, current);} /* RecBinary1: recursive forgetful version of binary search. Pre:   The contiguous list list has been created, and bottom and top are    indices of entries in the list.Post: If an entry in list between bottom and top, inclusive, has key equal    to target, then the function returns the location of the first such    entry (success).  Otherwise, the function returns -1 (failure). */int RecBinary1(List list, KeyType target, int bottom, int top){    int middle = -1;    if (bottom < top) {   /* The list has size greater than 1. */        middle = (top + bottom) / 2;        if (GT(target, list.entry[middle].key)) /* Reduce to the top half of the list.*/            middle = RecBinary1(list, target, middle+1, top);        else                    /* Reduce to the bottom half of the list.*/            middle = RecBinary1(list, target, bottom, middle);    } else if (bottom == top) {  /* The list has exactly 1 entry. */        if (EQ(target, list.entry[top].key))            middle = top;    }    return middle;} /* RecBinary1Search: front end for RecBinary1.  */int RecBinary1Search(List list, KeyType target){    return RecBinary1(list, target, 0, list.count-1);} /* Binary1Search: forgetful version of binary search. Pre:   The contiguous list list has been created.Post: If an entry in list has key equal to target, then the function    returns the location of the first such entry (success).    Otherwise the function returns -1 (failure). */int Binary1Search(List list, KeyType target){    int bottom, middle, top;    top = list.count - 1;   /* Initialize bounds to encompass entire list.  */    bottom = 0;    while (top > bottom) {      /* Check terminating condition. */        middle = (top + bottom) / 2;        if (GT(target, list.entry[middle].key))            bottom = middle + 1; /* Reduce to the top half of the list. */        else            top = middle; /* Reduce to the bottom half of the list. */    }    if (top == -1)        return -1;      /* Search for an empty list always fails. */    if (EQ(list.entry[top].key, target))        return top;    else        return -1;} /* RecBinary2: recursive recognizing equality version of binary search. Pre:   The contiguous list list has been created, and bottom and top are    indices of entries in the list.Post: If an entry in list between bottom and top, inclusive, has key equal    to target, then the function returns the location of one such    entry (success).  Otherwise, the function returns -1 (failure). */int RecBinary2(List list, KeyType target, int bottom, int top){    int middle = -1;     if (bottom <= top) {        middle = (top + bottom) / 2;        if (LT(target, list.entry[middle].key)) /* Reduce to the bottom half.*/            middle = RecBinary2(list, target, bottom, middle - 1);        else if (GT(target, list.entry[middle].key))/* Reduce to the top half.*/            middle = RecBinary2(list, target, middle + 1, top);    }    return middle;} /* RecBinary2Search: front end for RecBinary2.  */int RecBinary2Search(List list, KeyType target){    return RecBinary2(list, target, 0, list.count-1);} /* Binary2Search: recognizing equality version of binary search. Pre:   The contiguous list list has been created.Post: If an entry in list has key equal to target, then the function    returns the location of one such entry (success).    Otherwise the function returns -1 (failure). */2 int Binary2Search(List list, KeyType target){    int bottom, middle, top;     top = list.count - 1;   /* Initialize bounds to encompass entire list.  */    bottom = 0;    while (top >= bottom) {     /* Check terminating condition. */        middle = (top + bottom) / 2;        if (EQ(target, list.entry[middle].key))            return middle;        else if (LT(target, list.entry[middle].key))            top = middle - 1;       /* Reduce to the bottom half of the list. */        else            bottom = middle + 1;    /* Reduce to the top half of the list.  */    }    return -1;}