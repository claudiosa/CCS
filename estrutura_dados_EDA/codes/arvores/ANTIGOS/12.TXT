 (x + y) * exp(x - z) - 4.0a * b + c / d - c * (x + y)(p && q) || (x <= 7.0) /* Evaluate: evaluate an expression in prefix form.          */Value Evaluate(expression){    Value x, y;     Let token be the first symbol in the expression,    and remove token from the expression     if (token is a unary operator) {        x = Evaluate(expression);        return result of applying operator token to x;     } else if (token is a binary operator) {        x = Evaluate(expression);        y = Evaluate(expression);        return result of applying operator token to x and y;     } else {        return token;    }} /* EvaluatePrefix: evaluate an expression in prefix form. Pre:   expr is an expression in prefix form.Post: The expression has been evaluated (and perhaps consumed in the    process) giving the value returned. */Value EvaluatePrefix(Expression expr){    Token token;    Value x, y;    GetToken(token, expr);    switch(Kind(token)) {    case OPERAND:        return GetValue(token);    case UNARYOP:        x = EvaluatePrefix(expr);        return DoUnary(token, x);    case BINARYOP:        x = EvaluatePrefix(expr);        y = EvaluatePrefix(expr);        return DoBinary(token, x, y);    }} /* EvaluatePostfix: evaluate expression in postfix form. Pre:   expr is an expression in prefix form.Post: The expression has been evaluated (and perhaps consumed in the    process) giving the value returned. */Value EvaluatePostfix(Expression expr){    KindType    type;    Token       token;    Value       x, y;    Stack       stack;    CreateStack(&stack);    do {        GetToken(token, expr);        switch (type = Kind(token)) {        case OPERAND:            Push(GetValue(token), &stack);            break;        case UNARYOP:            Pop(&x, &stack);            Push(DoUnary(token, x), &stack);            break;        case BINARYOP:            Pop(&y, &stack);            Pop(&x, &stack);            Push(DoBinary(token, x, y), &stack);            break;        case ENDEXPR:            Pop(&x, &stack);            if (!StackEmpty(&stack))                Error("Incorrect expression");            break;        }    } while (type != ENDEXPR);    return x;} /* EvaluatePostfix: evaluate expression in postfix form. Pre:   expr is an expression in prefix form.Post: The expression has been evaluated (and perhaps consumed in the    process) giving the value returned. */Value EvaluatePostfix(Expression expr){    Value   result;    Token   token;     GetToken(token, expr);    if (Kind(token) == OPERAND)        result = RecEvaluate(token, expr);    else        Error("Postfix expression does not start with operand");    if (Kind(token) == ENDEXPR)        return result;    else        Error("Missing end expression");} /* RecEvaluate: recursively evaluate expression in postfix form. Pre:   The token token exists and it is guaranteed to be an operand    when RecEvaluated is invoked. expr is the remaining expression.Post: At conclusion, token is the first token beyond the expression    evaluated and will be a binary operator, unless the end of the    expression has been reached. */Value RecEvaluate(Token token, Expression expr){    KindType    type;    Value       x;    Value       result;     result = GetValue(token);    for (GetToken(token, expr); (type = Kind(token)) == OPERAND ||                                 type == UNARYOP; GetToken(token, expr)) {        if (type == UNARYOP)            result = DoUnary(token, result);        else {            x = RecEvaluate(token, expr);            if (Kind(token) == BINARYOP)                result = DoBinary(token, result, x);            else                Error("Expecting binary operator");        }    }    return result;} /* InfixtoPostfix: translate from infix to postfix form. Pre:     The input is a valid expression in infix form.Post:   The ouput is the input expression converted into a postfix expression. */ void InfixtoPostfix(Expression expr, Expression postfix){    Stack          stack;    StackEntry  topentry;    Token       token, tmp;    KindType    type;     CreateStack(&stack);    do {        GetToken(token, expr);        switch (type = Kind(token)) {         case OPERAND:            PutToken(token, postfix);          break;3         case LEFTPAREN:            Push(token, &stack);            break;         case RIGHTPAREN:            for (Pop(token, &stack); Kind(token) != LEFTPAREN; Pop(token, &stack))                PutToken(token, postfix);            break;         case UNARYOP:            /* Treat both kinds together. */         case BINARYOP:            do {                if (StackEmpty(&stack))                   break;                 else {                    StackTop(&topentry, &stack);                    if (Kind(topentry) == LEFTPAREN)                            break;                     else if (Priority(topentry) < Priority(token))                              break;                          else if (Priority(topentry) == Priority(token)                                  && Priority(token) == MAXPRIORITY)                              break;                     else {                        Pop(tmp, &stack);                        PutToken(tmp, postfix);                    }                }            } while (1);            Push(token, &stack);            break;         case ENDEXPR:            while(!StackEmpty(&stack)) {                Pop(token, &stack);                PutToken(token, postfix);            }            break;         }    } while (type != ENDEXPR);} Dictionary lexicon;/* Read infix expression, change it to postfix, and graph it.   */void main(void){    Expression      infix, postfix;    PlotParameter   plotdata;    char            cmd;    int             hashtable[MAXTOKEN];    Introduction();    Initialize(&infix, &postfix, hashtable, &plotdata);    while ((cmd = GetCommand()) != 'q')        DoCommand(cmd, &infix, &postfix, hashtable, &plotdata);} /* DoCommand: do one command. Pre:     cmd contains a valid command.Post:   Performed the given command cmd on the expression    infix or postfix. */void DoCommand(char cmd, Expression *infix, Expression *postfix,               int hashtable[], PlotParameter *plotdata){     if (EndExpression(postfix) && strchr("rhq", cmd) == NULL)         ErrorInform(WARNING, "Please read an expression before doing "                              "any other operation.");     else          switch(cmd) {          case 'g':               DrawGraph(postfix, plotdata);               break;          case 'h':               Help();               break;          case 'l':               ReadNewGraphLimits(plotdata);               break;          case 'n':               ReadNewParameters(plotdata);               break;          case 'p':               WriteParameters(plotdata);               break;          case 'q':               break;          case 'r':               while (!ReadExpression(infix, hashtable, plotdata));               InfixtoPostfix(infix, postfix);               break;          case 'w':               WriteExpression(infix);               WriteExpression(postfix);               break;        }} #define     MAXPRIORITY     6   /* largest operator priority        */#define        MAXSTRING      101  /* maximum tokens in expression         */#define        MAXTOKEN       101  /* maximum distinct tokens              */#define        MAXNAME             7    /* number of characters in identifier    */#define        MAXLINE             100  /* maximum line length for an Expression */ #define     FIRSTUNARY      3   /* index of first unary operator    */#define        LASTUNARY      11   /* index of last unary operator         */#define        FIRSTBINARY         12   /* index of first binary operator  */#define        LASTBINARY          17   /* index of last binary operator   */#define        FIRSTOPERAND   18   /* index of first operand               */#define        LASTOPERAND         20   /* index of last predefined operand     */ #define     HASHSIZE    101 typedef enum errorlevel { WARNING, BADVALUE, BADEXPR, FATAL } ErrorLevel;typedef enum kindtype { OPERAND, UNARYOP, BINARYOP,                        LEFTPAREN, RIGHTPAREN, ENDEXPR } KindType;typedef double Value;typedef struct dictionary {          struct {               char           name[MAXNAME];               KindType       kind;               union {int pri; Value val;} info;          } entry[MAXTOKEN];          int  count;} Dictionary; typedef List Expression;typedef struct plotparameter {    List        paramlist;    double      x, y;    double      xlow, xhigh;    double      ylow, yhigh;    double      increment;} PlotParameter; Dictionary lexicon; /* Initialize:                                      */void Initialize(Expression *infix, Expression *postfix, int hashtable[],                PlotParameter *plotdata){     SetupLexicon();      CreateList(infix);     CreateList(postfix);     CreateList(&plotdata->paramlist);      plotdata->x = plotdata->y = 0.;     plotdata->xlow  = -10.;     plotdata->xhigh = 10.;     plotdata->ylow  = -100.;     plotdata->yhigh = 100.;     plotdata->increment = .01;      CreateHashTable(hashtable);     FillHashTable(hashtable);} /* CreateHashTable: initialize a hash table. Pre:     None.Post:   The hash table hashtable has been created and    initialized to be empty. */void CreateHashTable(int hashtable[]){    int i;    for (i = 0; i < MAXTOKEN; i++)        hashtable[i] = -1;} /* FillHashTable: initialize a hash table. Pre:     hashtable has been created.Post:   All token codes from lexicon have been put into the table. */void FillHashTable(int hashtable[]){    int i;    for (i = 0; i <= LASTOPERAND; i++)        hashtable[Hash(hashtable, lexicon.entry[i].name)] = i;} /* Hash: find the place for a name in the hash table. Pre:     hashtable has been created and x is a token name.Post:   The function returns the location of x in hashtable if it is    present, and otherwise the empty location where x may be inserted. */ int Hash(int hashtable[], char *x){    int h = x[0] % HASHSIZE;     while (1) {          if (hashtable[h] == -1)             break;                   /* Entry is empty. */        else if (strcmp(lexicon.entry[hashtable[h]].name, x) == 0)            break;              /* name in the hash table   */        else {            if (x[1] == '\0')                h += 31;            else                h += x[1];            h %= HASHSIZE;      /* Find another position.   */        }    }    return abs(h);} /* ErrorInform: inform of an error and its severity. Pre:     level is a valid error level; msg is a message.Post:   The message msg has been written to the screen with a message        on the severity of the error. */void ErrorInform(ErrorLevel level, char *msg){    printf("%s\n", msg);    switch(level) {    case WARNING:          printf("...program continues.\n");break;     case BADVALUE:          printf("...bad value. Give new graphing limits.\n");break;      case BADEXPR:          printf("...bad expression. Enter new expression.\n");break;      case FATAL:        printf("...fatal error. Press Enter to terminate the program.\n");        fflush(stdin);        (void) getchar();        RestoreScreen();        exit(1);    }} /* GetToken: get a new token. Pre:     expr is a valid expression.Post:   The first entry of the expression expr has been deleted and        returned in token.Uses:   DeleteList. */ void GetToken(int *token, Expression *expr){    DeleteList(0, token, expr);} /* ReadExpression: read an expression in infix form. Pre:     hashtable has been created and initialized with the predefined        tokens found in the lexicon.Post:   The expression infix has been read in and the tokens not found        in the hashtable are added to the table.Uses:   CreateList, */Boolean ReadExpression(Expression *infix, int hashtable[],                       PlotParameter *plotdata){    Boolean valid;    int     h;      /* Holds the hashtable value. */    int     len, pos;    char    instring[MAXSTRING];    CreateList(infix);    fflush(stdin);    printf("Please type (on one line) the expression to graph.\n");    printf("Put blanks on each side of every token.\n");    fgets(instring, MAXSTRING, stdin);    len = strlen(instring);    instring[len-1] = ' ';      /* sentinel for searches            */    for (pos = 0; pos < len; ) {        if (instring[pos] == ' ') {            pos++;            continue;        } else if (isalpha(instring[pos]))            pos = ExtractWord(instring, pos, &h, hashtable, plotdata);        else if (isdigit(instring[pos]) || instring[pos] == '.')            pos = ExtractNumber(instring, pos, &h);          else pos = ExtractSymbol(instring, pos, &h, hashtable, infix);        if (h == -1) {            valid = FALSE;            break;              /* invalid token                    */        } else {            valid = TRUE;            PutToken(h, infix); /* h has the location in lexicon. */        }    }    if (valid)        valid = ValidInfix(infix);    if (!valid)        ErrorInform(BADEXPR, "Expression invalid or too long.");    PutToken(0, infix);         /* Mark the end of the expression.  */    PutToken(0, &plotdata->paramlist);    return valid;} /* Leading: TRUE if it is a leading position. Pre:     infix has been initialized.Post:   Returns TRUE if the token before position current in        infix makes this a leading position, FALSE otherwise.Uses:   Kind, RetrieveList. */ Boolean Leading(Expression *infix, int current){    int      tok;    KindType kind;    Boolean  valid = FALSE;     if (current == 0)        valid = TRUE;     else {        RetrieveList(current - 1, &tok, infix);        kind = Kind(tok);        if (kind == LEFTPAREN || kind == UNARYOP || kind == BINARYOP)            valid = TRUE;    }    return valid;} /* ValidInfix: verify that an infix expression is valid. Pre:     infix has been initialized.Post:   Returns TRUE if the expression is in valid infix form,        FALSE otherwise.Uses:   Kind, Leading, ListSize, RetrieveList. */ Boolean ValidInfix(Expression *infix){    int         i, tok;    KindType    kind;    Boolean     valid;    int         parencount = 0;     for (i = 0; i < ListSize(infix); i++) {        RetrieveList(i, &tok, infix);        kind = Kind(tok);        if (Leading(infix, i))            if (kind == OPERAND || kind == UNARYOP || kind == LEFTPAREN)                valid = TRUE;            else                valid = FALSE;        else            if (kind == BINARYOP || kind == RIGHTPAREN)                valid = TRUE;            else                valid = FALSE;        if (valid) {            if (kind == LEFTPAREN)                parencount++;            else if (kind == RIGHTPAREN)                if (--parencount < 0)                    valid = FALSE;        }        if (!valid)            break;    }    return valid;} /* GetWord: get word from instring starting at pos. Pre:     instring has been initialized; pos is the position within        instring starting the word to be extracted.Post:   The word has been extracted from instring and put in word.        The function returns the location after the word. */int GetWord(char *instring, int pos, char *word){    int i;    char *pw = word;    for (i = pos; isalpha(instring[i]) || isdigit(instring[i]); i++)        *word++ = tolower(instring[i]);    *word = '\0';    if (i - pos > MAXNAME) {        printf("Word %s was truncated.\n", pw);        pw[MAXNAME] = '\0';    }    return i;           /* Return next position in instring.    */} /* ExtractWord: extract a word from instring. Pre:     instring has been initialized; pos is the position within        instring starting the word to be processed.Post:   The word has been read from instring and pos points to next        location (after the word). The word is inserted into the lexicon        with hashtable holding the token's location in the lexicon.Uses:   GetWord, ErrorInform, Hash. */int ExtractWord(char *instring, int pos, int *h, int hashtable[],                PlotParameter *plotdata){    char word[MAXTOKEN];    pos = GetWord(instring, pos, word);    if ((*h = hashtable[Hash(hashtable, word)]) == -1)        if (++lexicon.count >= MAXTOKEN) {            ErrorInform(BADEXPR, "Too many distinct variables and constants.");        } else {            *h = hashtable[Hash(hashtable, word)] = lexicon.count;            strcpy(lexicon.entry[lexicon.count].name, word);            lexicon.entry[lexicon.count].kind = OPERAND;            lexicon.entry[lexicon.count].info.val = 0.;            PutToken(*h, &plotdata->paramlist);        }    return pos;} /* ExtractNumber: extract a number from instring. Pre:     instring has been initialized; pos is the position within        instring where the number to be processed starts.Post:   The number has been extracted from instring and put in the lexicon.        The function returns the location after the number. */int ExtractNumber(char *instring, int pos, int *h){    if (++lexicon.count >= MAXTOKEN) {        *h = -1;        ErrorInform(BADEXPR, "Too many distinct variables and constants.");    } else {        *h = lexicon.count;        lexicon.entry[lexicon.count].kind = OPERAND;        strcpy(lexicon.entry[lexicon.count].name, "const");        lexicon.entry[lexicon.count].info.val = atof(&instring[pos]);        for ( ; isdigit(instring[pos]) || instring[pos] == '.'; pos++)            ;    }    return pos;} /* ExtractSymbol: extract symbol from instring. Pre:     instring has been initialized; pos is the position within        instring starting the symbol to be extracted.Post:   The symbol has been read from instring and pos points to next        location (after the symbol). The symbol is inserted into the lexicon        with hashtable holding the token's location in the lexicon. */1 int ExtractSymbol(char *instring, int pos, int *h, int hashtable[], Expression *infix){    int     i;    char    word[MAXTOKEN];    for (i = 0; instring[pos] != ' '; i++, pos++)        word[i] = instring[pos];    word[i] = '\0';    if ((*h = hashtable[Hash(hashtable, word)]) == -1) {        ErrorInform(BADEXPR, "Unrecognized symbol in expression");    } else {        if (Leading(infix, ListSize(infix)))            if (strcmp(word, "+") == 0)                ;                           /* Do nothing with unary plus.  */            else if (strcmp(word, "-") == 0)                *h = hashtable[Hash(hashtable, "@")];   /* special name for unary minus */    }    return pos;} /* GetValue: get a value from lexicon[] for token. Pre:   token is a valid token code for an operand in the lexicon.Post: The value of the operand is returned. */Value GetValue(int token){    if (Kind(token) != OPERAND)        ErrorInform(FATAL, "Attempt to get value for nonoperand");    return lexicon.entry[token].info.val;} /* DoBinary: apply binary operator on x and y; return the result. Pre:   x and y are valid operand values; token is a token code of a    binary operator in the lexicon.Post: The operator pointed to by token in the lexicon has been performed. */Value DoBinary(int token, Value x, Value y){     switch(token) {     case 12:                      /* binary plus                */          return x + y;     case 13:                      /* binary minus                    */          return x - y;     case 14:                      /* times                      */          return x * y;     case 15:                      /* divide                     */          if (y != (Value) 0)              return x / y;          else              ErrorInform(FATAL, "Division by zero is not allowed.");     case 16:                      /* modulus operator           */          if (y != (Value) 0)              return fmod(x, y);          else              ErrorInform(FATAL, "Division by zero is not allowed.");     case 17:                      /* x to the power y            */          if (x < 0. && y != (int) y)              ErrorInform(FATAL, "pow() cannot handle x^y for x < 0 and fractional y.");          return pow(x, y);     default:          printf("%d ", token);          ErrorInform(FATAL, "is an invalid Binary token.");break;     }} /* InitializeScreen: initialize screen to graphics mode. Pre:     None.Post:   The screen has been initialized to graphics mode and        maximum size of the screen has been stored in the parameters.Uses:   Uses Borland's graphics.h and graphic routines. */void InitializeScreen(int *maxx, int *maxy){    int errorcode, graphicdriver = DETECT, graphicmode;    initgraph(&graphicdriver, &graphicmode, "");    if ((errorcode = graphresult()) != grOk) {        printf("Error is %d: %s\n", errorcode, grapherrormsg(errorcode));        ErrorInform(FATAL, "Graphics error in InitializeScreen().");    }    *maxx = getmaxx();    *maxy = getmaxy();} /* RestoreScreen: restore screen to text mode. Pre:     The output is in graphics mode.Post:   The screen has been restored to text mode.Uses:   Uses Borland's graphics.h and graphic routine. */void RestoreScreen(void){    restorecrtmode();} /* GraphPoint: graph a point it is within screen range. Pre:     x and y are valid floating point numbers; maxx and maxy         were calculated by the graphic routines.Post:   If the point x,y is within the range specified by the user        then it is printed relative to maxx and maxy.Uses:   Uses Borland's graphics.h and graphic routine. */void GraphPoint(Value x, Value y, int maxx, int maxy, PlotParameter *plotdata){    int ix, iy;    if (x >= plotdata->xlow && x <= plotdata->xhigh   &&        y >= plotdata->ylow && y <= plotdata->yhigh) {        ix = (x - plotdata->xlow) * maxx / (plotdata->xhigh - plotdata->xlow);        iy = maxy -             (y - plotdata->ylow) * maxy / (plotdata->yhigh - plotdata->ylow);        putpixel(ix, iy, 3);    }} /* DrawGraph: use postfix expression to draw the graph. Pre:     postfix has been initialized. The plotting parameters        in plotdata have been initialized.Post:   The expression postfix has been graphed.Uses:   InitializeScreen, EvaluatePostfix, GraphPoint, RestoreScreen. */void DrawGraph(Expression *postfix, PlotParameter *plotdata){    Value   x, y;    int     maxx, maxy;    InitializeScreen(&maxx, &maxy);    for (x = plotdata->xlow; x <= plotdata->xhigh; x += plotdata->increment) {        lexicon.entry[FIRSTOPERAND].info.val = x;        y = EvaluatePostfix(postfix);        GraphPoint(x, y, maxx, maxy, plotdata);    }    fflush(stdin);                  /* Discard any available input.     */    (void) getchar();               /* Wait for the user to press Enter.*/    RestoreScreen();    printf("Please enter the next command or h for Help.\n");}   switch(token)           case 12:        return CommonLog(x);