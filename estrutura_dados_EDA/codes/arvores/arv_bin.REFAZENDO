 // Definicao de arv_bin011.h#include "arv_bin.h" /* CreateTree:  create a tree.Pre:   None.Post: An empty binary search tree has been created to which root points. */void CreateTree(BinTreeNode **root){	 *root = NULL;}/* TreeEmpty:  TRUE if the tree is emtpy.Pre:   The tree to which root points has been created.Post: The function returns the value TRUE or FALSE according as thetree is empty or not. */bool TreeEmtpy(BinTreeNode *root){    if(root == NULL)	 return true;     else     return false;   } /* Preorder: visit each node of the tree in preorder.Pre:  The binary tree to which root points has been created.Post: The function Visit has been performed on every entry in the binarytree in preorder sequence. */void printInorder(BinTreeNode * node){     if (node == NULL)          return;     /* first recur on left child */     printInorder(node->left);     /* then print the data of node */     printf("\n: %d :", node->dados . UM_NUM);       printf("\t NOME: %s ", node->dados . UM_NOME);       /* now recur on right child */     printInorder(node->right);} /* Inorder: visit each node of the tree in inorder.Pre:  The binary tree to which root points has been created.Post: The function Visit has been performed on every entry in the binarytree in inorder sequence. */void Inorder(BinTreeNode *root, void (*Visit)(TreeEntry x)){  if (root) {	 Inorder(root->left, Visit);	 Visit(root->entry);	 Inorder(root->right, Visit);  }} /* Postorder: visit each node of the tree in postorder.Pre:  The binary tree to which root points has been created.Post: The function Visit has been performed on every entry in the binarytree in postorder sequence. */void Postorder(BinTreeNode *root, void (*Visit)(TreeEntry x)){  if (root) {	 Postorder(root->left, Visit);	 Postorder(root->right, Visit);	 Visit(root->entry);  }}void A(BinTreeNode *root,		 void (*Visit)(TreeEntry x)){  if (root) {	 Visit(root->entry);	 B(root->left, Visit);	 B(root->right, Visit);  }}void B(BinTreeNode *root,		 void (*Visit)(TreeEntry x)){  if (root) {	 A(root->left, Visit);	 Visit(root->entry);	 A(root->right, Visit)  }}Tree *TreeSearch(Tree *root, KeyType target); /* TreeSearch: search for target starting at node root.Pre:   The tree to which root points has been created.Post: The function returns a pointer to a tree node that matches targetor NULL if the target is not in the tree. */BinTreeNode *TreeSearch(BinTreeNode *root, KeyType target){	 if (root)		  if (LT(target, root->entry.key))				root = TreeSearch(root->left, target);		  else if (GT(target, root->entry.key))				root = TreeSearch(root->right, target);	 return root;}while (position && NE(target, position->entry.key))  if (LT(target, position->entry.key))		position = position->left;  else		position = position->right;  /* InsertTree: insert a new node in the tree.Pre:   The binary search tree to which root points has been created.	 The parameter newnode points to a node that has been created and	 contains a key in its entry.Post: The node newnode has been inserted into the tree in such a way	 that the properties of a binary search tree are preserved. */BinTreeNode *InsertTree_BIN(BinTreeNode *root,                         TreeEntry *newnode ){	 if (root == NULL) {		  root -> dados = newnode; // Tipo TreeEntry		  root->left = root->right = NULL;	 } else if ((newnode -> UM_NUM) =< (root -> dados . UM_NUM))		  root->left = InsertTree_BIN(root->left, newnode);	 else		  root->right = InsertTree_BIN(root->right, newnode);	 return root;} /* DeleteNodeTree: delete a new node from the tree. Pre:   The parameter p is the address of an actual link (not a copy)    in a binary search tree, and p is not NULL.Post: The node p has been deleted from the binary search tree and the    resulting smaller tree has the properties required of a binary search    tree. */void DeleteNodeTree(BinTreeNode **p){    BinTreeNode *r = *p, *q;           /* used to find place for left subtree  */    if (r == NULL)        Error("Attempt to delete a nonexistent node from binary search tree");    else if (r->right == NULL) {        *p = r->left;           /* Reattach left subtree.   */        free(r);                /* Release node space.      */     } else if (r->left == NULL) {        *p = r->right;          /* Reattach right subtree.  */		  free(r);     } else {                    /* Neither subtree is empty.    */        for (q = r->right; q->left; q = q->left)            ;           /* leftmost node of right subtree*/        q->left = r->left;      /* Reattach left subtree.   */        *p = r->right;          /* Reattach right subtree.  */		  free(r);    }} /* DeleteKeyTree: delete a new node from the tree. Pre:   root is the root of a binary search tree with a node containing	 key equal to target.Post: The node with key equal to target has been deleted and returned.    The resulting tree has the properties required of a binary search    tree.Uses: DeleteKeyTree recursively, DeleteNodeTree. */void DeleteKeyTree(BinTreeNode **root, BinTreeNode **keyposition, KeyType target){    if (*root == NULL)        Error("Attempt to delete a key not present in the binary search tree");     else if (EQ(target, (*root)->entry.key)) {        *keyposition = *root;        DeleteNodeTree(root);    } else if (LT(target, (*root)->entry.key))        DeleteKeyTree(root, keyposition, target);    else        DeleteKeyTree(root, keyposition, target);} /* BuildTree: build nodes from GetNode into a binary tree. Pre:   The binary search tree pointed to by root has been created.Post: The tree has been reorganized into a balanced tree.Uses: GetNode, Insert, ConnectSubtrees, FindRoot. */BinTreeNode *BuildTree(void){    BinTreeNode *newnode;    int count = 0;                  /* number of nodes so far               */    int level;                      /* number of steps above leaves         */    BinTreeNode *lastnode[MAXHEIGHT];  /* pointers to last node on each level  */	 for (level = 0; level < MAXHEIGHT; level++)        lastnode[level] = NULL;     while ((newnode = GetNode()) != NULL)        Insert(newnode, ++count, lastnode);     newnode = FindRoot(lastnode);	 ConnectSubtrees(lastnode);    return newnode;                 /* Return root of the tree. */} /* Insert: insert newnode as the rightmost node of a partial tree. Pre:   newnode is a valid pointer of an entry to be inserted into the	 binary search tree.Post: newnode has been inserted as rightmost node of a partial binary    search tree.Uses: Power2. */void Insert(BinTreeNode *newnode, int count, BinTreeNode *lastnode[]){	 int level = Power2(count) + 1;    newnode->right = NULL;    newnode->left = lastnode[level-1];    lastnode[level] = newnode;    if (lastnode[level+1] && !lastnode[level+1]->right)        lastnode[level+1]->right = newnode;} #define     ODD(x)  ((x)/2*2 != (x))/* Power2: find the highest power of 2 that divides count. Pre:   x is a valid integer.Post: The function finds the highest power of 2 that divides x;    requires x != 0. */int Power2(int x){    int level;    for (level = 0; !ODD(x); level++)        x /= 2;    return level;} /* FindRoot: find root of tree (highest entry in lastnode). Pre:   The array lastnode contains pointers to the occupied levels of    the binary search tree.Post: Return a pointer to the root of the newly created binary search tree. */ BinTreeNode *FindRoot(BinTreeNode *lastnode[]){    int level;	 for (level = MAXHEIGHT-1; level > 0 && !lastnode[level]; level--)        ;     if (level <= 0)        return NULL;    else		  return lastnode[level];} /* ConnectSubtrees: connect free subtrees from lastnode[]. Pre:   The nearly completed binary search tree has been initialized. The	 array last-node has been initialized and contains the information    needed to complete the binary search tree.Post: The binary search tree has been completed. */ void ConnectSubtrees(BinTreeNode *lastnode[]){    BinTreeNode    *p;    int         level, templevel;    for (level = MAXHEIGHT-1; level > 2 && !lastnode[level]; level--)        ;                           /* Find the highest node: root.     */2 	 while (level > 2) {             /* Levels 1 and 2 are already OK.   */        if (lastnode[level]->right)            level--;                /* Search for highest dangling node.*/        else {                      /* Right subtree is undefined.      */            p = lastnode[level]->left;            templevel = level - 1;            do {            /* Find highest entry not in left subtree.  */					 p = p->right;            } while (p && p == lastnode[--templevel]);            lastnode[level]->right = lastnode[templevel];            level = templevel;        }    }} /* InsertAVL: insert newnode in AVL tree starting at the root. Pre:  The root of the AVL tree is pointed by root, and newnode is a new    node to be inserted into the tree.Post: newnode has been inserted into the AVL tree with taller equal to    TRUE if the height of the tree has increased, FALSE otherwise.Uses: InsertAVL recursively, RightBalance, LeftBalance. */BinTreeNode *InsertAVL(BinTreeNode *root, BinTreeNode *newnode, bool *taller){    if (!root) {        root = newnode;        root->left = root->right = NULL;		  root->bf = EH;        *taller = TRUE;     } else if (EQ(newnode->entry.key, root->entry.key)) {        Error("Duplicate key is not allowed in AVL tree.");     } else if (LT(newnode->entry.key, root->entry.key)) {		  root->left = InsertAVL(root->left, newnode, taller);        if (*taller)                        /* Left subtree is taller.  */            switch(root->bf) {             case LH:                        /* Node was left high.      */                root = LeftBalance(root, taller); break; 				case EH:                root->bf = LH;  break;      /* Node is now left high.   */             case RH:                root->bf = EH;          /* Node now has balanced height.*/                *taller = FALSE; break;            }    } else {        root->right = InsertAVL(root->right, newnode, taller);        if (*taller)                        /* Right subtree is taller. */            switch(root->bf) {             case LH:					 root->bf = EH;          /* Node now has balanced height.*/                *taller = FALSE; break;             case EH:                root->bf = RH; break;   /* Node is right high.      */             case RH:                        /* Node was right high.     */					 root = RightBalance(root, taller); break;            }    }    return root;} /* RotateLeft: rotate a binary tree to the left.Pre:  p is the root of the nonempty AVL subtree being rotated, and its    right child is nonempty.Post: The right child of p becomes the new p. The old p becomes the    left child of the new p. */ BinTreeNode *RotateLeft(BinTreeNode *p){    BinTreeNode *rightchild = p;     if (!p)		  Error("It is impossible to rotate an empty tree in RotateLeft.");     else if (!p->right)        Error("It is impossible to make an empty subtree the root in RotateLeft.");     else {        rightchild = p->right;		  p->right = rightchild->left;        rightchild->left = p;    }    return rightchild;} /* RightBalance: right balance a binary tree.Pre:  A node of an AVL tree has become doubly unbalanced to the right.Post: The AVL properties have been restored.Uses: RotateRight, RotateLeft. */ BinTreeNode *RightBalance(BinTreeNode *root, bool *taller){    BinTreeNode *rs = root->right;     /* right subtree of root*/    BinTreeNode *ls;                   /* left subtree  of right subtree */     switch(rs->bf) {	 case RH:        root->bf = rs->bf = EH;        root = RotateLeft(root);    /* single rotation left */        *taller = FALSE;        break;     case EH:		  Error("Tree is already balanced");        break;     case LH:                        /* double rotation left */        ls = rs->left;        switch(ls->bf) {        case RH:				root->bf = LH;            rs->bf   = EH;            break;         case EH:            root->bf = rs->bf = EH;            break;        case LH:            root->bf = EH;            rs->bf   = RH;            break;        }        ls->bf = EH;		  root->right = RotateRight(rs);        root = RotateLeft(root);        *taller = FALSE;    }    return root;} /* LinkLeft: link to the left side. Pre:  target > current->entry.key.Post: Moves current and its left subtree into the tree of keys known to    be less than target; therefore reassigns lastsmall to old    current and moves current to its right child. */BinTreeNode *LinkLeft(BinTreeNode *current, BinTreeNode **lastsmall){    (*lastsmall)->right = current;    *lastsmall = current;    return current->right;} /* RotateRight: rotate a binary tree to the right. Pre:  current points to a node of a binary search tree with sentinel.Post: Rotates rightward the edge joining current and its left child. */BinTreeNode *RotateRight(BinTreeNode *current){	 BinTreeNode *leftchild = current->left;    current->left = leftchild->right;    leftchild->right = current;    return leftchild;} /* TreeSplay: find or insert target in a splay tree. Pre:  The splay tree to which root points has been created.Post: The tree has been splayed around the key target. If a node with key    target was in the tree, it has now become the root. If not, then a    new node has been created as the root, with key target.Uses: LinkLeft, LinkRight, RotateLeft, RotateRight,	 MakeNode, SetNode. */ BinTreeNode *TreeSplay(BinTreeNode *root, KeyType target){ 	 BinTreeNode    *current;   /* the current position in the tree             */     BinTreeNode    *child;     /* one of the children of current             */     BinTreeNode    *lastsmall; /* largest key known to be less than the target */     BinTreeNode    *firstlarge;/* smallest key known to be greater than the target*/    extern BinTreeNode *sentinel;     sentinel->entry.key = target; /* Establish sentinel for searching.      */     lastsmall = firstlarge = sentinel;2    for (current = root; NE(current->entry.key, target); )        if (LT(current->entry.key, target)) {            child = current->right;            if (EQ(target, child->entry.key)) {                current = LinkLeft(current, &lastsmall);            } else if (GT(target, child->entry.key)) {					 current = RotateLeft(current);                current = LinkLeft(current, &lastsmall);            } else {                current = LinkLeft(current, &lastsmall);                current = LinkRight(current, &firstlarge);            }         } else {            child = current->left;            if (EQ(target, child->entry.key)) {                current = LinkRight(current, &firstlarge);            } else if (LT(target, child->entry.key)) {                current = RotateRight(current);					 current = LinkRight(current, &firstlarge);            } else {                current = LinkRight(current, &firstlarge);                current = LinkLeft(current, &lastsmall);            }        }     if (current == sentinel) {        printf("Target has been inserted as root of the tree.");        root = current = MakeNode(target, sentinel);    } else {        printf("Target was found; it is now the root of the tree.");    }    lastsmall->right = current->left;   /* Move remaining central nodes.    */     firstlarge->left = current->right;     current->right = sentinel->left;    /* root of larger-key subtree       */ 	 current->left  = sentinel->right;   /* root of smaller-key subtree      */     root = current;                     /* Define the new root.             */     SetNode(sentinel, 0, sentinel); /* Re-establish standard use of sentinel.*/ 	 return root;}