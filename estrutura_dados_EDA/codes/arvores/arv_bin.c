 // Definicao de arv_bin011.h#include "arv_bin.h" /* CreateTree:  create a tree.Pre:   None.Post: An empty binary search tree has been created to which root points. */void CreateTree(BinTreeNode **root){	 *root = NULL;}// ALOCA UM NO DA ARVOREBinTreeNode * cria_no_BIN(void){  BinTreeNode *X;  X =  (BinTreeNode *) malloc (sizeof (BinTreeNode));  if ( ! X )   {    printf("\n problema de alocacao... de memoria");    getchar();    }      else    {       X -> left = NULL;       X -> right = NULL;    }      return (X);}/* TreeEmpty:  TRUE if the tree is emtpy.Pre:   The tree to which root points has been created.Post: The function returns the value TRUE or FALSE according as thetree is empty or not. */bool TreeEmtpy(BinTreeNode *root){    if(root == NULL)	 return true;     else     return false;   } /* Preorder: visit each node of the tree in preorder.Pre:  The binary tree to which root points has been created.Post: The function Visit has been performed on every entry in the binarytree in preorder sequence. */ /* InsertTree: insert a new node in the tree.Pre:   The binary search tree to which root points has been created.	 The parameter newnode points to a node that has been created and	 contains a key in its entry.Post: The node newnode has been inserted into the tree in such a way	 that the properties of a binary search tree are preserved. */// root vira como COPIA// podes fazer por REFERENCIA **   BinTreeNode * InsertTree_BIN(BinTreeNode *root, TreeEntry INFO ){  if (root == NULL)   {   // cria um no ao chegar numa folha na arvore ...    BinTreeNode * X = cria_no_BIN(); 	 X -> dados . UMA_CHAVE = INFO . UMA_CHAVE;    strcpy(X -> dados.UM_NOME , INFO . UM_NOME);   // Tipo TreeEntry   //printf("\n %d : %x : %s", X -> dados.UMA_CHAVE , X , X -> dados.UM_NOME );	 X -> left = X -> right = NULL;    root = X; // CUIDADO ... NAO ESQUECER    // TINHA ESQUECIDO DE ATUALIZAR ... 2 horas estudo    // pois eh o ultimo inserido	 }    else      {      if ((INFO.UMA_CHAVE) == (root -> dados.UMA_CHAVE))        {          printf("\n CHAVE DUPLICADA !!!");           printf("\n VIOLA DEFINICAO DE ABB !!!\n");           printf("\n TINHA: %d | ENTRY: %d\n",root -> dados.UMA_CHAVE, INFO.UMA_CHAVE );           getchar();          //system("exit"); // ver isto depois         }       // SEGUE A BUSCA ATE UMA FOLHA         else if ((INFO.UMA_CHAVE) < (root -> dados.UMA_CHAVE))       root->left = InsertTree_BIN(root->left, INFO); // MENOR: ESQUERDA       else       root->right = InsertTree_BIN(root->right, INFO);// MAIOR: DIREITA   }    //printf("\n Retorno da NOVA raiz : %x ", X );   return root; // falhando em chave duplicada .... todo fluxo passa aqui}int sizeof_Tree_BIN( BinTreeNode *root){  if (root == NULL)   return 0;  else  return( sizeof_Tree_BIN(root ->left) + 1 +          sizeof_Tree_BIN(root ->right)        ); } /* TreeSearch: search for target starting at node root.Pre:   The tree to which root points has been created.Post: The function returns a pointer to a tree node that matches targetor NULL if the target is not in the tree. */BinTreeNode *TreeSearch(BinTreeNode *NOH_RAIZ, int ALVO){   if ( NOH_RAIZ != NULL )   {     // RAMO ESQUERDO     if ( ALVO < (NOH_RAIZ -> dados.UMA_CHAVE) )       // alvo menor que o valor corrente da raiz      NOH_RAIZ = TreeSearch(NOH_RAIZ->left, ALVO);          if ( ALVO > (NOH_RAIZ-> dados.UMA_CHAVE) )        NOH_RAIZ = TreeSearch(NOH_RAIZ->right, ALVO);          if ( ALVO == (NOH_RAIZ-> dados.UMA_CHAVE) ) // achou!!!        return NOH_RAIZ;      else       {      printf("\n ALGUM Problema em TreeSearch : ALVO era: %d", ALVO);       getchar();     // system("exit"); // ver isto depois      }          } // FIM DO IF da BUSCA      // se nao foi chamada para o lado esquerdo ou direito   // NEM eh o valor ALVO procurado ou raiz NULL ... ENTAO valor   // nao estah na arvore      return NOH_RAIZ;}/*Versao Recursivowhile (position && NE(target, position->entry.key))  if (LT(target, position->entry.key))    position = position->left;  else    position = position->right; *///*************************************// NAO ESTA BOM ....//bool deltree(BinTreeNode * tree) void deltree(BinTreeNode * tree) {if (tree == NULL)    return; // true; else  {   deltree(tree->left);   deltree(tree->right);   // EXCLUIR O NOH CORRENTE APOS EXCLUIR AS SUB-ARVORES   free(tree); // libera folha  }  }//*************************************// MELHORAR ..... NAO OKvoid deltree_TRUE(BinTreeNode ** tree) {if ((*tree) == NULL)    return; // true; else  {   deltree((*tree)->left);   deltree((*tree)->right);   // EXCLUIR O NOH CORRENTE APOS EXCLUIR AS SUB-ARVORES   BinTreeNode *temp = (*tree);      free( (*tree) ); // libera folha   temp = NULL;  }  }void printInorder(BinTreeNode * node){  //printf("+ ");  if (node == NULL)      return;     /* first recur on left child */     printInorder(node->left);     /* then print the data of node */     printf("\n: %d :", node->dados . UMA_CHAVE);       printf("\t NOME: %s ", node->dados . UM_NOME);     printf("\t END NOH: %x ",  node );       /* now recur on right child */     printInorder(node->right);}void printPreorder(BinTreeNode * node){  //printf("+ ");  if (node == NULL)      return;      /* first print the data of node */     printf("\n: %d :", node->dados . UMA_CHAVE);       printf("\t NOME: %s ", node->dados . UM_NOME);       /*  then recur on left child */     printPreorder(node->left);     /* now recur on right child */     printPreorder(node->right);}void printPosorder(BinTreeNode * node){  //printf("+ ");  if (node == NULL)      return;     /* first recur on left child */     printPreorder(node->left);     /* then recur on right child */     printPreorder(node->right);     /* now print the data of node */     printf("\n: %d :", node->dados . UMA_CHAVE);       printf("\t NOME: %s ", node->dados . UM_NOME);  }/*REFAZER PONTEIRO DE PONTEIRO .... COOLnode* search(node ** tree, int val) {47 if(!(*tree)) {48   return NULL;49  }50 if(val == (*tree)->data) {51   return *tree;52  } else if(val < (*tree)->data) {53    search(&((*tree)->left), val);54  } else if(val > (*tree)->data){55    search(&((*tree)->right), val);56  }57 }*/