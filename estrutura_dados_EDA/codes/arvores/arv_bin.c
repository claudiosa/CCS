 // Definicao de arv_bin011.h#include "arv_bin.h" /* CreateTree:  create a tree.Pre:   None.Post: An empty binary search tree has been created to which root points. */void CreateTree(BinTreeNode **root){	 *root = NULL;}// ALOCA UM NO DA ARVOREBinTreeNode * cria_no_BIN(void){  BinTreeNode *X;  X =  (BinTreeNode *) malloc (sizeof (BinTreeNode));  if ( ! X )   {    printf("\n problema de alocacao... de memoria");    getchar();    }      else    {       X -> left = NULL;       X -> right = NULL;    }      return (X);}/* TreeEmpty:  TRUE if the tree is emtpy.Pre:   The tree to which root points has been created.Post: The function returns the value TRUE or FALSE according as thetree is empty or not. */bool TreeEmtpy(BinTreeNode *root){    if(root == NULL)	 return true;     else     return false;   } /* Preorder: visit each node of the tree in preorder.Pre:  The binary tree to which root points has been created.Post: The function Visit has been performed on every entry in the binarytree in preorder sequence. */ /* InsertTree: insert a new node in the tree.Pre:   The binary search tree to which root points has been created.	 The parameter newnode points to a node that has been created and	 contains a key in its entry.Post: The node newnode has been inserted into the tree in such a way	 that the properties of a binary search tree are preserved. */// root vira por COPIA// podes fazer por REFERENCIA **   BinTreeNode * InsertTree_BIN(BinTreeNode *root,                         TreeEntry INFO ){  if (root == NULL) {  // cria o no ao chegar numa folha     BinTreeNode * X = cria_no_BIN(); 		X -> dados . UMA_CHAVE = INFO . UMA_CHAVE;     strcpy(X -> dados.UM_NOME , INFO . UM_NOME);   // Tipo TreeEntry    //printf("\n %d : %x : %s", X -> dados.UMA_CHAVE , X , X -> dados.UM_NOME );		X -> left = X -> right = NULL;    root = X;     // TINHA ESQUECIDO DE ATUALIZAR ... 2 horas estudo    // pois eh o ultimo inserido	 }      else if ((INFO . UMA_CHAVE) <= (root -> dados . UMA_CHAVE))		  root->left = InsertTree_BIN(root->left, INFO);  	 else		  root->right = InsertTree_BIN(root->right, INFO);	   //printf("\n Retorno NOVA raiz : %x ", X );   return root;}//*************************************bool deltree(BinTreeNode * tree) {if (tree)   {   deltree(tree->left);   deltree(tree->right);   free(tree); // libera folha  }  //if (tree == NULL)   return true; // sempre TRUE ... hum  //else // return false; // sempre TRUE ... hum   }//*************************************void printInorder(BinTreeNode * node){  //printf("+ ");  if (node == NULL)      return;     /* first recur on left child */     printInorder(node->left);     /* then print the data of node */     printf("\n: %d :", node->dados . UMA_CHAVE);       printf("\t NOME: %s ", node->dados . UM_NOME);       /* now recur on right child */     printInorder(node->right);}void printPreorder(BinTreeNode * node){  //printf("+ ");  if (node == NULL)      return;      /* first print the data of node */     printf("\n: %d :", node->dados . UMA_CHAVE);       printf("\t NOME: %s ", node->dados . UM_NOME);       /*  then recur on left child */     printPreorder(node->left);     /* now recur on right child */     printPreorder(node->right);}