 /* ReverseRead: read one line of input and write it backward. Pre:    The user supplies one line of input.Post:  The line has been printed backward, using a stack. */void ReverseRead(void){    StackEntry  item;    Stack stack;    CreateStack(&stack);        /* Initialize the stack to be empty. */    while (!StackFull(&stack) && (item = getchar()) != '\n')        Push(item, &stack);         /* Push each item onto the stack.  */    while (!StackEmpty(&stack)) {        Pop(&item, &stack);         /* Pop an item from the stack.  */        putchar(item);    }    putchar('\n');} #define MAXSTACK    10typedef char StackEntry;typedef struct stack {    int  top;    StackEntry entry[MAXSTACK];} Stack; /* Push: push an item onto the stack. Pre:     The stack exists and it is not full.Post:   The argument item has been stored at the top of the stack. */void Push(StackEntry item, Stack *s){    if (StackFull(s))        Error("Stack is full");    else        s->entry[s->top++] = item;} /* Pop: pop an item from the stack. Pre:   The stack exists and it is not empty.Post: The item at the top of stack has been removed and returned in *item. */void Pop(StackEntry *item, Stack *s){    if (StackEmpty(s))        Error("Stack is empty");    else        *item = s->entry[--s->top];} /* StackEmpty: returns non-zero if the stack is empty. Pre:    The stack exists and it has been initialized.Post:  Return non-zero if the stack is empty; return zero, otherwise. */Boolean StackEmpty(Stack *s){    return s->top <= 0;} /* StackFull: returns non-zero if the stack is full. Pre:     The stack exists and it has been initialized.Post:   Return non-zero if the stack is full; return zero, otherwise. */Boolean StackFull(Stack *s){    return s->top >= MAXSTACK;} /* CreateStack: initialize the stack to be empty. Pre:     None.Post:   The stack has been initialized to be empty. */void CreateStack(Stack *s){    s->top = 0;} typedef struct node {    StackEntry      entry;    struct node *next;} Node; /* MakeNode: make a new node and insert item. Pre:   None.Post: Create a new node and insert item in it. */Node *MakeNode(StackEntry item){    Node *nodepointer;    if ((nodepointer = malloc(sizeof(Node))) == NULL)        Error("Exhausted memory.");    else {        nodepointer->entry = item;        nodepointer->next = NULL;    }    return nodepointer;} typedef struct stack {    Node *top;} Stack; /* Push: make a new node with item and push it onto stack. Pre:   The stack exists and has been initialized.Post: The argument item has been stored at the top of the stack. */void Push(StackEntry item, Stack *s){    Node *np = MakeNode(item);    if (np == NULL)        Error("Attempted to push a non-existing node.");    else {        np->next = s->top;        s->top  = np;    }} CreateStack(s);Push('a', s);Push('b', s);Push('c', s);Pop(&x, s);Pop(&y, s);Pop(&z, s); CreateStack(s);Push('a', s);Push('b', s);Push('c', s);Pop(&x, s);Pop(&y, s);Push(x, s);Push(y, s);Pop(&z, s); CreateStack(s);Push('a', s);Push('b', s);ClearStack(s);Push('c', s);Pop(&x, s);Push('a', s);Pop(&y, s);Push('b', s);Pop(&z, s); CreateStack(s);Push('a', s);Push('b', s);Push('c', s);while (!StackEmpty(s))  Pop(&x, s);  /* Factorial: compute n! Pre:  n is a nonnegative integer.Post: The function value is the factorial of n.*/int Factorial(int n) {    if (n == 0)        return 1;    else        return n * Factorial(n-1);} Move(63,1,2,3);printf("Move disk 64 from tower 1 to tower 3.\n");Move(63,2,3,1) #define DISKS   64      /* Number of disks on the first tower. *//* Towers of Hanoi Pre:  None.Post: The simulation of the Towers of Hanoi has terminated. */int main(void){    Move(DISKS, 1, 3, 2);    return 0;} /* Move: moves count disks from start to finish using temp for temporary storage. */void Move(int count, int start, int finish, int temp){    if (count > 0) {        Move(count-1, start, temp, finish);        printf("Move a disk from %d to %d.\n", start, finish);        Move(count-1, temp, finish, start);    }} Move(1, 1, 2, 3); /* Move 1 disk from tower 1 to tower 2 using tower 3.*/printf("Move disk 2 from tower 1 to tower 3.\n");Move(1, 2, 3, 1); /* Move 1 disk from tower 2 to tower 3 using tower 1.*/ Move(0, 1, 3, 2); /* Move 0 disks. */printf("Move disk 1 from tower 1 to tower 2.\n");Move(0, 3, 2, 1); /* Move 0 disks. */ void AddQueen(void){    for (every unguarded position p on the board) {        Place a queen in position p;        n++;        if (n == 8)            Print the configuration;        else            AddQueen();        Remove the queen from position p;        n--;    }} /* Queen: Eight-queens program. Pre:  None.Post: All solutions to the eight-queens problem are printed.Uses: Function AddQueen performs the recursive backtracking; WriteBoard       prints the solutions. */#include "common.h"#define BOARDSIZE   8#define DIAGONAL    (2*BOARDSIZE-1)#define DOWNOFFSET  7void WriteBoard(void);void AddQueen(void);int queencol[BOARDSIZE];    /* column with the queen    */Boolean colfree[BOARDSIZE]; /* Is the column free?      */Boolean upfree[DIAGONAL];   /* Is the upward diagonal free?     */Boolean downfree[DIAGONAL]; /* Is the downward diagonal free?   */int queencount = -1,        /* row whose queen is currently placed  */    numsol = 0;             /* number of solutions found so far     */ int main(void){    int i;    for (i = 0; i < BOARDSIZE; i++)        colfree[i] = TRUE;    for (i = 0; i < DIAGONAL; i++) {        upfree[i] = TRUE;        downfree[i] = TRUE;    }    AddQueen();    return 0;} /* AddQueen: add a queen to the board. Pre:  Queens have been properly placed in rows 0 through queencount (provided      queencount >= 0) and the information recorded in the above arrays.Post: All solutions beginning with this configuration have been printed.      queencount, and values in all arrays have been returned      to their original values.Uses: Global variable queencount, global arrays queencol, colfree,      upfree, and downfree, and function WriteBoard. */ void AddQueen(void){    int col;    /* column being tried for the queen */    queencount++;    for (col = 0; col < BOARDSIZE; col++)        if (colfree[col] && upfree[queencount + col] &&            downfree[queencount - col + DOWNOFFSET]) {            /* Put a queen in position (queencount, col).   */            queencol[queencount] = col;            colfree[col] = FALSE;            upfree[queencount + col] = FALSE;            downfree[queencount - col + DOWNOFFSET] = FALSE;            if (queencount == BOARDSIZE-1)  /* termination condition    */                WriteBoard();            else                AddQueen();                 /* Proceed recursively. */            colfree[col] = TRUE;    /* Now backtrack by removing the queen. */            upfree[queencount + col] = TRUE;            downfree[queencount - col + DOWNOFFSET] = TRUE;        }    queencount--;} /* WriteBoard: display the current solution. Pre:  Global array queencol and variable numsol exist and have been      initialized.Post: Writes out the board with the queens in their respective positions.Uses: Global array queencol and variable numsol. */void WriteBoard(void){    int row, col;    printf("Configuration %d of eight queens:\n", ++numsol);    for (row = 0; row < BOARDSIZE; row++) {        for (col = 0; col < BOARDSIZE; col++)            if (queencol[row] == col)                printf("Q");            else                printf("-");        printf("\n");    }    printf("\nPress Enter to continue");    while (getchar() != '\n')        ;} /* Move: iterative version. Pre:  Disk count is a valid disk to be moved.Post: Moves count disks from start to finish using temp for temporary      storage.*/void Move(int count, int start, int finish, int temp){    int swap;   /* temporary storage to swap towers */    while (count > 0) {        Move(count - 1, start, temp, finish);        printf("Move disk %d from %d to %d.\n", count, start, finish);        count--;        swap = start;        start = temp;        temp = swap;    }} /* Factorial: recursive version. Pre:  n is a nonnegative integer.Post: The function value is the factorial of n.*/int Factorial(int n){    if (n == 0)        return 1;    else        return n * Factorial(n-1);} /* Function: iterative version. Pre:  n is a nonnegative integer.Post: The function value is the factorial of n.*/int Factorial(int n){    int count, product;    for (product = 1, count = 2; count <= n; count++)        product *= count;    return product;}  + Factorial(5) = 5 * Factorial(4) + = 5 * (4 * Factorial(3)) + = 5 * (4 * (3 * Factorial(2))) + = 5 * (4 * (3 * (2 * Factorial(1)))) + = 5 * (4 * (3 * (2 * (1 * Factorial(0))))) + = 5 * (4 * (3 * (2 * (1 * 1)))) + = 5 * (4 * (3 * (2 * 1))) + = 5 * (4 * (3 * 2)) + = 5 * (4 * 6) + = 5 * 24 + = 120  /* Fibonacci: recursive version. Pre:  The parameter n is a nonnegative integer.Post: The function returns the n^th Fibonacci number.*/int Fibonacci(int n){    if (n <= 0)        return 0;    else if (n == 1)        return 1;    else        return Fibonacci(n-1) + Fibonacci(n-2);} /* Fibonacci: iterative version. Pre:  The parameter n is a nonnegative integer.Post: The function returns the n^th Fibonacci number.*/int Fibonacci(int n){    int i;    int twoback;    /* second previous number, F_i-2    */    int oneback;    /* previous number, F_i-1       */    int current;    /* current number, F_i      */    if (n <= 0)        return 0;    else if (n == 1)        return 1;    else {        twoback = 0;        oneback = 1;        for (i = 2; i <= n; i++) {            current = twoback + oneback;            twoback = oneback;            oneback = current;        }        return current;    }}  5 CreateStack  Push    StackEmpty   StackSizeClearStack   Pop     StackFull    TraverseStack