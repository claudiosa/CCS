 /* InsertionSort: sort contiguous list by the insertion sort method. Pre:    The contiguous list list has been created. Each entry of list         contains a key.Post:  The entries of list have been rearranged so that the keys in        all the entries are sorted into nondecreasing order. */void InsertionSort(List *list){    Position fu;        /* position of first unsorted entry */    Position place;     /* searches sorted part of list */    ListEntry current;  /* holds entry temporarily removed from list */    for (fu = 1; fu < list->count; fu++)        if (LT(list->entry[fu].key, list->entry[fu - 1].key)) {            current = list->entry[fu];            for (place = fu - 1; place >= 0; place--) {                list->entry[place + 1] = list->entry[place];                if (place == 0 || LE(list->entry[place - 1].key, current.key))                        break;            }            list->entry[place] = current;        }} /* InsertionSort: sort linked list by the insertion sort method. Pre:    The linked list list has been created. Each entry of list         contains a key.Post:  The entries of list have been rearranged so that the keys in all        the entries are sorted into nondecreasing order. */void InsertionSort(List *list){    ListNode *fu;           /* the first unsorted node to be inserted */    ListNode *ls;           /* the last sorted node (tail of sorted sublist) */    ListNode *current, *trailing;    if (list->head) {        ls = list->head;    /* An empty list is already sorted. */        while (ls->next) {            fu = ls->next;  /* Remember first unsorted node.    */            if (LT(fu->entry.key, list->head->entry.key)) {                ls->next = fu->next;                fu->next = list->head;                list->head = fu;    /* Insert first unsorted at the head of sorted list. */            } else {                /* Search the sorted sublist. */                trailing = list->head;                for (current = trailing->next; GT(fu->entry.key, current->entry.key);                    current = current->next)                        trailing = current;                /* First unsorted node now belongs between trailing and current. */                if (fu == current)                    ls = fu;                else {                    ls->next = fu->next;                    fu->next = current;                    trailing->next = fu;                }            }        }    }} /* SelectionSort: sort contiguous list by the selection sort method. Pre:    The contiguous list list has been created. Each entry of list         contains a key.Post:  The entries of list have been rearranged so that the keys in        all the entries are sorted into nondecreasing order.Uses: MaxKey, Swap. */ void SelectionSort(List *list){    Position current;       /* position of place being correctly filled */    Position max;           /* position of largest remaining key */    for (current = list->count - 1; current > 0; current--) {        max = MaxKey(0, current, list);        Swap(max, current, list);    }} /* MaxKey: find the position of the largest key in the sublist. Pre:    The contiguous list list has been created. low and high         are valid positions in list.Post:  The position of the entry between low and high with the        largest key is returned. */ Position MaxKey(Position low, Position high, List *list){    Position largest;       /* position of largest key so far */    Position current;       /* index for the contigous list */    largest = low;    for (current = low + 1; current <= high; current++)        if (LT(list->entry[largest].key, list->entry[current].key))            largest = current;    return largest;} /* Swap: swap two entries in the contiguous list. Pre:    The contiguous list list has been created. low and high         are valid positions in list.Post:  The entry at position low is swapped with the entry at position        high. */void Swap(Position low, Position high, List *list){    ListEntry temp = list->entry[low];    list->entry[low] = list->entry[high];    list->entry[high] = temp;} /* ShellSort: sort contiguous list by the Shell sort method. Pre:    The contiguous list list has been created. Each entry of list         contains a key.Post:  The entries of list have been rearranged so that the keys in        all the entries are sorted into nondecreasing order.Uses: SortInterval. */void ShellSort(List *list){    int      increment; /* spacing of entries in sublist */    Position start;     /* starting position of sublist */    increment = list->count;    do {        increment = increment / 3 + 1;        for (start = 0; start < increment; start++)            SortInterval(start, increment, list); /* modified insert sort */    } while (increment > 1);} void FourSort(Key *a, Key *b, Key *c, Key *d){  if (GT(a, b) Swap(a, b);      /*Now know a <= b.*/  if (GT(c, d) Swap(c, d);      /*Now know c <= d.*/  if (GT(b, d) Swap(b, d);      /*Now know that d is largest.*/  if (GT(a, c) Swap(a, c);      /*Now know that a is smallest.*/  if (GT(b, c) Swap(b, c);      /*Finally compare the middle keys.*/} Sort(list){   if the list has length greater than 1 then   {      Partition the list into lowlist, highlist;      Sort(lowlist);      Sort(highlist);      Combine(lowlist, highlist);   }} /* MergeSort: sort contiguous list by the merge sort method. Pre:    The linked list list has been created. Each entry of list         contains a key.Post:  The entries of list have been rearranged so that the keys in all        the entries are sorted into nondecreasing order.Uses: Divide, Merge. */void MergeSort(List *list){    List secondhalf;    /* holds the second half of the list after division */    if (ListSize(list) > 1) {       /* Is there a need to sort? */        Divide(list, &secondhalf);  /* Divide the list in half. */        MergeSort(list);            /* Sort the first half.     */        MergeSort(&secondhalf);     /* Sort the second half.    */        Merge(list, &secondhalf, list); /* Merge the two sorted sublists. */    }} /* Divide: divide the list into two parts. Pre:    The linked list list has been created.Post:  List list has been reduced to its first half, and the second half        of the entries from list are in the linked list secondhalf.        If list has an odd number of entries, then its first half will        be one entry larger than its second. */void Divide(List *list, List *secondhalf){    ListNode *current, *midpoint;    if ((midpoint = list->head) == NULL)        secondhalf->head = NULL;    else {        for (current = midpoint->next; current; ) {            current = current->next;            if (current) {                midpoint = midpoint->next;                current = current->next;            }        }        secondhalf->head = midpoint->next;        midpoint->next = NULL;    }} /* Merge: merge two lists producing a third list. Pre:    first and second are ordered linked lists and have been created.Post:  out is an ordered linked list containing all entries that were in        first and second. The original lists first and second have        been destroyed. */void Merge(List *first, List *second, List *out){    ListNode *p1, *p2;  /* pointers to traverse first and second lists */    ListNode *lastsorted;   /* always points to last node of sorted list */    if (!first->head)        *out = *second;    else if (!second->head)        *out = *first;    else {        p1 = first->head;   /* First find the head of the merged list. */        p2 = second->head;        if (LE(p1->entry.key, p2->entry.key)) {            *out = *first;            p1 = p1->next;        } else {            *out = *second;            p2 = p2->next;        }        lastsorted = out->head; /* lastsorted gives last entry of merged list. */        while (p1 && p2)            if (LE(p1->entry.key, p2->entry.key)) {                lastsorted->next = p1;                lastsorted = p1;                p1 = p1->next;            } else {                lastsorted->next = p2;                lastsorted = p2;                p2 = p2->next;            }        if (p1)                 /* Attach the remaining list. */            lastsorted->next = p1;        else            lastsorted->next = p2;    }} /* QuickSort: sort contiguous list by the quicksort method. Pre:    The contiguous list list has been created. Each entry of list         contains a key.Post:  The entries of list have been rearranged so that the keys in        all the entries are sorted into nondecreasing order.Uses: RecQuickSort. */void QuickSort(List *list){    RecQuickSort(list, 0, list->count - 1);} /* RecQuickSort: use recursive method to sort list. Pre:    The contiguous list list has been created. Each entry of list         contains a key. low and high are valid positions on the        list list.Post:  The entries of list have been rearranged so that the keys in        all the entries are sorted into nondecreasing order.Uses: RecQuickSort, Partition. */void RecQuickSort(List *list, Position low, Position high){    Position pivotpos;      /* position of the pivot after partitioning */    if (low < high) {        pivotpos = Partition(list, low, high);        RecQuickSort(list, low, pivotpos - 1);        RecQuickSort(list, pivotpos + 1, high);    }} /* Partition: partition a list. Pre:    The contiguous list list has been created; low and high are        valid positions on the list list.Post:  The center (or left center) entry of list has been chosen as a        pivot and moved to index pivotpos. All entries of list between        indices low and high, inclusive, have been rearranged so that        those with keys less than the pivot come before pivotpos and the        remaining entries come after pivotpos.Uses: Swap. */Position Partition(List *list, Position low, Position high){    ListEntry pivot;    Position i, lastsmall, pivotpos;    Swap(low, (low + high) / 2, list);    pivot= list->entry[low];    pivotpos = low;    for (i = low + 1; i <= high; i++)        if (LT(list->entry[i].key, pivot.key))            Swap(++pivotpos, i, list); /* Move large entry to right and small to left. */    Swap(low, pivotpos, list);    return pivotpos;} do {  do  i = i + 1  while (LT(list->entry[i].key, pivot.key));  do  j = j - 1  while (GT(list->entry[j].key, pivot.key));  Swap(i, j, list);} while (i < j); /* HeapSort: sort contiguous list by the heap sort method. Pre:    The contiguous list list has been created. Each entry of list         contains a key.Post:  The entries of list have been rearranged so that the keys in        all the entries are sorted into nondecreasing order.Uses: BuildHeap, InsertHeap. */void HeapSort(List *list){    Position lu;            /* Entries beyond lu have been sorted. */    ListEntry current;      /* holds entry temporarily removed from list */    BuildHeap(list);        /* First phase: turn list into a heap. */    for (lu = list->count - 1; lu >= 1; lu--) {        current = list->entry[lu]; /* Extract last element from list. */        list->entry[lu] = list->entry[0]; /* Move top of heap to end of list. */        InsertHeap(current, 0, lu - 1, list);    }} /* InsertHeap: insert an entry into the heap. Pre:    The entries of contiguous list list between indices low + 1        and high, inclusive, form a heap. The entry in position low         will be discarded.Post:  The entry current has been inserted into list and the entries        rearranged so that the entries between indices low and high,        inclusive, form a heap. */void InsertHeap(ListEntry current, Position low, Position high, List *list){    Position large; /* position of child of list->entry[low] with the                       larger key */    large = 2 * low + 1;    /* large is now the left child of low. */    while (large <= high) {        if (large < high && LT(list->entry[large].key, list->entry[large + 1].key))            large++; /* large is now the child of low with the largest key. */        if (GE(current.key, list->entry[large].key))            break;        else {          /* Promote entry[large] and move down the tree. */            list->entry[low] = list->entry[large];            low = large;            large = 2 * low + 1;        }    }    list->entry[low] = current;} /* BuildHeap: build a heap from a random contiguous list. Pre:    The contiguous list list has been created. Each entry of list         contains a key.Post:  The entries of list have been rearranged so that list becomes        a heap.Uses: InsertHeap. */void BuildHeap(List *list){    Position low;           /* Entries beyond low form a heap. */    for (low = list->count / 2 - 1; low >= 0; low--)        InsertHeap(list->entry[low], low, list->count, list);}