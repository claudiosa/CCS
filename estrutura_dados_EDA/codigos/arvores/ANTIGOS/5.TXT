 /* InsertList: insert a new entry in the list. Pre:   The list list has been created, list is not full, x is a valid        list entry, 0 <= p <= n where n is the number of entries in        list.Post: x has been inserted into position p in list; the entry formerly        in position p (provided p < n) and all later entries        have their position numbers increased by 1.Uses: Error, ListFull, ListSize. */void InsertList(Position p, ListEntry x, List *list){    int i;    if (p < 0 || p > ListSize(list))        Error("Attempt to insert in a position not in the list.");    else if (ListFull(list))        Error("Attempt to insert an entry into a full list.");    else {        for (i = ListSize(list) - 1; i >= p; i--) /* Move later entries.*/            list->entry[i+1] = list->entry[i];        list->entry[p] = x;        list->count++;    }} typedef char ListEntry;typedef struct listnode {    ListEntry       entry;    struct listnode *next;} ListNode; typedef int  Position;typedef struct list {    int         count;    ListNode    *head;} List; /* SetPosition: set current to point to a node at position p. Pre:   p is a valid position on list list; 0 <=p < list->count.Post: The list pointer current points to the list node at position p.Uses: Error. */void SetPosition(Position p, List *list, ListNode **current){    int count;      /* used to loop through positions */    ListNode *q;        /* used to traverse list */    if (p < 0 || p >= list->count)        Error("Attempt to set a position not in the list.");    else {          /* Count from head of list to position p. */        q = list->head;        for (count = 1; count <= p; count++)            q = q->next;        *current = q;    }} newnode->next = current->next;current->next = newnode; /* InsertList: insert a new entry in the list.  Pre:   The list list has been created, list is not full, x is a valid        list entry, 0 <= p <= n where n is the number of entries in        list.Post: x has been inserted into position p in list; the entry formerly        in position p (provided p<n) and all later entries        have their position numbers increased by 1.Uses: Error, MakeListNode, SetPosition. */void InsertList(Position p, ListEntry x, List *list){    ListNode *newnode, *current;     if (p < 0 || p > list->count)        Error("Attempt to insert in a position not in the list.");    else {        newnode = MakeListNode(x);        if (p == 0) {            newnode->next = list->head;            list->head = newnode;        } else {            SetPosition(p-1, list, &current);            newnode->next = current->next;            current->next = newnode;        }        list->count++;    }} /* MakeListNode: make a new ListNode. Pre:   The entry x is valid.Post: The function creates a new ListNode, initializes it with x,        and returns a pointer to the new node. */ListNode *MakeListNode(ListEntry x){    ListNode *p = malloc(sizeof(ListNode)); /* Obtain space from the system. */    if (p) {        p->entry = x;        p->next  = NULL;  /* Set pointer field for safety's sake. */    } else        Error("No space for additional node can be obtained.");    return p;} typedef int  Position;typedef struct list {    int         count;    ListNode    *head;    Position    currentpos;    ListNode    *current;} List; /* SetPosition: set list->current to point to a node at position p. Pre:   p is a valid position on list list; 0 <= p < list->count.Post: The pointer list->current points to the list node at position p.Uses: Error. */void SetPosition(Position p, List *list){    if (p < 0 || p >= list->count)        Error("Attempt to set a position not in the list.");    else {        if (p < list->currentpos) {            list->currentpos = 0;            list->current    = list->head;        }        for ( ; list->currentpos != p; list->currentpos++)            list->current = list->current->next;    }} typedef char ListEntry;typedef struct listnode {    ListEntry       entry;    struct listnode *next;    struct listnode *previous;} ListNode; typedef int  Position;typedef struct list {    int         count;    ListNode    *current;    Position    currentpos;} List; /* SetPosition: set current to point to a node at position p. Pre:   p is a valid position on list list; 0 <=p < list->count.Post: The pointer list->current points to the list node at position p.Uses: Error. */ void SetPosition(Position p, List *list){    if (p < 0 || p >= list->count)        Error("Attempt to set a position not in the list.");    else if (list->currentpos < p)        for ( ; list->currentpos != p; list->currentpos++)            list->current = list->current->next;    else if (list->currentpos > p)        for ( ; list->currentpos != p; list->currentpos--)            list->current = list->current->previous;} /* InsertList: insert a new entry in the list. Pre:   The list list has been created, list is not full, x is a valid        list entry, 0 <= p <= n where n is the number of entries        in list.Post: x has been inserted into position p in list; the entry formerly        in position p (provided p<n) and all later entries        have their position numbers increased by 1.Uses: Error, SetPosition. */void InsertList(Position p, ListEntry x, List *list){    ListNode *newnode, *following;    if (p < 0 || p > list->count)        Error("Attempt to insert in a position not in the list.");    else {        newnode = MakeListNode(x);        if (p == 0) {           /* Insert at the beginning of the list. */            newnode->previous = NULL;            if (list->count == 0)   /* The list was empty. */                newnode->next = NULL;            else {              /* Insert at the start of the existing list. */                SetPosition(0, list);                newnode->next = list->current;                list->current->previous = newnode;            }        } else {                /* Insert later in the list. */            SetPosition(p-1, list);            following = list->current->next;                                /* Insert between current and following. */            newnode->next = following;            newnode->previous = list->current;            list->current->next = newnode;            if (following)                following->previous = newnode;        }        list->current = newnode;        list->currentpos = p;        list->count++;    }} char *string = "This is a string."; /* Implement a simple editor. Pre:  None.Post: Reads in a file that contains lines (character strings),        performs simple editing operations on the lines, and        writes out the edited version.Uses: GetCommad, DoCommand. */ int main(int argc, char *argv[]){    char command;    List buffer;     CreateList(&buffer);    OpenFiles(argc, argv, &buffer);     do {        GetCommand(&command, &buffer);        DoCommand(command, &buffer);    } while(command != 'q');     return 0;} /* GetCommand: get a new command. Pre:  None.Post: Returns a character command corresponding to the legal commands        for the editor.Uses: ListSize, DisplayCurrentLine. */void GetCommand(char *command, List *buffer){    if(ListSize(buffer) == 0)        printf("The buffer is empty.\n");    else        DisplayCurrentLine(buffer);    printf("Please enter a command: ");    do {        while ((*command = getchar()) == ' ' || *command == '\t' ||                *command == '\n')            ;               /* Skip white space characters. */        *command = tolower(*command);        if (strchr("bcdefgh?ilnpqrsvw", *command) == NULL)            printf("Press h for help or enter a valid command: ");        else            return;         /* Received a valid command. */    } while (1);} /* DoCommand: execute a command. Pre:  command is a valid command for the editor.Post: The command designated by command has been performed on the lines        in the buffer or one line (depending on the command).Uses: All the functions that perform editor commands. */void DoCommand(char command, List *buffer){    switch(command) {    case 'b':               /* Go to beginning of buffer. */        GoToBeginning(buffer);        break;    case 'c':               /* Change string to replacement text. */        ChangeString(buffer);        break;     case 'd':               /* Delete the current line. */        DeleteLine(buffer);        break;     case 'e':               /* Go to the last line of the buffer. */        GoToEnd(buffer);        break;     case 'f':               /* Find the first line containing target string. */        FindString(buffer);        break;     case 'g':               /* Go to a user-specified line number. */        GoToLine(buffer);        break;     case '?':     case 'h':               /* Display instructions explaining all commands. */        Help();        break;     case 'i':               /* Insert a new line at the current line number. */        InsertLine(buffer);        break;     case 'l':         /* Show the length of current line and number of lines. */        Length(buffer);        break;     case 'n':               /* Move to next line of buffer. */        NextLine(buffer);        break;     case 'p':               /* Move to the previous line of buffer. */        PrecedingLine(buffer);        break;     case 'q':               /* Terminate the editor immediately. */        break;     case 'r':               /* Read a text file into the buffer. */        ReadFile(buffer);        break;     case 's':               /* Substitute a new line for the current line. */        SubstituteLine(buffer);        break;     case 'v':               /* View the entire contents of the buffer. */        ViewBuffer(buffer);        break;     case 'w':               /* Write the contents of the buffer into a text file. */        WriteFile(buffer);        break;    }} /* ReadFile: read the contents of the input file. Pre:  The buffer has been created.Post: Reads the file contents of the input file into buffer, stopping        at the end of file; any contents of the buffer before the read        are discarded after approval from the user; leaves the        current line at the first line of the buffer.Uses: ListEmpty, ClearList, CreateList, InsertList,        UserSaysYes. */ void ReadFile(List *buffer){     char line[MAXLINE];    Boolean proceed = TRUE;     if (!ListEmpty(buffer)) {        printf("Buffer is not empty; the read will destroy it. "                "OK to proceed? ");        if ((proceed = UserSaysYes()) == TRUE)            ClearList(buffer);    }     if (proceed) {        CreateList(buffer);        fseek(buffer->fpi, 0L, 0);  /* reset to the beginning of the file */        while (fgets(line, MAXLINE, buffer->fpi))            InsertList(ListSize(buffer), line, buffer);        buffer->currentpos = 0;        buffer->current = buffer->head;    } } /* InsertLine: insert a new line into the buffer. Pre:  The list buffer has been created.Post: The line newline if valid is inserted into the list and currentpos         is set to the newline.Uses: ListFull, ListSize, InsertList, Error. */  void InsertLine(List *buffer){     int newline;    char line[MAXLINE];     if(ListFull(buffer))        Error("Buffer is full; no insertion is possible.");     else {        printf("Where do you want to insert a new line? ");        scanf("%d", &newline);        if (newline < 0 || newline > ListSize(buffer)) {            printf("That line number does not exist.");        } else {            printf("I: ");            fflush(stdin);            fgets(line, MAXLINE, stdin);            InsertList(newline, line, buffer);        }    } } /* FindString: find the line containing the string specified. Pre:  The list buffer has been created.Post: Obtains a target string from the user and moves through the buffer      searching for the first line that contains the target string;     prints the line where target is found, with the target highlighted.      If the target is not found, no change is made, and the user is informed.Uses: ListEmpty. */void FindString(List *buffer){    int  n;    ListNode *p;    char *s, *t, target[MAXLINE];    if (ListEmpty(buffer))        printf("Empty buffer; cannot search.\n");    else {        printf("String to search for? ");        fflush(stdin);        fgets(target, MAXLINE, stdin);        target[strlen(target) - 1] = '\0';  /* Drop newline character. */        for (p = buffer->current, n = buffer->currentpos; p; p = p->next, n++)            if ((s = strstr(p->entry, target)) != NULL)                break;        if (!p)            printf("String was not found.\n");        else {            buffer->current = p;            buffer->currentpos = n;            printf("%2d: %s", n, p->entry);            printf("    ");            for (t = p->entry; t < s; t++)                putchar(' ');            for ( ; t < s + strlen(target); t++)                putchar('^');            putchar('\n');        }    }} /* ChangeString: change a string within buffer. Pre:  The list buffer has been created.Post: If the line the user specifies is not in the buffer, then        no change is made, and the user is informed. Otherwise, a target        is obtained from the user and located in the line the user specified.        If it is not found, the user is informed. Otherwise, a replacement        string is obtained from the user and substituted for the target string.Uses: ListSize, SetPosition. */void ChangeString(List *buffer){    int n, len;    char *s, rep[MAXLINE], text[MAXLINE], temp[MAXLINE];    printf("Which line to change? ");    scanf("%d", &n);            /* Input the line number. */    if (n < 0 || n >= ListSize(buffer))        printf("No line to process.");    else {        SetPosition(n, buffer);        printf("Text to replace? ");        fflush(stdin);        fgets(text, MAXLINE, stdin);    /* Input the target. */        text[strlen(text) - 1] = '\0';  /* Drop newline character. */        if ((s = strstr(buffer->current->entry, text)) == NULL)            printf("String not found.");        else {            printf("Replacement text? ");            fflush(stdin);            fgets(rep, MAXLINE, stdin); /* Input the replacement. */            rep[strlen(rep) - 1] = '\0';            len = s - buffer->current->entry;            strncpy(temp, buffer->current->entry, len);            temp[len] = '\0';            strcat(temp, rep);            strcat(temp, buffer->current->entry + len + strlen(text));            free(buffer->current->entry);            buffer->current->entry = malloc(strlen(temp) + 1);            strcpy(buffer->current->entry, temp);        }    }} #define     MAXLIST     10   /* Use a small value for testing. */typedef char ListEntry;typedef int  ListIndex;typedef struct listnode {    ListEntry entry;    ListIndex next;} ListNode; typedef int Position;typedef struct list {    ListIndex   head;    int         count;} List;extern ListIndex avail, lastused;extern ListNode  workspace[]; void    CreateList(List *);int     CurrentPosition(Position, List *);void    DisposeNode(ListIndex, List *);void    Error(char *);void    InsertList(Position, ListEntry, List *);ListIndex NewNode(void);void    SetPosition(Position, ListIndex *, List *);void    TraverseList(List *, void (*f)());void    WriteEntry(ListEntry); /* NewNode: make a new node. Pre:  The list indices avail and lastused have been initialized when    they were defined as global variables and have been used or modified    only by NewNode and DisposeNode. The workspace array is not full.Post: The list index newindex has been set to the first available place    in workspace; avail, lastused, and workspace have been updated    as necessary.Uses: avail, lastused, and workspace as global variables. */ ListIndex NewNode(void){    ListIndex newindex = -1;     if (avail != -1) {        newindex = avail;        avail = workspace[avail].next;        workspace[newindex].next = 0;    } else if (lastused < MAXLIST - 1) {        newindex = ++lastused;        workspace[newindex].next = 0;    } else        Error("Overflow: workspace for linked list is full.");    return newindex;} /* DisposeNode: return a node to available space. Pre:  The list indices avail and lastused have been initialized when    they were defined as global variables and have been used or modified    only by NewNode and DisposeNode; oldindex is an occupied    position in workspace.Post: The list index oldindex has been pushed onto the linked stack    of available space; avail, lastused, and workspace have been    updated as necessary.Uses: avail, lastused, and workspace as global variables. */void DisposeNode(ListIndex oldindex, List *list){    ListIndex previous;    if (oldindex == -1)        Error("Disposing a nonexistent node in workspace array.");    else {        if (oldindex == list->head)            list->head = workspace[oldindex].next;        else {            SetPosition(CurrentPosition(oldindex, list) - 1, &previous, list);            workspace[previous].next = workspace[oldindex].next;        }        workspace[oldindex].next = avail;        avail = oldindex;    }} /* TraverseList: traverse the list applying (*f)() to each element. Pre:   The list list exists.Post: The function (*f)() has been applied to each element of the list. */ void TraverseList(List *list, void (*f)()){    ListIndex current;     for (current = list->head; current != -1; current = workspace[current].next)        f(workspace[current].entry);} /* InsertList: insert a node into the list. Pre:   The linked list list has been created, list is not full, x is    a valid list entry, and 0 <= p <= n, where n is the number of    entries in ist.Post: x has been inserted into position p in list; the entry formerly    in position p (provided p < n) and all later entries have    their position numbers increased by 1.Uses: SetPosition, NewNode, Error. */ void InsertList(Position p, ListEntry x, List *list){    ListIndex newindex, previous;     if (p < 0 || p > list->count)        Error("Inserting into a nonexistent position.");     else {        newindex = NewNode();        workspace[newindex].entry = x;        if (p == 0) {            workspace[newindex].next = list->head;            list->head = newindex;        } else {            SetPosition(p-1, &previous, list);            workspace[newindex].next = workspace[previous].next;            workspace[previous].next = newindex;        }        list->count++;    }} void Permute(, ){/* requires that 1 through k - 1 already be in the permutation list; theninserts the integers from k through n into the permutation list */  for each of the  possible positions in the list {    Insert  into the given position;    if  ==        ProcessPermutation    else      Permute();    Remove  from the given position;   }} /* Permute: insert all entries in perm. Pre:  perm contains a permutation with entries 1 through        newentry - 1.Post: All permutations with degree entries, built from the given        permutation, have been constructed and processed.Uses: Permute recursively, ProcessPermutation. */ void Permute(int newentry, int degree, List *perm){    int current = 0;     for (current = 1; current <= ListSize(perm)+1; current++) {        InsertList(current, newentry, perm);        if (newentry == degree)            ProcessPermutation(perm);        else            Permute(newentry + 1, degree, perm);        DeleteList(current, newentry, perm);    }} /* Permute: insert all entries in perm. Pre:  perm contains a linked permutation with entries 1 through        newentry - 1.Post: All permutations with degree entries, built from the given        permutation, have been constructed and processed.Uses: Permute recursively, ProcessLinkedPermutation. */void Permute(int newentry, int degree, int *perm){    int current = 0;     do {        perm[newentry] = perm[current];        perm[current]  = newentry;        if (newentry == degree)            ProcessLinkedPermutation(perm);        else            Permute(newentry + 1, degree, perm);        perm[current] = perm[newentry];        current = perm[current];    } while (current != 0);} #define   MAXDEGREE 20  /* large enough for all practical purposes */int main(){    int degree;    int perm[MAXDEGREE+1];    printf("Number of elements to permute? ");    scanf("%d", &degree);    if (degree < 1 || degree > MAXDEGREE)        printf("The number must be between 1 and %d\n", MAXDEGREE);    else {        perm[0] = 0;        /* Set the list to be initially empty. */        Permute(1, degree, perm);/* Install all entries from 1 to degree. */    }    return 0;} /* ProcessLinkedPermutation: print a permutation. Pre:  perm contains a permutation in linked form.Post: The permutation has been printed at the terminal. */void ProcessLinkedPermutation(int *perm){    int current = 0;    while (perm[current] != 0) {        printf("%3d", perm[current]);        current = perm[current];    }    putchar('\n');}