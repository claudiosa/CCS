 /* RadixSort:  sort a list using radix sort method. Pre:   The linked list list has been created. The entries in list all    contain keys that are arrays of letters of size KEYSIZE.Post: The entries of list have been sorted so all their keys are in    alphabetical order.Uses: Functions for queues (chapter 5) and lists (chapter 6). */void RadixSort(List *list){    int     i, j;    Node    *x;    Queue   queues[MAXQUEUEARRAY];    for (i = 0; i < MAXQUEUEARRAY; i++)        CreateQueue(&queues[i]);    for (j = KEYSIZE - 2; j >= 0; j--) {        while(!ListEmpty(list)) {            DeleteList(0, &x, list);            AppendNode(x, &queues[QueuePosition(x->entry[j])]);        }        Rethread(list, queues);    }} /* QueuePosition:  determine the queue position (0 through 27)    for a character. Pre:   None.Post: If c is a letter of the alphabet (either upper or lower case) then    the function returns the position of c within the alphabet (from 1    for `a' or `A' to 26 for `z' or `Z'). Otherwise, if c is a blank then    0 is returned, else the function returns 27.Uses: System requirement that the letters have adjacent codes (true for    ASCII, not true for EBCDIC) */int QueuePosition(char c){    if (c == ' ')        return 0;    else if (isalpha(c))        return tolower(c) - 'a' + 1;    else        return 27;} /* Rethread:  rethread a list from an array of queues. Pre:   All 28 linked queues in array queues have been created; the list    has been created and is empty.Post: All the queues are combined to form one list list; all the queues    are empty. */void Rethread(List *list, Queue queues[]){    int     i;    Node    *x;    for (i = 0; i < MAXQUEUEARRAY; i++)        while(!QueueEmpty(&queues[i])) {            ServeNode(&x, &queues[i]);            InsertList(ListSize(list), x, list);        }} /* Hash:  determine the hash value of key s. Pre:     s is a valid key type.Post:   s has been hashed, returning a value between 0 and HASHSIZE -1 */int Hash(Key s){    unsigned h = 0;    while (*s)        h += *s++;    return h % HASHSIZE;} /* declarations for a hash table with open addressing */#define HASHSIZE 997typedef char *Key;typedef struct item {    Key key;} Entry;typedef Entry HashTable[HASHSIZE]; /* Insert: insert an item using open addressing and linear probing. Pre:     The hash table H has been created and is not full. H has no        current entry with key equal to that of newitem.Post:   The item newitem has been inserted into H.Uses:   Hash. */void Insert(HashTable H, Entry newitem){    int pc = 0;     /* probe count to be sure that table is not full    */    int probe;      /* position currently probed in H                 */    int increment = 1;  /* increment used for quadratic probing         */    probe = Hash(newitem.key);     while (H[probe].key != NULL &&          /* Is the location empty?       */      strcmp(newitem.key, H[probe].key) &&  /* Duplicate key present?   */      pc <= HASHSIZE / 2) {                 /* Has overflow occurred?       */        pc++;        probe = (probe + increment) % HASHSIZE;        increment += 2;         /* Prepare increment for next iteration.  */    }     if (H[probe].key == NULL)        H[probe] = newitem;             /* Insert the new entry.    */    else if (strcmp(newitem.key, H[probe].key) == 0)        Error("The same key cannot appear twice in the hash table.");    else        Error("Hash table is full; insertion cannot be made.");} for(i = 0; i < HASHSIZE; i++)    CreateList(H[i]); #define     HASHSIZE        997 #define     FACTOR          101 typedef enum state { DEAD, ALIVE } State;typedef struct cell{     State       status;     int         neighborcount;     int         row,                col;     struct cell *next; } Cell;typedef Cell *HashTable[HASHSIZE];typedef Cell *ListEntry; typedef struct node{     ListEntry   entry;     struct node *next; } Node;typedef int  Position;typedef struct list{     int     count;     Node    *head; } List; #include "common.h" #include "life3.h" HashTable map;      /* global: the hash table map                   */List    newlive,    /* global: the cells that have just been vivified       */         newdie,     /* global: the cells that have just died                */         maylive,    /* global: candidates to vivify in the next generation  */         maydie;     /* global: candidates to kill in the next generation    */ /* Life3 - Third version of Life Pre:  The user supplies an initial configuration of living cells.Post: The program prints a sequence of maps showing the changes in the      configuration of living cells according to the rules for the game      of Life.Uses: Introduction, Initialized, WriteMap, and simple list functions. */void main(void){    Introduction();    Initialize(map, &newlive, &newdie, &maylive, &maydie);    WriteMap();    printf("Proceed with the demonstration");    while (UserSaysYes()) {        TraverseList(&maylive,Vivify);        ClearList(&maylive);        TraverseList(&maydie, Kill);        ClearList(&maydie);        WriteMap();        TraverseList(&newlive, AddNeighbors);        ClearList(&newlive);        TraverseList(&newdie, SubtractNeighbors);        ClearList(&newdie);        printf("Do you want to continue viewing new generations");    }} /* Vivify: vivify a cell if it should become alive. Pre:  The cell pointed by cell is a candidate to become alive.Post: Checks that cell in the hash table map pointed by cell     meets all requirements to become alive.  If not,    no change is made.  If so, then the pointer to the cell is added to    the list newlive. The cell status is set to ALIVE.Uses: Function AddList, the      list newlive as global variables (side effects). */void Vivify(ListEntry cell){    if (cell->status == DEAD && cell->neighborcount == 3) {        cell->status = ALIVE;        AddList(cell, &newlive);    }} /* AddNeighbors: add the neighbors for cell. Pre:  cell is a pointer to a cell that has just become alive.Post: The neighbors of the cell pointed to by cell have had their        neighbor count increased. If the increased neighbor count makes        the cell a candidate to be vivified [resp. killed]        then the pointer to the        cell has been added to the list maylive [resp. maydie].Uses: AddList, GetCell, changes lists maylive and maydie as global        variables (side effects). */void AddNeighbors(ListEntry cell){    int nbrrow,     /* loop index for row of neighbor loops */        nbrcol;     /* column loop index    */    Cell *neighbor; /* pointer to a structure form of a neighbor    */    for (nbrrow = cell->row-1; nbrrow <= cell->row+1; nbrrow++)        for (nbrcol = cell->col-1; nbrcol <= cell->col+1; nbrcol++)            if (nbrrow != cell->row || nbrcol != cell->col) {   /* Skip cell itself. */                neighbor = GetCell(nbrrow, nbrcol);                switch (++neighbor->neighborcount) {                case 0: Error("Impossible case in AddNeighbors.");                    break;                case 3:                    if (neighbor->status == DEAD)                        AddList(neighbor, &maylive);                    break;                case 4:                    if (neighbor->status == ALIVE)                        AddList(neighbor, &maydie);                    break;                }   /* switch statement */            }} /* GetCell: get a cell from the hash table. Pre:     The hash table map has been initialized.Post:   The function returns a pointer to the cell(row, col) from the        hash table map if it is present; otherwise the cell is created,        initialized, and put into the hash table map, and a pointer to        it is returned. */Cell *GetCell(int row, int col){    Cell *p;    int location = Hash(row, col);    for (p = map[location]; p; p = p->next)        if (p->row == row && p->col == col)            break;    if (!p) {        p = (Cell *)malloc(sizeof(Cell));        p->row = row;        p->col = col;        p->status = DEAD;        p->neighborcount = 0;        p->next = map[location];        map[location] = p;    }    return p;} /* Hash: calculate hash value. Pre:  None.Post: Calculated a value between 0 and HASHSIZE -1, inclusive. */int Hash(int row, int col){    return abs(row + FACTOR * col) % HASHSIZE;}  /* Kill: kill a cell if it should become dead. Pre:  The cell pointed by cell is a candidate to die.Post: Checks that cell in the hash table map pointed by cell     meets all requirements to die.  If not,    no change is made.  If so, then the pointer to the cell is added to    the list newdie. The cell status is set to DEAD.Uses: Function AddList, the      list newdie as global variables (side effects). */void Kill(ListEntry cell){    if (cell->status == ALIVE &&        cell->neighborcount != 2  && cell->neighborcount != 3) {        cell->status = DEAD;        AddList(cell, &newdie);    }}  /* SubtractNeighbors: subtract the neighbors for cell. Pre:  cell is a pointer to a cell that has just become dead.Post: The neighbors of the cell pointed to by cell have had their        neighbor count decreased. If the decreased neighbor count makes        the cell a candidate to be killed        then the pointer to the        cell has been added to the list maydie.Uses: Function AddList, changes list maydie as global        variables (side effects). */void SubtractNeighbors(ListEntry cell){    int nbrrow,     /* loop index for row of neighbor loops */        nbrcol;     /* column loop index */    Cell *neighbor; /* structure form of a neighbor */    for (nbrrow = cell->row-1; nbrrow <= cell->row+1; nbrrow++)        for (nbrcol = cell->col-1; nbrcol <= cell->col+1; nbrcol++)            if (nbrrow != cell->row || nbrcol != cell->col) {   /* Skip cell itself. */                neighbor = GetCell(nbrrow, nbrcol);                switch (--neighbor->neighborcount) {                case 1:                    if (neighbor->status == ALIVE)                        AddList(neighbor, &maydie);                    break;                case 3:                    if (neighbor->status == DEAD)                        AddList(neighbor, &maylive);                    break;                }   /* switch statement */            }}