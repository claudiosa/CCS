 /* Simulation of Conway's game of Life on a bounded gridPre:  The user must supply an initial configuration of living cells.Post: The program prints a sequence of maps showing the changes in    the configuration of living cells according to the rules for the    game of Life.Uses: functions Initialize, WriteMap, NeighborCount, and UserSaysYes */#include    "common.h"   /* common include files and definitions */#include    "life.h"     /* Life's defines, typedefs, and prototypes */void main(void){    int  row, col;    Grid map;                       /* current generation   */    Grid newmap;                    /* next generation      */    Initialize(map);    WriteMap(map);    printf("This is the initial configuration you have chosen.\n"           "Press <Enter> to continue.\n");    while(getchar() != '\n')        ;    do {        for (row = 1; row <= MAXROW;    row++)            for (col = 1; col <= MAXCOL; col++)                switch(NeighborCount(map, row, col)) {                case 0:                case 1:                    newmap[row][col]= DEAD;                    break;                case 2:                    newmap[row][col]= map[row][col];                    break;                case 3:                    newmap[row][col]= ALIVE;                    break;                case 4:                case 5:                case 6:                case 7:                case 8:                    newmap[row][col]= DEAD;                    break;                }        CopyMap(map, newmap);        WriteMap(map);        printf("Do you wish to continue viewing the new generations");    } while (UserSaysYes());} #include <stdio.h>#include <stdlib.h>typedef enum boolean { FALSE, TRUE } Boolean;void Error(char *);void Warning(char *); /* Error: report program error.Pre:    s points to the message to be printed.Post:  The function prints the message and terminates the program. */void Error(char *s){    fprintf(stderr, "%s\n", s);    exit(1);}#define   MAXROW        20          /* maximum row range        */#define   MAXCOL        60          /*  maximum column range    */typedef enum state { DEAD, ALIVE } State;typedef State Grid[MAXROW+2][MAXCOL+2];void    CopyMap(Grid map, Grid newmap);Boolean UserSaysYes(void);void    Initialize(Grid map);int     NeighborCount(Grid map, int row, int column);void    WriteMap(Grid map);switch { ... }while (tv == HOCK)    Study();if ( !sleepy)    Play();else    Nap(); void DoesSomething(int *first, int *second){    *first = *second - *first;    *second = *second - *first;    *first = *second + *first;}/* Swap: swap integer first with second     */void Swap(int *first, int *second){    int temp;    temp = *first;    *first = *second;    *second = temp;}#define MAXINT  100int Calculate(int apple, int orange){ int peach, lemon;peach = 0; lemon = 0; if (apple < orange) {peach = orange; } else if (orange <= apple) {peach = apple; } else { peach = MAXINT; lemon = MAXINT;} if (lemon != MAXINT) { return(peach); } } /* Max: return the largest of two integers      */int Max(int a, int b){    if (a < b)        return b;    else        return a;}double Figure(double vector1[], int n){ int loop1; double loop2; double loop3; int loop4;loop1 = 0; loop2 = vector1[loop1]; loop3 = 0.0;loop4 = loop1; for (loop4 = 0; loop4 < n; loop4 = loop4 + 1){ loop1 = loop1 + 1; loop2 = vector1[loop1-1];loop3 = loop2 + loop3; } loop2 = loop1;loop2 = loop3/loop2; return(loop2); } /* Mean: find the mean of an array of n numbers */double Mean(double v[], int n){     int i;     double sum = 0.0;     for (i = 0; i < n; i++)          sum += v[i];     return sum / n;}void Question(int *a17, int *stuff){ int another, yetanother, stillonemore;another = yetanother; stillonemore = *a17;yetanother = *stuff; another = stillonemore; *a17 = yetanother;stillonemore = yetanother;*stuff = another; another = yetanother; yetanother = *stuff; } /* Swap: swap integer first with second.     */void Swap(int *first, int *second){    int temp;    temp = *first;    *first = *second;    *second = temp;}int Mystery(int apple, int orange, int peach){ if (apple > orange) if (apple > peach) if(peach > orange) return(peach); else if (apple < orange)return(apple); else return(orange); else return(apple); elseif (peach > apple) if (peach > orange) return(orange); elsereturn(peach); else return(apple); } /* Median: find the middle value of three parameters    */int Median(int a, int b, int c){    if (a > b)        if (a > c)            if (c > b)                return c;            else                return b;        else            return a;    else if (c > a)        if (c > b)            return b;        else            return c;    else        return a;}if (x < z) if (x < y) if (y < z) c = 1; else c = 2; elseif (y < z) c = 3; else c = 4; else if (x < y)if (x < z) c = 5; else c = 6; else if (y < z) c = 7; elseif (z < x) if (z < y) c = 8; else c = 9; else c = 10;if (x < z)    if (x < y)        if (y < z)            c = 1;        else            c = 2;    else if (y < z)        c = 3;    else        c = 4;else if (x < y)    if (x < z)        c = 5;    else        c = 6;else if (y < z)    c = 7;else if (z < x)    if (z < y)        c = 8;    else        c = 9;else    c = 10;if (x < z) {    if (x < y)        if (y < z)            c = 1;        else            c = 2;    else if (y < z)        c = 3;} else if (x < y) {    if (x > z)        c = 6;} else if (y < z)    c = 7;else if (z < x)    if (z < y)        c = 8;if (x < z)    if (x < y)        if (y < z)            c = 1;        else            c = 2;    else        c = 3;else if (x < y)    c = 4;else if (y < z)    c = 5;else    c = 6;double Fcn(double stuff){ double april, tim, tiny, shadow, tom, tam, square;Boolean flag;tim = stuff; tam = stuff; tiny = 0.00001;if (stuff != 0) do { shadow = tim + tim;square = tim * tim;tom = (shadow + stuff/square);april = tom / 3;if (april * april * april - tam > -tiny)if (april * april * april - tam < tiny) flag = TRUE;else flag = FALSE; else flag = FALSE;if (flag == FALSE) tim = april; else tim = tam; }while (flag == FALSE);if (stuff == 0) return(stuff); else return(april); } #include    <math.h>#define TOLERANCE   0.00001/* CubeRoot:  find cube root of x with Newton method.       */double CubeRoot(double x){     double y, z;     y = z = x;     if (x != 0.0)          do {               z = (y + y + x / (y * y)) / 3.0;               y = z;          } while (fabs(z * z * z - x) > TOLERANCE);     return z;} #include    <math.h>#define TOLERANCE   0.00001/* Formula:  find cube root of x directly from the formula  */double Formula(double x){     double y = x;     if (x != 0.0)          do {               y = (2 * y + x / (y * y)) / 3.0;          } while (fabs(y * y * y - x) > TOLERANCE);     return y;}#include    <math.h>double Variance(double *, int);/* StandardDeviation:  calculate standard deviation of v[].  */double StandardDeviation(double v[], int n){     return sqrt(Variance(v, n));}double Mean(double *, int);/* Variance:  calculate the variance for n numbers in v[].   */double Variance(double v[], int n){    int    i;    double temp;    double sum_squares = 0.;    for (i = 0; i < n; i++)        sum_squares += v[i] * v[i];    temp = Mean(v, n);    return sum_squares / n - temp * temp;}/* Mean:  calculate the mean of an array of n numbers.       */double Mean(double v[], int n){     int i;     double sum = 0.0;     for (i = 0; i < n; i++)          sum += v[i];     return sum / n;}#include    "common.h"#include    "calls.h"/* Read coordinates from a file and plot coordinate pairs.   */void main(void){    FILE *fp;    double xmax, xmin;              /* bounds for x values  */    double ymax, ymin;              /* bounds for y values  */    double x, y;                    /* x, y values to plot  */    if ((fp = fopen("points", "r")) == NULL) {        fprintf(stderr, "Cannot open points file\n");        exit(1);    }    Bounds(fp, &xmax, &xmin, &ymax, &ymin);    DrawAxes(xmax, xmin, ymax, ymin);    fseek(fp, 0L, SEEK_SET);        /* reset beginning file */    while (fscanf(fp, "%lf %lf", &x, &y) != EOF)        Plot(x, y);}#include    "common.h"/* Bounds: determine maximum and minimum values for x and y. */void Bounds(FILE *fp, double *xmax, double *xmin,            double *ymax, double *ymin){    double x, y;    if (fscanf(fp, "%lf %lf", &x, &y) != EOF) {        *xmax = *xmin = x;        *ymax = *ymin = y;    }    while (fscanf(fp, "%lf %lf", &x, &y) != EOF) {        if (x < *xmin)            *xmin = x;        if (x > *xmax)            *xmax = x;        if (y < *ymin)            *ymin = y;        if (y > *ymax)            *ymax = y;    }}/* DrawAxes: draw x and y axes and labels.               */void DrawAxes(double xmax, double xmin,              double ymax, double ymin){}/* Plot: take a pair of points and plots them in the graph. */void Plot(double x, double y){} /* Initialize:  initialize grid map.                    */void Initialize(Grid map){}/* WriteMap:  write grid map.                           */void WriteMap(Grid map){}/* NeighborCount:  count neighbors of row,col.      */int NeighborCount(Grid map, int row, int col){    return 1;}/* NeighborCount:  count neighbors of row,col.Pre:   The pair row, col is a valid cell in a Life configuration.Post: The function returns the number of living neighbors of the living cell. */int NeighborCount(Grid map, int row, int col){    int i;              /* row of a neighbor of the cell (row,col)  */    int j;              /* column of a neighbor of the cell (row,col)   */    int count = 0;      /* counter of living neighbors                  */    for (i = row - 1; i <= row + 1; i++)        for (j = col - 1; j <= col + 1; j++)            if (map[i][j] == ALIVE)                count++;    if (map[row][col] == ALIVE)        count--;    return count;}/* Initialize:  initialize grid map.Pre:   None.Post: All the cells in the grid map have been set to    initial configuration of living cells. */void Initialize(Grid map){    int row, col;               /* coordinates of a cell    */    printf("This program is a simulation of the game of Life.\n"           "The grid has a size of %d rows and "           " %d columns.\n", MAXROW, MAXCOL);    for (row =  0; row <= MAXROW + 1; row++)        for (col = 0; col <= MAXCOL + 1; col++)            map[row][col] = DEAD; /* Set all cells empty, including the hedge. */    printf("On each line give a pair of coordinates for a living cell.\n"           "Terminate the list with the special pair 0 0.\n");    scanf("%d %d", &row, &col);    while (row != 0 || col != 0) {  /* Check termination condition. */        if (row >= 1 && row <= MAXROW && col >= 1 && col <= MAXCOL)            map[row][col] = ALIVE;        else            printf("Values are not within range.\n");        scanf("%d %d", &row, &col);    }    while (getchar() != '\n')       /* Discard remaining characters. */        ;}/* WriteMap:  display grid map.Pre:   The rectangular array  map contains the current Life configuration.Post: The current Life configuration is written for the user.*/void WriteMap(Grid map){    int row, col;    putchar('\n');    putchar('\n');    for (row = 1; row <= MAXROW; row++) {        for (col = 1; col <= MAXCOL; col++)            if (map[row][col] == ALIVE)                    putchar('*');            else                    putchar('-');        putchar('\n');    }}/* CopyMap:  copy newmap into map.Pre:   The grid newmap has the current Life configuration.Post: The grid map has a copy of newmap. */void CopyMap(Grid map, Grid newmap){    int row, col;    for (row = 0; row <= MAXROW + 1; row++)        for (col = 0; col <= MAXCOL + 1; col++)            map[row][col] = newmap[row][col];}/* UserSaysYes:  TRUE if the user wants to continue execution.Pre:   None.Post: Returns TRUE if the user's answer begins with either y or Y,    FALSE if the user responds with any response beginning with either    n or . */Boolean UserSaysYes(void){     int  c;    printf(" (y,n)? ");    do {        while ((c = getchar()) == '\n')            ;           /* Ignore new line character.   */        if (c == 'y' || c == 'Y' || c == 'n' || c == 'N')            return (c == 'y' || c == 'Y');        printf("Please respond by typing one of the letters y or n\n");    } while (1);}/* Driver:  test NeighborCount().Pre:   The user must supply an initial configuration of living cells.Post: The program repeatedly invokes NeighborCount and displays the      values returned. */int main(void){    Grid map;    int  i, j;    Initialize(map);    for (i = 0; i < MAXROW; i++) {        for (j = 0; j < MAXCOL; j++)            printf("%3d", NeighborCount(map, i, j));        printf("\n");    }    return 0;}Initialize(map);WriteMap(map);if (a < b) if (c > d) x = 1; else if (c == d) x = 2;else x = 3; else if (a == b) x = 4; else if (c == d) x = 5;else x = 6;